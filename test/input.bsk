
using std

let x: int = 3
let x = 3


local class AIEntity {
    function fact(x: int) -> int {
        match x {
            case 0 { return 1 }
            case 1 { return 1 }
            else {
                return x*fact(x-1)
            }        
        }        
    }
    
    function fact(x: int) -> int = match x {
        case 0 => 0
        case 1 => 1
        else => x*fact(x-1)    
    }

    function abs(x: int) -> int = match x {
        case x when x < 0 => -x
        else => x
    }    
}

local extern type ptrFILE

extern function fprintf(ptrFile, String)

abstract class AIEntity {
    function get(int) -> int
}

local function get() -> int {
    return 3
}

let local atomic  x = new AIEntity() {
    function init() {
        return -1
    } 
}

let x = [1, 2, std.String, let x = 3 in [1, 2, 3]]

synchronized function posAt(x: int) -> ( fn(int, int) -> (int, byte) , int) {
    using std
    return (1, 2)
   /* using std */
}

let y = system+(1, 2 ,3)
