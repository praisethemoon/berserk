
using std

let x: int = 3
let x = 3


local class AIEntity {
    function fact(x: int) -> int {
        match x {
            case 0 { return 1 }
            case 1 { return 1 }
            else {
                return x*fact(x-1)
            }        
        }        
    }
    
    function fact(x: int) -> int = match x {
        case 0 => 0
        case 1 => 1
        else => x*fact(x-1)    
    }

    function abs(x: int) -> int = match x {
        case x when x < 0 => -x
        else => x
    }    
}

local extern type ptrFILE

extern function fprintf(ptrFile, String)

abstract class AIEntity {
    function get(int) -> int
}

local function get() -> int {
    return 3
}

let local atomic  x = new AIEntity() {
    function init() {
        return -1
    } 
}

let x = [1, 2, std.String, let x = 3*100 in [1, 2, x]]

let y = [ for str: String in file.ReadAll() if !str.empty() => str ]
let z = [ for x: int in [1, 2, 3, 4] => x*x ]

synchronized function posAt(x: int) -> ( fn(int, int) -> (int, byte) , int) {
    using std
    return (1, 2)
   /* using std */
}

let y = system+(1, 2 ,3)

let w = new int[][13]
let w = new int[][13]

let x = ["hello", "world", "awesome", "berserk", "yeah!"]
let y = map(x, lambda(e: String) -> String = e.length())
/* now y = [5, 5, 7, 7, 5] */

/* can also be done via list comprehension */
let y = [for e: String in x => e.length()]
