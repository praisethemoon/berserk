/*

     ***** **                                                              *
  ******  ***                                                            **
 **   *  * **                                                            **
*    *  *  **                                                            **
    *  *   *              ***  ****       ****              ***  ****    **
   ** **  *        ***     **** **** *   * **** *    ***     **** **** * **  ***
   ** ** *        * ***     **   ****   **  ****    * ***     **   ****  ** * ***
   ** ***        *   ***    **         ****        *   ***    **         ***   *
   ** ** ***    **    ***   **           ***      **    ***   **         **   *
   ** **   ***  ********    **             ***    ********    **         **  *
   *  **     ** *******     **               ***  *******     **         ** **
      *      ** **          **          ****  **  **          **         ******
  ****     ***  ****    *   ***        * **** *   ****    *   ***        **  ***
 *  ********     *******     ***          ****     *******     ***       **   *** *
*     ****        *****                             *****                 **   ***
*
 **

Written by Soulaymen Chouri
Contact me @ akaisora@tuta.io

Copyright (c) 2016,Soulaymen Chouri (akaisora@tuta.io). All rights reserved.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the author nor the names of other contributors may be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>                  /* wchar_t */
#include <sys/stat.h>
#include <assert.h>
#include <string.h>

#include "Engine.h"                 /* The Kessels engine. */
#include "Grammar.h"                /* Generated by GOLD. */
#include "Parser.h"
#include "Defines.h"

#define TRIMREDUCTIONS 0            /* 0=off, 1=on */
#define DEBUG          1            /* 0=off, 1=on */


#define parseExpr(i, p) RuleJumpTable[Token->Tokens[i]->ReductionRule](Token->Tokens[i], p)
#define switchCaseExpr(i) case ET_##i: e->i = calloc(1, sizeof(e->i)); break
#define getToken(i) Token->Tokens[i]
#define match(t) assert(parent->type == t);


/***** Helper subroutines ***************************************************/


/* Make a readable copy of a string. All characters outside 32...127 are
displayed as a HEX number in square brackets, for example "[0A]". */
void ReadableString(wchar_t *Input, wchar_t *Output, long Width) {
    char s1[BUFSIZ];
    long i1;
    long i2;

    /* Sanity check. */
    if ((Output == NULL) || (Width < 1)) return;
    Output[0] = 0;
    if (Input == NULL) return;

    i1 = 0;
    i2 = 0;
    while ((i2 < Width - 1) && (Input[i1] != 0)) {
        if ((Input[i1] >= 32) && (Input[i1] <= 127)) {
            Output[i2++] = Input[i1];
        }
        else {
            if (Width - i2 > 4) {
                sprintf(s1, "%02X", Input[i1]);
                Output[i2++] = '[';
                Output[i2++] = s1[0];
                Output[i2++] = s1[1];
                Output[i2++] = ']';
            }
        }
        i1++;
    }
    Output[i2] = 0;
}


void ShowIndent(int Indent) {
    /*int i;
    for (i = 0; i < Indent; i++)
        report_Print("  ");*/
}


extern void (*RuleJumpTable[])(struct TokenStruct *Token, struct ContextStruct *Context);

/***** Rule subroutine template *********************************************/

/* This subroutine is a template of things that can happen in the
subroutine of a rule. It shows how to access the value of symbols
and how to call rules, and how to transport results and stuff via
the parent.

For example the rule:

<Increment> ::= <Expression> '+' Number

Has 3 sub-tokens:

Token->Tokens[0] = token for <Expression>, a rule
Token->Tokens[1] = token for '+', a symbol
Token->Tokens[2] = token for Number, a symbol

We know Token->Tokens[0] is a rule, because that's what the grammar
says. We may assume that the engine has fully populated the sub-tokens
and don't have to perform any checks. We can immediately call the
subroutine of the rule, like this:

RuleJumpTable[Token->Tokens[0]->ReductionRule](Token->Tokens[0],parent);

The subroutine should hand back it's results via the parent. Here
is an example of how to store a result in the parent:

parent->ReturnValue = (wchar_t *)wcsdup(....);

Symbols are literal strings from the input (that was parsed by the
engine), stored in the sub-token. We can get the value of the "Number"
symbol like this:

Value = (wchar_t *)wcsdup(Token->Tokens[2]->Data);

Further reading:
- See "engine.h" for the definition of the TokenStruct.
- See "readme.txt" for a short discussion on how to use the content
of a Token.
- See "example4.c" for a working template example.
*/

void RuleTemplate(struct TokenStruct *Token, struct ContextStruct *parent) {
    int i;

    /* Debugging: show the description of the rule. */
    if (parent->Debug > 0) {
        ShowIndent(parent->Indent);
        printf("Executing rule: %ls\n", Grammar.RuleArray[Token->ReductionRule].Description);
    }

    /* For all the sub-Tokens. */
    for (i = 0; i < Grammar.RuleArray[Token->ReductionRule].SymbolsCount; i++) {
        /* See if the Token is a Symbol or a Rule. */
        if (Token->Tokens[i]->ReductionRule < 0) {
            /* It's a Symbol. Make a copy of the Data. Most symbols are grammar,
            for example '+', 'function', 'while', and such, and you won't
            need to look at the Data. Other symbols are literals from the input
            script, for example numbers, strings, variable names, and such. */
            if (parent->ReturnValue != NULL) free(parent->ReturnValue);
            parent->ReturnValue = (wchar_t *)wcsdup(Token->Tokens[i]->Data);

            /* Debugging: show a description of the Symbol, and it's value. */
            if (parent->Debug > 0) {
                ShowIndent(parent->Indent + 1);
                printf("Token[%u] = Symbol('%ls') = '%ls'\n", i,
                    Grammar.SymbolArray[Token->Tokens[i]->Symbol].Name,
                    parent->ReturnValue);
            }

        }
        else {
            /* It's a rule. */

            /* Debugging: show a description of the rule. */
            if (parent->Debug > 0) {
                ShowIndent(parent->Indent + 1);
                printf("Token[%u] = Rule = %ls\n", i,
                    Grammar.RuleArray[Token->Tokens[i]->ReductionRule].Description);
            }

            /* Call the rule's subroutine via the RuleJumpTable. */
            parent->Indent = parent->Indent + 1;
            RuleJumpTable[Token->Tokens[i]->ReductionRule](Token->Tokens[i], parent);
            parent->Indent = parent->Indent - 1;

            /* At this point you will probably want to save the parent->ReturnValue
            somewhere. */

            /* Debugging: show the value that was returned by the rule's subroutine. */
            if (parent->Debug > 0) {
                ShowIndent(parent->Indent + 2);
                printf("Result value = %ls\n", parent->ReturnValue);
            }
        }
    }

    /* Do whatever processing is needed by the rule. Remember to free() the
    Values you have saved. */
}


/***** Rule subroutines *****************************************************/




/* <Decls> ::= <Decl> <Decls> */
void Rule_Decls(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decls> ::=  */
void Rule_Decls2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Func Decl> */
void Rule_Decl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Class Decl> */
void Rule_Decl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Enum Decl> */
void Rule_Decl3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Set Decl> */
void Rule_Decl4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= extern type Id */
void Rule_Decl_extern_type_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Var Decl> */
void Rule_Decl5(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Import> */
void Rule_Decl6(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <CDefFunc Decl> */
void Rule_Decl7(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Using Stm> */
void Rule_Decl8(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <CDefStruct> */
void Rule_Decl9(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= import <File Path> */
void Rule_Import_import(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= import <File Path> as Id */
void Rule_Import_import_as_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= from <File Path> import <File Path List> */
void Rule_Import_from_import(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path> ::= Id '.' <File Path> */
void Rule_FilePath_Id_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path> ::= Id */
void Rule_FilePath_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path List> ::= <File Path> ',' <File Path List> */
void Rule_FilePathList_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path List> ::= <File Path> */
void Rule_FilePathList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header> ::= Id '(' <Params> ')' */
void Rule_FnHeader_Id_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header> ::= Id '(' <Params> ')' '->' <Type> */
void Rule_FnHeader_Id_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header> ::= Id '(' <Types> ')' */
void Rule_FnHeader_Id_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header> ::= Id '(' <Types> ')' '->' <Type> */
void Rule_FnHeader_Id_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header> ::= Id '(' ')' */
void Rule_FnHeader_Id_LParen_RParen3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header> ::= Id '(' ')' '->' <Type> */
void Rule_FnHeader_Id_LParen_RParen_MinusGt3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= function <Fn Header> <Block> */
void Rule_FuncDecl_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= function <Fn Header> '=' <Expr> */
void Rule_FuncDecl_function_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <private final static inherited> function <Fn Header> */
void Rule_CFuncProto_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Decl> ::= <private final static inherited> function <Fn Header> <Block> */
void Rule_CFuncDecl_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Decl> ::= <private final static inherited> function <Fn Header> '=' <Expr> */
void Rule_CFuncDecl_function_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private */
void Rule_privatefinalstaticinherited_private(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= static */
void Rule_privatefinalstaticinherited_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= final */
void Rule_privatefinalstaticinherited_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= inherited */
void Rule_privatefinalstaticinherited_inherited(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private static */
void Rule_privatefinalstaticinherited_private_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= static private */
void Rule_privatefinalstaticinherited_static_private(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private inherited */
void Rule_privatefinalstaticinherited_private_inherited(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= inherited private */
void Rule_privatefinalstaticinherited_inherited_private(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= static final */
void Rule_privatefinalstaticinherited_static_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= final static */
void Rule_privatefinalstaticinherited_final_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private final */
void Rule_privatefinalstaticinherited_private_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= final static private */
void Rule_privatefinalstaticinherited_final_static_private(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= final private static */
void Rule_privatefinalstaticinherited_final_private_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= static final private */
void Rule_privatefinalstaticinherited_static_final_private(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= static private final */
void Rule_privatefinalstaticinherited_static_private_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private final static */
void Rule_privatefinalstaticinherited_private_final_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private static final */
void Rule_privatefinalstaticinherited_private_static_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::=  */
void Rule_privatefinalstaticinherited(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= extern function <Fn Header> */
void Rule_CDefFuncDecl_extern_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Params> ::= <Param> ',' <Params> */
void Rule_Params_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Params> ::= <Param> */
void Rule_Params(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Param> ::= final Id ':' <Type> */
void Rule_Param_final_Id_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Param> ::= Id ':' <Type> */
void Rule_Param_Id_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Types> ::= <Type> ',' <Types> */
void Rule_Types_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Types> ::= <Type> */
void Rule_Types(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Id List> ::= Id ',' <Id List> */
void Rule_IdList_Id_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Id List> ::= Id */
void Rule_IdList_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= <Normal Class> */
void Rule_ClassDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= <Abstract Class> */
void Rule_ClassDecl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Class> ::= class <Class Name> '{' <CDecls> '}' */
void Rule_NormalClass_class_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Class> ::= class <Class Name> extends <Extend Class Name List> '{' <CDecls> '}' */
void Rule_NormalClass_class_extends_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Abstract Class> ::= abstract class <Class Name> '{' <ACDecls> '}' */
void Rule_AbstractClass_abstract_class_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Abstract Class> ::= abstract class <Class Name> extends <Extend Class Name List> '{' <ACDecls> '}' */
void Rule_AbstractClass_abstract_class_extends_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Name> ::= Id */
void Rule_ClassName_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Name> ::= Id '<' <Id List> '>' */
void Rule_ClassName_Id_Lt_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name> ::= <Pkg> */
void Rule_ExtendClassName(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name> ::= <Pkg> '<' <Extend Class Name List> '>' */
void Rule_ExtendClassName_Lt_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name List> ::= <Extend Class Name> ',' <Extend Class Name List> */
void Rule_ExtendClassNameList_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name List> ::= <Extend Class Name> */
void Rule_ExtendClassNameList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecls> ::= <CDecl> <CDecls> */
void Rule_CDecls(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecls> ::=  */
void Rule_CDecls2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecls> ::= <ACDecl> <ACDecls> */
void Rule_ACDecls(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecls> ::=  */
void Rule_ACDecls2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <CFunc Decl> */
void Rule_CDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <CVar Decl> */
void Rule_CDecl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <Using Stm> */
void Rule_CDecl3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <Operator Stm> */
void Rule_CDecl4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CFunc Decl> */
void Rule_ACDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CFunc Proto> */
void Rule_ACDecl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CVar Decl> */
void Rule_ACDecl3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <Using Stm> */
void Rule_ACDecl4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <Operator Stm> */
void Rule_ACDecl5(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator Stm> ::= operator <Operator> <Op Header> '=' <Expr> */
void Rule_OperatorStm_operator_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator Stm> ::= operator <Operator> <Op Header> <Block> */
void Rule_OperatorStm_operator(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefStruct> ::= extern struct Id '{' <Params> '}' */
void Rule_CDefStruct_extern_struct_Id_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '+' */
void Rule_Operator_Plus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '-' */
void Rule_Operator_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '*' */
void Rule_Operator_Times(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '/' */
void Rule_Operator_Div(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '%' */
void Rule_Operator_Percent(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '^' */
void Rule_Operator_Caret(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&' */
void Rule_Operator_Amp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '|' */
void Rule_Operator_Pipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '~' */
void Rule_Operator_Tilde(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '!' */
void Rule_Operator_Exclam(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '=' */
void Rule_Operator_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<' */
void Rule_Operator_Lt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>' */
void Rule_Operator_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '+=' */
void Rule_Operator_PlusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '-=' */
void Rule_Operator_MinusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '*=' */
void Rule_Operator_TimesEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '/=' */
void Rule_Operator_DivEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '%=' */
void Rule_Operator_PercentEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '^=' */
void Rule_Operator_CaretEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&=' */
void Rule_Operator_AmpEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '|=' */
void Rule_Operator_PipeEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<<' */
void Rule_Operator_LtLt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>>' */
void Rule_Operator_GtGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>>=' */
void Rule_Operator_GtGtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<<=' */
void Rule_Operator_LtLtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '==' */
void Rule_Operator_EqEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '!=' */
void Rule_Operator_ExclamEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<=' */
void Rule_Operator_LtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>=' */
void Rule_Operator_GtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&&' */
void Rule_Operator_AmpAmp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '||' */
void Rule_Operator_PipePipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '++' */
void Rule_Operator_PlusPlus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '--' */
void Rule_Operator_MinusMinus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= ',' */
void Rule_Operator_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '(' ')' */
void Rule_Operator_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '[' ']' */
void Rule_Operator_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header> ::= '(' <Params> ')' */
void Rule_OpHeader_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header> ::= '(' <Params> ')' '->' <Type> */
void Rule_OpHeader_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header> ::= '(' <Types> ')' */
void Rule_OpHeader_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header> ::= '(' <Types> ')' '->' <Type> */
void Rule_OpHeader_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header> ::= '(' ')' */
void Rule_OpHeader_LParen_RParen3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header> ::= '(' ')' '->' <Type> */
void Rule_OpHeader_LParen_RParen_MinusGt3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let final <Var Header> */
void Rule_VarDecl_let_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let <Var Header> */
void Rule_VarDecl_let(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <private final static inherited> <Var Header> */
void Rule_CVarDecl_let(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> ':' <Type> '=' <Expr> */
void Rule_VarHeader_Colon_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> ':' <Type> */
void Rule_VarHeader_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> '=' <Expr> */
void Rule_VarHeader_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Decl> ::= enum Id '{' <Enum Def> '}' */
void Rule_EnumDecl_enum_Id_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Def> ::= Id ',' <Enum Def> */
void Rule_EnumDef_Id_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Def> ::= Id */
void Rule_EnumDef_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Set Decl> ::= set Id '{' <Enum Def> '}' */
void Rule_SetDecl_set_Id_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Base> */
void Rule_Type(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Fn Type> */
void Rule_Type2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Pkg> */
void Rule_Type3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Pkg> '<' <Types> '>' */
void Rule_Type_Lt_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Type> '[' ']' */
void Rule_Type_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= '(' <Type> ')' */
void Rule_Type_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' ')' */
void Rule_FnType_fn_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' ')' '->' <Type> */
void Rule_FnType_fn_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' <Types> ')' */
void Rule_FnType_fn_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' <Types> ')' '->' <Type> */
void Rule_FnType_fn_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type Constructor> ::= <Pkg> */
void Rule_TypeConstructor(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type Constructor> ::= <Pkg> '<' <Types> '>' */
void Rule_TypeConstructor_Lt_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= <Sign> <Scalar> */
void Rule_Base(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'size_t' */
void Rule_Base_size_t(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::= signed */
void Rule_Sign_signed(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::= unsigned */
void Rule_Sign_unsigned(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::=  */
void Rule_Sign(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= char */
void Rule_Scalar_char(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= int */
void Rule_Scalar_int(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= short */
void Rule_Scalar_short(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= long */
void Rule_Scalar_long(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= short int */
void Rule_Scalar_short_int(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= long int */
void Rule_Scalar_long_int(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= float */
void Rule_Scalar_float(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= double */
void Rule_Scalar_double(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= byte */
void Rule_Scalar_byte(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <Var Decl> */
void Rule_Stm(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <Using Stm> */
void Rule_Stm2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <If Stm> */
void Rule_Stm3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= while <Expr> <Block> */
void Rule_Stm_while(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= for <Arg> ';' <Arg> ';' <Arg> <Block> */
void Rule_Stm_for_Semi_Semi(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= foreach Id in <Expr> <Block> */
void Rule_Stm_foreach_Id_in(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <Normal Stm> */
void Rule_Stm4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Using Stm> ::= using <Pkg> */
void Rule_UsingStm_using(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg> ::= Id '.' <Pkg> */
void Rule_Pkg_Id_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg> ::= Id */
void Rule_Pkg_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <If Stm> ::= if <Expr> <Block> <else-if> */
void Rule_IfStm_if(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::= else if <Expr> <Block> <else-if> */
void Rule_elseif_else_if(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::= else <Block> */
void Rule_elseif_else(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::=  */
void Rule_elseif(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= do <Block> while <Expr> */
void Rule_NormalStm_do_while(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= match <Expr> '{' <Case Stms> '}' */
void Rule_NormalStm_match_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= <Block> */
void Rule_NormalStm(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= <Expr> */
void Rule_NormalStm2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= break */
void Rule_NormalStm_break(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= continue */
void Rule_NormalStm_continue(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= return <Expr> */
void Rule_NormalStm_return(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= return */
void Rule_NormalStm_return2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= ';' */
void Rule_NormalStm_Semi(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Arg> ::= <Expr> */
void Rule_Arg(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Arg> ::=  */
void Rule_Arg2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= case <Expr> when <Expr> <Block> <Case Stms> */
void Rule_CaseStms_case_when(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= case <Expr> <Block> <Case Stms> */
void Rule_CaseStms_case(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= else <Block> */
void Rule_CaseStms_else(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Block> ::= '{' <Stm List> '}' */
void Rule_Block_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm List> ::= <Stm> <Stm List> */
void Rule_StmList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm List> ::=  */
void Rule_StmList2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Var Decl> in <Expr> */
void Rule_Expr_in(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Func Decl> in <Expr> */
void Rule_Expr_in2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= match <Expr> '{' <Case Exprs> '}' */
void Rule_Expr_match_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Expr> ',' <Op Assign> */
void Rule_Expr_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Op Assign> */
void Rule_Expr(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '=' <Op Assign> */
void Rule_OpAssign_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '+=' <Op Assign> */
void Rule_OpAssign_PlusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '-=' <Op Assign> */
void Rule_OpAssign_MinusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '*=' <Op Assign> */
void Rule_OpAssign_TimesEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '/=' <Op Assign> */
void Rule_OpAssign_DivEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '^=' <Op Assign> */
void Rule_OpAssign_CaretEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '&=' <Op Assign> */
void Rule_OpAssign_AmpEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '|=' <Op Assign> */
void Rule_OpAssign_PipeEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '>>=' <Op Assign> */
void Rule_OpAssign_GtGtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '<<=' <Op Assign> */
void Rule_OpAssign_LtLtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> */
void Rule_OpAssign(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Or> ::= <Op Or> '||' <Op And> */
void Rule_OpOr_PipePipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Or> ::= <Op And> */
void Rule_OpOr(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op And> ::= <Op And> '&&' <Op BinOR> */
void Rule_OpAnd_AmpAmp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op And> ::= <Op BinOR> */
void Rule_OpAnd(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> */
void Rule_OpBinOR_Pipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinOR> ::= <Op BinXOR> */
void Rule_OpBinOR(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> */
void Rule_OpBinXOR_Caret(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinXOR> ::= <Op BinAND> */
void Rule_OpBinXOR(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinAND> ::= <Op BinAND> '&' <Op Equate> */
void Rule_OpBinAND_Amp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinAND> ::= <Op Equate> */
void Rule_OpBinAND(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Equate> '==' <Op Compare> */
void Rule_OpEquate_EqEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Equate> '!=' <Op Compare> */
void Rule_OpEquate_ExclamEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Compare> */
void Rule_OpEquate(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '<' <Op Shift> */
void Rule_OpCompare_Lt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '>' <Op Shift> */
void Rule_OpCompare_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '<=' <Op Shift> */
void Rule_OpCompare_LtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '>=' <Op Shift> */
void Rule_OpCompare_GtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> is <Type> */
void Rule_OpCompare_is(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> in <Op Shift> */
void Rule_OpCompare_in(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Shift> */
void Rule_OpCompare(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Shift> '<<' <Op Add> */
void Rule_OpShift_LtLt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Shift> '>>' <Op Add> */
void Rule_OpShift_GtGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Add> */
void Rule_OpShift(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Add> '+' <Op Mult> */
void Rule_OpAdd_Plus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Add> '-' <Op Mult> */
void Rule_OpAdd_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Mult> */
void Rule_OpAdd(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '*' <Op Unary> */
void Rule_OpMult_Times(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '/' <Op Unary> */
void Rule_OpMult_Div(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '%' <Op Unary> */
void Rule_OpMult_Percent(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Unary> */
void Rule_OpMult(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '!' <Op Unary> */
void Rule_OpUnary_Exclam(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '~' <Op Unary> */
void Rule_OpUnary_Tilde(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '-' <Op Unary> */
void Rule_OpUnary_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '*' <Op Unary> */
void Rule_OpUnary_Times(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '&' <Op Unary> */
void Rule_OpUnary_Amp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '++' <Op Unary> */
void Rule_OpUnary_PlusPlus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '--' <Op Unary> */
void Rule_OpUnary_MinusMinus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> '++' */
void Rule_OpUnary_PlusPlus2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> '--' */
void Rule_OpUnary_MinusMinus2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Unary> as <Type> */
void Rule_OpUnary_as(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <New Expr> */
void Rule_OpUnary(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= delete <Op Pointer> */
void Rule_OpUnary_delete(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= sizeof '(' <Type> ')' */
void Rule_OpUnary_sizeof_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> */
void Rule_OpUnary2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '.' <Value> */
void Rule_OpPointer_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '[' <Expr> ']' */
void Rule_OpPointer_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '(' <Expr> ')' */
void Rule_OpPointer_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '(' ')' */
void Rule_OpPointer_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Value> */
void Rule_OpPointer(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= OctLiteral */
void Rule_Value_OctLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= HexLiteral */
void Rule_Value_HexLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= DecLiteral */
void Rule_Value_DecLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= BinLiteral */
void Rule_Value_BinLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= StringLiteral */
void Rule_Value_StringLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= CharLiteral */
void Rule_Value_CharLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= FloatLiteral */
void Rule_Value_FloatLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= null */
void Rule_Value_null(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= <Pkg> */
void Rule_Value(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= <Lambda Expr> */
void Rule_Value2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '(' <Expr> ')' */
void Rule_Value_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '{' <Expr> '}' */
void Rule_Value_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' <Block> */
void Rule_LambdaExpr_lambda_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> */
void Rule_LambdaExpr_lambda_LParen_RParen_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> */
void Rule_LambdaExpr_lambda_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> */
void Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> */
void Rule_CaseExprs_case_when_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> */
void Rule_CaseExprs_case_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= else '=>' <Expr> */
void Rule_CaseExprs_else_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> '(' ')' */
void Rule_NewExpr_new_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> '(' <Expr> ')' */
void Rule_NewExpr_new_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> */
void Rule_NewExpr_new(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> '(' ')' '{' <CDecl> '}' */
void Rule_NewExpr_new_LParen_RParen_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> '(' <Expr> ')' '{' <CDecl> '}' */
void Rule_NewExpr_new_LParen_RParen_LBrace_RBrace2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/***** Rule jumptable *******************************************************/




extern void (*RuleJumpTable[])(struct TokenStruct *Token, struct ContextStruct *Context) = {

  /* 0. <Decls> ::= <Decl> <Decls> */
  Rule_Decls,

  /* 1. <Decls> ::=  */
  Rule_Decls2,

  /* 2. <Decl> ::= <Func Decl> */
  Rule_Decl,

  /* 3. <Decl> ::= <Class Decl> */
  Rule_Decl2,

  /* 4. <Decl> ::= <Enum Decl> */
  Rule_Decl3,

  /* 5. <Decl> ::= <Set Decl> */
  Rule_Decl4,

  /* 6. <Decl> ::= extern type Id */
  Rule_Decl_extern_type_Id,

  /* 7. <Decl> ::= <Var Decl> */
  Rule_Decl5,

  /* 8. <Decl> ::= <Import> */
  Rule_Decl6,

  /* 9. <Decl> ::= <CDefFunc Decl> */
  Rule_Decl7,

  /* 10. <Decl> ::= <Using Stm> */
  Rule_Decl8,

  /* 11. <Decl> ::= <CDefStruct> */
  Rule_Decl9,

  /* 12. <Import> ::= import <File Path> */
  Rule_Import_import,

  /* 13. <Import> ::= import <File Path> as Id */
  Rule_Import_import_as_Id,

  /* 14. <Import> ::= from <File Path> import <File Path List> */
  Rule_Import_from_import,

  /* 15. <File Path> ::= Id '.' <File Path> */
  Rule_FilePath_Id_Dot,

  /* 16. <File Path> ::= Id */
  Rule_FilePath_Id,

  /* 17. <File Path List> ::= <File Path> ',' <File Path List> */
  Rule_FilePathList_Comma,

  /* 18. <File Path List> ::= <File Path> */
  Rule_FilePathList,

  /* 19. <Fn Header> ::= Id '(' <Params> ')' */
  Rule_FnHeader_Id_LParen_RParen,

  /* 20. <Fn Header> ::= Id '(' <Params> ')' '->' <Type> */
  Rule_FnHeader_Id_LParen_RParen_MinusGt,

  /* 21. <Fn Header> ::= Id '(' <Types> ')' */
  Rule_FnHeader_Id_LParen_RParen2,

  /* 22. <Fn Header> ::= Id '(' <Types> ')' '->' <Type> */
  Rule_FnHeader_Id_LParen_RParen_MinusGt2,

  /* 23. <Fn Header> ::= Id '(' ')' */
  Rule_FnHeader_Id_LParen_RParen3,

  /* 24. <Fn Header> ::= Id '(' ')' '->' <Type> */
  Rule_FnHeader_Id_LParen_RParen_MinusGt3,

  /* 25. <Func Decl> ::= function <Fn Header> <Block> */
  Rule_FuncDecl_function,

  /* 26. <Func Decl> ::= function <Fn Header> '=' <Expr> */
  Rule_FuncDecl_function_Eq,

  /* 27. <CFunc Proto> ::= <private final static inherited> function <Fn Header> */
  Rule_CFuncProto_function,

  /* 28. <CFunc Decl> ::= <private final static inherited> function <Fn Header> <Block> */
  Rule_CFuncDecl_function,

  /* 29. <CFunc Decl> ::= <private final static inherited> function <Fn Header> '=' <Expr> */
  Rule_CFuncDecl_function_Eq,

  /* 30. <private final static inherited> ::= private */
  Rule_privatefinalstaticinherited_private,

  /* 31. <private final static inherited> ::= static */
  Rule_privatefinalstaticinherited_static,

  /* 32. <private final static inherited> ::= final */
  Rule_privatefinalstaticinherited_final,

  /* 33. <private final static inherited> ::= inherited */
  Rule_privatefinalstaticinherited_inherited,

  /* 34. <private final static inherited> ::= private static */
  Rule_privatefinalstaticinherited_private_static,

  /* 35. <private final static inherited> ::= static private */
  Rule_privatefinalstaticinherited_static_private,

  /* 36. <private final static inherited> ::= private inherited */
  Rule_privatefinalstaticinherited_private_inherited,

  /* 37. <private final static inherited> ::= inherited private */
  Rule_privatefinalstaticinherited_inherited_private,

  /* 38. <private final static inherited> ::= static final */
  Rule_privatefinalstaticinherited_static_final,

  /* 39. <private final static inherited> ::= final static */
  Rule_privatefinalstaticinherited_final_static,

  /* 40. <private final static inherited> ::= private final */
  Rule_privatefinalstaticinherited_private_final,

  /* 41. <private final static inherited> ::= final static private */
  Rule_privatefinalstaticinherited_final_static_private,

  /* 42. <private final static inherited> ::= final private static */
  Rule_privatefinalstaticinherited_final_private_static,

  /* 43. <private final static inherited> ::= static final private */
  Rule_privatefinalstaticinherited_static_final_private,

  /* 44. <private final static inherited> ::= static private final */
  Rule_privatefinalstaticinherited_static_private_final,

  /* 45. <private final static inherited> ::= private final static */
  Rule_privatefinalstaticinherited_private_final_static,

  /* 46. <private final static inherited> ::= private static final */
  Rule_privatefinalstaticinherited_private_static_final,

  /* 47. <private final static inherited> ::=  */
  Rule_privatefinalstaticinherited,

  /* 48. <CDefFunc Decl> ::= extern function <Fn Header> */
  Rule_CDefFuncDecl_extern_function,

  /* 49. <Params> ::= <Param> ',' <Params> */
  Rule_Params_Comma,

  /* 50. <Params> ::= <Param> */
  Rule_Params,

  /* 51. <Param> ::= final Id ':' <Type> */
  Rule_Param_final_Id_Colon,

  /* 52. <Param> ::= Id ':' <Type> */
  Rule_Param_Id_Colon,

  /* 53. <Types> ::= <Type> ',' <Types> */
  Rule_Types_Comma,

  /* 54. <Types> ::= <Type> */
  Rule_Types,

  /* 55. <Id List> ::= Id ',' <Id List> */
  Rule_IdList_Id_Comma,

  /* 56. <Id List> ::= Id */
  Rule_IdList_Id,

  /* 57. <Class Decl> ::= <Normal Class> */
  Rule_ClassDecl,

  /* 58. <Class Decl> ::= <Abstract Class> */
  Rule_ClassDecl2,

  /* 59. <Normal Class> ::= class <Class Name> '{' <CDecls> '}' */
  Rule_NormalClass_class_LBrace_RBrace,

  /* 60. <Normal Class> ::= class <Class Name> extends <Extend Class Name List> '{' <CDecls> '}' */
  Rule_NormalClass_class_extends_LBrace_RBrace,

  /* 61. <Abstract Class> ::= abstract class <Class Name> '{' <ACDecls> '}' */
  Rule_AbstractClass_abstract_class_LBrace_RBrace,

  /* 62. <Abstract Class> ::= abstract class <Class Name> extends <Extend Class Name List> '{' <ACDecls> '}' */
  Rule_AbstractClass_abstract_class_extends_LBrace_RBrace,

  /* 63. <Class Name> ::= Id */
  Rule_ClassName_Id,

  /* 64. <Class Name> ::= Id '<' <Id List> '>' */
  Rule_ClassName_Id_Lt_Gt,

  /* 65. <Extend Class Name> ::= <Pkg> */
  Rule_ExtendClassName,

  /* 66. <Extend Class Name> ::= <Pkg> '<' <Extend Class Name List> '>' */
  Rule_ExtendClassName_Lt_Gt,

  /* 67. <Extend Class Name List> ::= <Extend Class Name> ',' <Extend Class Name List> */
  Rule_ExtendClassNameList_Comma,

  /* 68. <Extend Class Name List> ::= <Extend Class Name> */
  Rule_ExtendClassNameList,

  /* 69. <CDecls> ::= <CDecl> <CDecls> */
  Rule_CDecls,

  /* 70. <CDecls> ::=  */
  Rule_CDecls2,

  /* 71. <ACDecls> ::= <ACDecl> <ACDecls> */
  Rule_ACDecls,

  /* 72. <ACDecls> ::=  */
  Rule_ACDecls2,

  /* 73. <CDecl> ::= <CFunc Decl> */
  Rule_CDecl,

  /* 74. <CDecl> ::= <CVar Decl> */
  Rule_CDecl2,

  /* 75. <CDecl> ::= <Using Stm> */
  Rule_CDecl3,

  /* 76. <CDecl> ::= <Operator Stm> */
  Rule_CDecl4,

  /* 77. <ACDecl> ::= <CFunc Decl> */
  Rule_ACDecl,

  /* 78. <ACDecl> ::= <CFunc Proto> */
  Rule_ACDecl2,

  /* 79. <ACDecl> ::= <CVar Decl> */
  Rule_ACDecl3,

  /* 80. <ACDecl> ::= <Using Stm> */
  Rule_ACDecl4,

  /* 81. <ACDecl> ::= <Operator Stm> */
  Rule_ACDecl5,

  /* 82. <Operator Stm> ::= operator <Operator> <Op Header> '=' <Expr> */
  Rule_OperatorStm_operator_Eq,

  /* 83. <Operator Stm> ::= operator <Operator> <Op Header> <Block> */
  Rule_OperatorStm_operator,

  /* 84. <CDefStruct> ::= extern struct Id '{' <Params> '}' */
  Rule_CDefStruct_extern_struct_Id_LBrace_RBrace,

  /* 85. <Operator> ::= '+' */
  Rule_Operator_Plus,

  /* 86. <Operator> ::= '-' */
  Rule_Operator_Minus,

  /* 87. <Operator> ::= '*' */
  Rule_Operator_Times,

  /* 88. <Operator> ::= '/' */
  Rule_Operator_Div,

  /* 89. <Operator> ::= '%' */
  Rule_Operator_Percent,

  /* 90. <Operator> ::= '^' */
  Rule_Operator_Caret,

  /* 91. <Operator> ::= '&' */
  Rule_Operator_Amp,

  /* 92. <Operator> ::= '|' */
  Rule_Operator_Pipe,

  /* 93. <Operator> ::= '~' */
  Rule_Operator_Tilde,

  /* 94. <Operator> ::= '!' */
  Rule_Operator_Exclam,

  /* 95. <Operator> ::= '=' */
  Rule_Operator_Eq,

  /* 96. <Operator> ::= '<' */
  Rule_Operator_Lt,

  /* 97. <Operator> ::= '>' */
  Rule_Operator_Gt,

  /* 98. <Operator> ::= '+=' */
  Rule_Operator_PlusEq,

  /* 99. <Operator> ::= '-=' */
  Rule_Operator_MinusEq,

  /* 100. <Operator> ::= '*=' */
  Rule_Operator_TimesEq,

  /* 101. <Operator> ::= '/=' */
  Rule_Operator_DivEq,

  /* 102. <Operator> ::= '%=' */
  Rule_Operator_PercentEq,

  /* 103. <Operator> ::= '^=' */
  Rule_Operator_CaretEq,

  /* 104. <Operator> ::= '&=' */
  Rule_Operator_AmpEq,

  /* 105. <Operator> ::= '|=' */
  Rule_Operator_PipeEq,

  /* 106. <Operator> ::= '<<' */
  Rule_Operator_LtLt,

  /* 107. <Operator> ::= '>>' */
  Rule_Operator_GtGt,

  /* 108. <Operator> ::= '>>=' */
  Rule_Operator_GtGtEq,

  /* 109. <Operator> ::= '<<=' */
  Rule_Operator_LtLtEq,

  /* 110. <Operator> ::= '==' */
  Rule_Operator_EqEq,

  /* 111. <Operator> ::= '!=' */
  Rule_Operator_ExclamEq,

  /* 112. <Operator> ::= '<=' */
  Rule_Operator_LtEq,

  /* 113. <Operator> ::= '>=' */
  Rule_Operator_GtEq,

  /* 114. <Operator> ::= '&&' */
  Rule_Operator_AmpAmp,

  /* 115. <Operator> ::= '||' */
  Rule_Operator_PipePipe,

  /* 116. <Operator> ::= '++' */
  Rule_Operator_PlusPlus,

  /* 117. <Operator> ::= '--' */
  Rule_Operator_MinusMinus,

  /* 118. <Operator> ::= ',' */
  Rule_Operator_Comma,

  /* 119. <Operator> ::= '(' ')' */
  Rule_Operator_LParen_RParen,

  /* 120. <Operator> ::= '[' ']' */
  Rule_Operator_LBracket_RBracket,

  /* 121. <Op Header> ::= '(' <Params> ')' */
  Rule_OpHeader_LParen_RParen,

  /* 122. <Op Header> ::= '(' <Params> ')' '->' <Type> */
  Rule_OpHeader_LParen_RParen_MinusGt,

  /* 123. <Op Header> ::= '(' <Types> ')' */
  Rule_OpHeader_LParen_RParen2,

  /* 124. <Op Header> ::= '(' <Types> ')' '->' <Type> */
  Rule_OpHeader_LParen_RParen_MinusGt2,

  /* 125. <Op Header> ::= '(' ')' */
  Rule_OpHeader_LParen_RParen3,

  /* 126. <Op Header> ::= '(' ')' '->' <Type> */
  Rule_OpHeader_LParen_RParen_MinusGt3,

  /* 127. <Var Decl> ::= let final <Var Header> */
  Rule_VarDecl_let_final,

  /* 128. <Var Decl> ::= let <Var Header> */
  Rule_VarDecl_let,

  /* 129. <CVar Decl> ::= let <private final static inherited> <Var Header> */
  Rule_CVarDecl_let,

  /* 130. <Var Header> ::= <Id List> ':' <Type> '=' <Expr> */
  Rule_VarHeader_Colon_Eq,

  /* 131. <Var Header> ::= <Id List> ':' <Type> */
  Rule_VarHeader_Colon,

  /* 132. <Var Header> ::= <Id List> '=' <Expr> */
  Rule_VarHeader_Eq,

  /* 133. <Enum Decl> ::= enum Id '{' <Enum Def> '}' */
  Rule_EnumDecl_enum_Id_LBrace_RBrace,

  /* 134. <Enum Def> ::= Id ',' <Enum Def> */
  Rule_EnumDef_Id_Comma,

  /* 135. <Enum Def> ::= Id */
  Rule_EnumDef_Id,

  /* 136. <Set Decl> ::= set Id '{' <Enum Def> '}' */
  Rule_SetDecl_set_Id_LBrace_RBrace,

  /* 137. <Type> ::= <Base> */
  Rule_Type,

  /* 138. <Type> ::= <Fn Type> */
  Rule_Type2,

  /* 139. <Type> ::= <Pkg> */
  Rule_Type3,

  /* 140. <Type> ::= <Pkg> '<' <Types> '>' */
  Rule_Type_Lt_Gt,

  /* 141. <Type> ::= <Type> '[' ']' */
  Rule_Type_LBracket_RBracket,

  /* 142. <Type> ::= '(' <Type> ')' */
  Rule_Type_LParen_RParen,

  /* 143. <Fn Type> ::= fn '(' ')' */
  Rule_FnType_fn_LParen_RParen,

  /* 144. <Fn Type> ::= fn '(' ')' '->' <Type> */
  Rule_FnType_fn_LParen_RParen_MinusGt,

  /* 145. <Fn Type> ::= fn '(' <Types> ')' */
  Rule_FnType_fn_LParen_RParen2,

  /* 146. <Fn Type> ::= fn '(' <Types> ')' '->' <Type> */
  Rule_FnType_fn_LParen_RParen_MinusGt2,

  /* 147. <Type Constructor> ::= <Pkg> */
  Rule_TypeConstructor,

  /* 148. <Type Constructor> ::= <Pkg> '<' <Types> '>' */
  Rule_TypeConstructor_Lt_Gt,

  /* 149. <Base> ::= <Sign> <Scalar> */
  Rule_Base,

  /* 150. <Base> ::= 'size_t' */
  Rule_Base_size_t,

  /* 151. <Sign> ::= signed */
  Rule_Sign_signed,

  /* 152. <Sign> ::= unsigned */
  Rule_Sign_unsigned,

  /* 153. <Sign> ::=  */
  Rule_Sign,

  /* 154. <Scalar> ::= char */
  Rule_Scalar_char,

  /* 155. <Scalar> ::= int */
  Rule_Scalar_int,

  /* 156. <Scalar> ::= short */
  Rule_Scalar_short,

  /* 157. <Scalar> ::= long */
  Rule_Scalar_long,

  /* 158. <Scalar> ::= short int */
  Rule_Scalar_short_int,

  /* 159. <Scalar> ::= long int */
  Rule_Scalar_long_int,

  /* 160. <Scalar> ::= float */
  Rule_Scalar_float,

  /* 161. <Scalar> ::= double */
  Rule_Scalar_double,

  /* 162. <Scalar> ::= byte */
  Rule_Scalar_byte,

  /* 163. <Stm> ::= <Var Decl> */
  Rule_Stm,

  /* 164. <Stm> ::= <Using Stm> */
  Rule_Stm2,

  /* 165. <Stm> ::= <If Stm> */
  Rule_Stm3,

  /* 166. <Stm> ::= while <Expr> <Block> */
  Rule_Stm_while,

  /* 167. <Stm> ::= for <Arg> ';' <Arg> ';' <Arg> <Block> */
  Rule_Stm_for_Semi_Semi,

  /* 168. <Stm> ::= foreach Id in <Expr> <Block> */
  Rule_Stm_foreach_Id_in,

  /* 169. <Stm> ::= <Normal Stm> */
  Rule_Stm4,

  /* 170. <Using Stm> ::= using <Pkg> */
  Rule_UsingStm_using,

  /* 171. <Pkg> ::= Id '.' <Pkg> */
  Rule_Pkg_Id_Dot,

  /* 172. <Pkg> ::= Id */
  Rule_Pkg_Id,

  /* 173. <If Stm> ::= if <Expr> <Block> <else-if> */
  Rule_IfStm_if,

  /* 174. <else-if> ::= else if <Expr> <Block> <else-if> */
  Rule_elseif_else_if,

  /* 175. <else-if> ::= else <Block> */
  Rule_elseif_else,

  /* 176. <else-if> ::=  */
  Rule_elseif,

  /* 177. <Normal Stm> ::= do <Block> while <Expr> */
  Rule_NormalStm_do_while,

  /* 178. <Normal Stm> ::= match <Expr> '{' <Case Stms> '}' */
  Rule_NormalStm_match_LBrace_RBrace,

  /* 179. <Normal Stm> ::= <Block> */
  Rule_NormalStm,

  /* 180. <Normal Stm> ::= <Expr> */
  Rule_NormalStm2,

  /* 181. <Normal Stm> ::= break */
  Rule_NormalStm_break,

  /* 182. <Normal Stm> ::= continue */
  Rule_NormalStm_continue,

  /* 183. <Normal Stm> ::= return <Expr> */
  Rule_NormalStm_return,

  /* 184. <Normal Stm> ::= return */
  Rule_NormalStm_return2,

  /* 185. <Normal Stm> ::= ';' */
  Rule_NormalStm_Semi,

  /* 186. <Arg> ::= <Expr> */
  Rule_Arg,

  /* 187. <Arg> ::=  */
  Rule_Arg2,

  /* 188. <Case Stms> ::= case <Expr> when <Expr> <Block> <Case Stms> */
  Rule_CaseStms_case_when,

  /* 189. <Case Stms> ::= case <Expr> <Block> <Case Stms> */
  Rule_CaseStms_case,

  /* 190. <Case Stms> ::= else <Block> */
  Rule_CaseStms_else,

  /* 191. <Block> ::= '{' <Stm List> '}' */
  Rule_Block_LBrace_RBrace,

  /* 192. <Stm List> ::= <Stm> <Stm List> */
  Rule_StmList,

  /* 193. <Stm List> ::=  */
  Rule_StmList2,

  /* 194. <Expr> ::= <Var Decl> in <Expr> */
  Rule_Expr_in,

  /* 195. <Expr> ::= <Func Decl> in <Expr> */
  Rule_Expr_in2,

  /* 196. <Expr> ::= match <Expr> '{' <Case Exprs> '}' */
  Rule_Expr_match_LBrace_RBrace,

  /* 197. <Expr> ::= <Expr> ',' <Op Assign> */
  Rule_Expr_Comma,

  /* 198. <Expr> ::= <Op Assign> */
  Rule_Expr,

  /* 199. <Op Assign> ::= <Op Or> '=' <Op Assign> */
  Rule_OpAssign_Eq,

  /* 200. <Op Assign> ::= <Op Or> '+=' <Op Assign> */
  Rule_OpAssign_PlusEq,

  /* 201. <Op Assign> ::= <Op Or> '-=' <Op Assign> */
  Rule_OpAssign_MinusEq,

  /* 202. <Op Assign> ::= <Op Or> '*=' <Op Assign> */
  Rule_OpAssign_TimesEq,

  /* 203. <Op Assign> ::= <Op Or> '/=' <Op Assign> */
  Rule_OpAssign_DivEq,

  /* 204. <Op Assign> ::= <Op Or> '^=' <Op Assign> */
  Rule_OpAssign_CaretEq,

  /* 205. <Op Assign> ::= <Op Or> '&=' <Op Assign> */
  Rule_OpAssign_AmpEq,

  /* 206. <Op Assign> ::= <Op Or> '|=' <Op Assign> */
  Rule_OpAssign_PipeEq,

  /* 207. <Op Assign> ::= <Op Or> '>>=' <Op Assign> */
  Rule_OpAssign_GtGtEq,

  /* 208. <Op Assign> ::= <Op Or> '<<=' <Op Assign> */
  Rule_OpAssign_LtLtEq,

  /* 209. <Op Assign> ::= <Op Or> */
  Rule_OpAssign,

  /* 210. <Op Or> ::= <Op Or> '||' <Op And> */
  Rule_OpOr_PipePipe,

  /* 211. <Op Or> ::= <Op And> */
  Rule_OpOr,

  /* 212. <Op And> ::= <Op And> '&&' <Op BinOR> */
  Rule_OpAnd_AmpAmp,

  /* 213. <Op And> ::= <Op BinOR> */
  Rule_OpAnd,

  /* 214. <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> */
  Rule_OpBinOR_Pipe,

  /* 215. <Op BinOR> ::= <Op BinXOR> */
  Rule_OpBinOR,

  /* 216. <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> */
  Rule_OpBinXOR_Caret,

  /* 217. <Op BinXOR> ::= <Op BinAND> */
  Rule_OpBinXOR,

  /* 218. <Op BinAND> ::= <Op BinAND> '&' <Op Equate> */
  Rule_OpBinAND_Amp,

  /* 219. <Op BinAND> ::= <Op Equate> */
  Rule_OpBinAND,

  /* 220. <Op Equate> ::= <Op Equate> '==' <Op Compare> */
  Rule_OpEquate_EqEq,

  /* 221. <Op Equate> ::= <Op Equate> '!=' <Op Compare> */
  Rule_OpEquate_ExclamEq,

  /* 222. <Op Equate> ::= <Op Compare> */
  Rule_OpEquate,

  /* 223. <Op Compare> ::= <Op Compare> '<' <Op Shift> */
  Rule_OpCompare_Lt,

  /* 224. <Op Compare> ::= <Op Compare> '>' <Op Shift> */
  Rule_OpCompare_Gt,

  /* 225. <Op Compare> ::= <Op Compare> '<=' <Op Shift> */
  Rule_OpCompare_LtEq,

  /* 226. <Op Compare> ::= <Op Compare> '>=' <Op Shift> */
  Rule_OpCompare_GtEq,

  /* 227. <Op Compare> ::= <Op Compare> is <Type> */
  Rule_OpCompare_is,

  /* 228. <Op Compare> ::= <Op Compare> in <Op Shift> */
  Rule_OpCompare_in,

  /* 229. <Op Compare> ::= <Op Shift> */
  Rule_OpCompare,

  /* 230. <Op Shift> ::= <Op Shift> '<<' <Op Add> */
  Rule_OpShift_LtLt,

  /* 231. <Op Shift> ::= <Op Shift> '>>' <Op Add> */
  Rule_OpShift_GtGt,

  /* 232. <Op Shift> ::= <Op Add> */
  Rule_OpShift,

  /* 233. <Op Add> ::= <Op Add> '+' <Op Mult> */
  Rule_OpAdd_Plus,

  /* 234. <Op Add> ::= <Op Add> '-' <Op Mult> */
  Rule_OpAdd_Minus,

  /* 235. <Op Add> ::= <Op Mult> */
  Rule_OpAdd,

  /* 236. <Op Mult> ::= <Op Mult> '*' <Op Unary> */
  Rule_OpMult_Times,

  /* 237. <Op Mult> ::= <Op Mult> '/' <Op Unary> */
  Rule_OpMult_Div,

  /* 238. <Op Mult> ::= <Op Mult> '%' <Op Unary> */
  Rule_OpMult_Percent,

  /* 239. <Op Mult> ::= <Op Unary> */
  Rule_OpMult,

  /* 240. <Op Unary> ::= '!' <Op Unary> */
  Rule_OpUnary_Exclam,

  /* 241. <Op Unary> ::= '~' <Op Unary> */
  Rule_OpUnary_Tilde,

  /* 242. <Op Unary> ::= '-' <Op Unary> */
  Rule_OpUnary_Minus,

  /* 243. <Op Unary> ::= '*' <Op Unary> */
  Rule_OpUnary_Times,

  /* 244. <Op Unary> ::= '&' <Op Unary> */
  Rule_OpUnary_Amp,

  /* 245. <Op Unary> ::= '++' <Op Unary> */
  Rule_OpUnary_PlusPlus,

  /* 246. <Op Unary> ::= '--' <Op Unary> */
  Rule_OpUnary_MinusMinus,

  /* 247. <Op Unary> ::= <Op Pointer> '++' */
  Rule_OpUnary_PlusPlus2,

  /* 248. <Op Unary> ::= <Op Pointer> '--' */
  Rule_OpUnary_MinusMinus2,

  /* 249. <Op Unary> ::= <Op Unary> as <Type> */
  Rule_OpUnary_as,

  /* 250. <Op Unary> ::= <New Expr> */
  Rule_OpUnary,

  /* 251. <Op Unary> ::= delete <Op Pointer> */
  Rule_OpUnary_delete,

  /* 252. <Op Unary> ::= sizeof '(' <Type> ')' */
  Rule_OpUnary_sizeof_LParen_RParen,

  /* 253. <Op Unary> ::= <Op Pointer> */
  Rule_OpUnary2,

  /* 254. <Op Pointer> ::= <Op Pointer> '.' <Value> */
  Rule_OpPointer_Dot,

  /* 255. <Op Pointer> ::= <Op Pointer> '[' <Expr> ']' */
  Rule_OpPointer_LBracket_RBracket,

  /* 256. <Op Pointer> ::= <Op Pointer> '(' <Expr> ')' */
  Rule_OpPointer_LParen_RParen,

  /* 257. <Op Pointer> ::= <Op Pointer> '(' ')' */
  Rule_OpPointer_LParen_RParen2,

  /* 258. <Op Pointer> ::= <Value> */
  Rule_OpPointer,

  /* 259. <Value> ::= OctLiteral */
  Rule_Value_OctLiteral,

  /* 260. <Value> ::= HexLiteral */
  Rule_Value_HexLiteral,

  /* 261. <Value> ::= DecLiteral */
  Rule_Value_DecLiteral,

  /* 262. <Value> ::= BinLiteral */
  Rule_Value_BinLiteral,

  /* 263. <Value> ::= StringLiteral */
  Rule_Value_StringLiteral,

  /* 264. <Value> ::= CharLiteral */
  Rule_Value_CharLiteral,

  /* 265. <Value> ::= FloatLiteral */
  Rule_Value_FloatLiteral,

  /* 266. <Value> ::= null */
  Rule_Value_null,

  /* 267. <Value> ::= <Pkg> */
  Rule_Value,

  /* 268. <Value> ::= <Lambda Expr> */
  Rule_Value2,

  /* 269. <Value> ::= '(' <Expr> ')' */
  Rule_Value_LParen_RParen,

  /* 270. <Value> ::= '{' <Expr> '}' */
  Rule_Value_LBrace_RBrace,

  /* 271. <Lambda Expr> ::= lambda '(' <Params> ')' <Block> */
  Rule_LambdaExpr_lambda_LParen_RParen,

  /* 272. <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> */
  Rule_LambdaExpr_lambda_LParen_RParen_Eq,

  /* 273. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> */
  Rule_LambdaExpr_lambda_LParen_RParen_MinusGt,

  /* 274. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> */
  Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq,

  /* 275. <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> */
  Rule_CaseExprs_case_when_EqGt,

  /* 276. <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> */
  Rule_CaseExprs_case_EqGt,

  /* 277. <Case Exprs> ::= else '=>' <Expr> */
  Rule_CaseExprs_else_EqGt,

  /* 278. <New Expr> ::= new <Type> '(' ')' */
  Rule_NewExpr_new_LParen_RParen,

  /* 279. <New Expr> ::= new <Type> '(' <Expr> ')' */
  Rule_NewExpr_new_LParen_RParen2,

  /* 280. <New Expr> ::= new <Type> */
  Rule_NewExpr_new,

  /* 281. <New Expr> ::= new <Type> '(' ')' '{' <CDecl> '}' */
  Rule_NewExpr_new_LParen_RParen_LBrace_RBrace,

  /* 282. <New Expr> ::= new <Type> '(' <Expr> ')' '{' <CDecl> '}' */
  Rule_NewExpr_new_LParen_RParen_LBrace_RBrace2
  };



struct ContextStruct* parseAst(struct TokenStruct *Token, struct ContextStruct *parent)
{
    RuleJumpTable[Token->ReductionRule](Token, parent);
    size_t i = 0;
      /*
    for(; i < parent->imports->size; i++)
    {
        ImportExpr* ie = getElement(parent->imports, i);
        char* path = calloc(ie->filePathSize+1, sizeof(char));
        wcstombs(path, ie->filePath, ie->filePathSize+1);


        if(!fileExists(path))
        {
            char* path2 = calloc(strlen(path)+strlen(getLibDir())+1, sizeof(char));
            strcat(path2, getLibDir());
            strcat(path2, path);

            if(fileExists(path2))
            {
                 report_Print("compiling %s", path2);
                 //compile(path2);
            }

        }
        else{
            report_Print("compiling %s", path);
            //compile(path);
        }

    }
*/
/*
    for (i = 0; i < parent->funcs->size; i++)
    {
        addElement(parentExpr->funcs, getElement(parent->funcs, i));
    }
    for (i = 0; i < parent->classes->size; i++)
    {
        addElement(parentExpr->classes, getElement(parent->classes, i));
    }
    for (i = 0; i < parent->enums->size; i++)
    {
        addElement(parentExpr->enums, getElement(parent->enums, i));
    }
    for (i = 0; i < parent->ctypes->size; i++)
    {
        addElement(parentExpr->ctypes, getElement(parent->ctypes, i));
    }
    for (i = 0; i < parent->vars->size; i++)
    {
        addElement(parentExpr->vars, getElement(parent->vars, i));
    }
    for (i = 0; i < parent->modules->size; i++)
    {
        addElement(parentExpr->modules, getElement(parent->modules, i));
    }
    for (i = 0; i < parent->cdefs->size; i++)
    {
        addElement(parentExpr->cdefs, getElement(parent->cdefs, i));
    }
    */

    return NULL;
}

#define space ShowIndent(n)

void dumpAST(ContextStruct *e, int n)
{
    /*
    ShowIndent(n);
    switch(e->type)
    {
      case ET_arrayExpr:
        space;printf("const array\n");
        dumpAST(e->arrayExpr->elements, n+1);
        break;
      case ET_asExpr:
        space;printf("BOP as\n");
        space;printf("Expr:\n");
    }*/
}
