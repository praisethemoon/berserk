/*

     ***** **                                                              *
  ******  ***                                                            **
 **   *  * **                                                            **
*    *  *  **                                                            **
    *  *   *              ***  ****       ****              ***  ****    **
   ** **  *        ***     **** **** *   * **** *    ***     **** **** * **  ***
   ** ** *        * ***     **   ****   **  ****    * ***     **   ****  ** * ***
   ** ***        *   ***    **         ****        *   ***    **         ***   *
   ** ** ***    **    ***   **           ***      **    ***   **         **   *
   ** **   ***  ********    **             ***    ********    **         **  *
   *  **     ** *******     **               ***  *******     **         ** **
      *      ** **          **          ****  **  **          **         ******
  ****     ***  ****    *   ***        * **** *   ****    *   ***        **  ***
 *  ********     *******     ***          ****     *******     ***       **   *** *
*     ****        *****                             *****                 **   ***
*
 **

Written by Soulaymen Chouri
Contact me @ akaisora@tuta.io

Copyright (c) 2016,Soulaymen Chouri (akaisora@tuta.io). All rights reserved.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the author nor the names of other contributors may be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>                  /* wchar_t */
#include <sys/stat.h>
#include <assert.h>
#include <string.h>

#include "Engine.h"                 /* The Kessels engine. */
#include "Grammar.h"                /* Generated by GOLD. */
#include "Parser.h"
#include "Defines.h"

#define TRIMREDUCTIONS 0            /* 0=off, 1=on */
#define DEBUG          1            /* 0=off, 1=on */


#define parseExpr(i, p) RuleJumpTable[Token->Tokens[i]->ReductionRule](Token->Tokens[i], p)
#define switchCaseExpr(i) case ET_##i: e->i = calloc(1, sizeof(e->i)); break
#define getToken(i) Token->Tokens[i]
#define match(t) assert(parent->type == t);


/***** Helper subroutines ***************************************************/


/* Make a readable copy of a string. All characters outside 32...127 are
displayed as a HEX number in square brackets, for example "[0A]". */
void ReadableString(wchar_t *Input, wchar_t *Output, long Width) {
    char s1[BUFSIZ];
    long i1;
    long i2;

    /* Sanity check. */
    if ((Output == NULL) || (Width < 1)) return;
    Output[0] = 0;
    if (Input == NULL) return;

    i1 = 0;
    i2 = 0;
    while ((i2 < Width - 1) && (Input[i1] != 0)) {
        if ((Input[i1] >= 32) && (Input[i1] <= 127)) {
            Output[i2++] = Input[i1];
        }
        else {
            if (Width - i2 > 4) {
                sprintf(s1, "%02X", Input[i1]);
                Output[i2++] = '[';
                Output[i2++] = s1[0];
                Output[i2++] = s1[1];
                Output[i2++] = ']';
            }
        }
        i1++;
    }
    Output[i2] = 0;
}


void ShowIndent(int Indent) {
    /*int i;
    for (i = 0; i < Indent; i++)
        report_Print("  ");*/
}


extern void (*RuleJumpTable[])(struct TokenStruct *Token, ContextStruct *Context);

/***** Rule subroutine template *********************************************/

/* This subroutine is a template of things that can happen in the
subroutine of a rule. It shows how to access the value of symbols
and how to call rules, and how to transport results and stuff via
the parent.

For example the rule:

<Increment> ::= <Expression> '+' Number

Has 3 sub-tokens:

Token->Tokens[0] = token for <Expression>, a rule
Token->Tokens[1] = token for '+', a symbol
Token->Tokens[2] = token for Number, a symbol

We know Token->Tokens[0] is a rule, because that's what the grammar
says. We may assume that the engine has fully populated the sub-tokens
and don't have to perform any checks. We can immediately call the
subroutine of the rule, like this:

RuleJumpTable[Token->Tokens[0]->ReductionRule](Token->Tokens[0],parent);

The subroutine should hand back it's results via the parent. Here
is an example of how to store a result in the parent:

parent->ReturnValue = (wchar_t *)wcsdup(....);

Symbols are literal strings from the input (that was parsed by the
engine), stored in the sub-token. We can get the value of the "Number"
symbol like this:

Value = (wchar_t *)wcsdup(Token->Tokens[2]->Data);

Further reading:
- See "engine.h" for the definition of the TokenStruct.
- See "readme.txt" for a short discussion on how to use the content
of a Token.
- See "example4.c" for a working template example.
*/

void RuleTemplate(struct TokenStruct *Token, ContextStruct *parent) {
    int i;

    /* Debugging: show the description of the rule. */
    if (parent->Debug > 0) {
        ShowIndent(parent->Indent);
        printf("Executing rule: %ls\n", Grammar.RuleArray[Token->ReductionRule].Description);
    }

    /* For all the sub-Tokens. */
    for (i = 0; i < Grammar.RuleArray[Token->ReductionRule].SymbolsCount; i++) {
        /* See if the Token is a Symbol or a Rule. */
        if (Token->Tokens[i]->ReductionRule < 0) {
            /* It's a Symbol. Make a copy of the Data. Most symbols are grammar,
            for example '+', 'function', 'while', and such, and you won't
            need to look at the Data. Other symbols are literals from the input
            script, for example numbers, strings, variable names, and such. */
            if (parent->ReturnValue != NULL) free(parent->ReturnValue);
            parent->ReturnValue = (wchar_t *)wcsdup(Token->Tokens[i]->Data);

            /* Debugging: show a description of the Symbol, and it's value. */
            if (parent->Debug > 0) {
                ShowIndent(parent->Indent + 1);
                printf("Token[%u] = Symbol('%ls') = '%ls'\n", i,
                    Grammar.SymbolArray[Token->Tokens[i]->Symbol].Name,
                    parent->ReturnValue);
            }

        }
        else {
            /* It's a rule. */

            /* Debugging: show a description of the rule. */
            if (parent->Debug > 0) {
                ShowIndent(parent->Indent + 1);
                printf("Token[%u] = Rule = %ls\n", i,
                    Grammar.RuleArray[Token->Tokens[i]->ReductionRule].Description);
            }

            /* Call the rule's subroutine via the RuleJumpTable. */
            parent->Indent = parent->Indent + 1;
            RuleJumpTable[Token->Tokens[i]->ReductionRule](Token->Tokens[i], parent);
            parent->Indent = parent->Indent - 1;

            /* At this point you will probably want to save the parent->ReturnValue
            somewhere. */

            /* Debugging: show the value that was returned by the rule's subroutine. */
            if (parent->Debug > 0) {
                ShowIndent(parent->Indent + 2);
                printf("Result value = %ls\n", parent->ReturnValue);
            }
        }
    }

    /* Do whatever processing is needed by the rule. Remember to free() the
    Values you have saved. */
}


/***** Rule subroutines *****************************************************/





/* <Decls> ::= <Using Stms> <Decl List> */
void Rule_Decls(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decls> ::=  */
void Rule_Decls2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl List> ::= <Decl> <Decl List> */
void Rule_DeclList(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl List> ::= <Decl> */
void Rule_DeclList2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Func Decl> */
void Rule_Decl(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Class Decl> */
void Rule_Decl2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Enum Decl> */
void Rule_Decl3(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= extern type Id */
void Rule_Decl_extern_type_Id(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= local extern type Id */
void Rule_Decl_local_extern_type_Id(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= extern local type Id */
void Rule_Decl_extern_local_type_Id(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Var Decl> */
void Rule_Decl4(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Import> */
void Rule_Decl5(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <CDefFunc Decl> */
void Rule_Decl6(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= import <File Path All> */
void Rule_Import_import(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= import <File Path> as Id */
void Rule_Import_import_as_Id(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= from <File Path> import <File Path List> */
void Rule_Import_from_import(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path> ::= Id '.' <File Path> */
void Rule_FilePath_Id_Dot(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path> ::= Id */
void Rule_FilePath_Id(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path All> ::= Id '.' <File Path All> */
void Rule_FilePathAll_Id_Dot(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path All> ::= Id '.*' */
void Rule_FilePathAll_Id_DotTimes(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path All> ::= Id */
void Rule_FilePathAll_Id(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path List> ::= <File Path> ',' <File Path List> */
void Rule_FilePathList_Comma(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path List> ::= <File Path> */
void Rule_FilePathList(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Params> ')' */
void Rule_FnHeaderProto_Id_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Params> ')' '->' <Type> */
void Rule_FnHeaderProto_Id_LParen_RParen_MinusGt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Types> ')' */
void Rule_FnHeaderProto_Id_LParen_RParen2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Types> ')' '->' <Type> */
void Rule_FnHeaderProto_Id_LParen_RParen_MinusGt2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' ')' */
void Rule_FnHeaderProto_Id_LParen_RParen3(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' ')' '->' <Type> */
void Rule_FnHeaderProto_Id_LParen_RParen_MinusGt3(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' <Params> ')' */
void Rule_FnHeaderImpl_Id_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' <Params> ')' '->' <Type> */
void Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' ')' */
void Rule_FnHeaderImpl_Id_LParen_RParen2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' ')' '->' <Type> */
void Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= function <Fn Header Impl> <Block> */
void Rule_FuncDecl_function(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= function <Fn Header Impl> '=' <Expr> */
void Rule_FuncDecl_function_Eq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= local function <Fn Header Impl> <Block> */
void Rule_FuncDecl_local_function(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= local function <Fn Header Impl> '=' <Expr> */
void Rule_FuncDecl_local_function_Eq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <private final static inherited> function <Fn Header Proto> */
void Rule_CFuncProto_function(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Decl> ::= <private final static inherited> function <Fn Header Impl> <Block> */
void Rule_CFuncDecl_function(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Decl> ::= <private final static inherited> function <Fn Header Impl> '=' <Expr> */
void Rule_CFuncDecl_function_Eq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private */
void Rule_privatefinalstaticinherited_private(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= static */
void Rule_privatefinalstaticinherited_static(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= final */
void Rule_privatefinalstaticinherited_final(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= inherited */
void Rule_privatefinalstaticinherited_inherited(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private static */
void Rule_privatefinalstaticinherited_private_static(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= static private */
void Rule_privatefinalstaticinherited_static_private(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private inherited */
void Rule_privatefinalstaticinherited_private_inherited(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= inherited private */
void Rule_privatefinalstaticinherited_inherited_private(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= static final */
void Rule_privatefinalstaticinherited_static_final(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= final static */
void Rule_privatefinalstaticinherited_final_static(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private final */
void Rule_privatefinalstaticinherited_private_final(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= final static private */
void Rule_privatefinalstaticinherited_final_static_private(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= final private static */
void Rule_privatefinalstaticinherited_final_private_static(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= static final private */
void Rule_privatefinalstaticinherited_static_final_private(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= static private final */
void Rule_privatefinalstaticinherited_static_private_final(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private final static */
void Rule_privatefinalstaticinherited_private_final_static(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::= private static final */
void Rule_privatefinalstaticinherited_private_static_final(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <private final static inherited> ::=  */
void Rule_privatefinalstaticinherited(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_extern_function(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= local extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_local_extern_function(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= extern local function <Fn Header Proto> */
void Rule_CDefFuncDecl_extern_local_function(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Params> ::= <Param> ',' <Params> */
void Rule_Params_Comma(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Params> ::= <Param> */
void Rule_Params(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Param> ::= final Id ':' <Type> */
void Rule_Param_final_Id_Colon(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Param> ::= Id ':' <Type> */
void Rule_Param_Id_Colon(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Types> ::= <Type> ',' <Types> */
void Rule_Types_Comma(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Types> ::= <Type> */
void Rule_Types(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Id List> ::= Id ',' <Id List> */
void Rule_IdList_Id_Comma(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Id List> ::= Id */
void Rule_IdList_Id(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= <Normal Class> */
void Rule_ClassDecl(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= <Abstract Class> */
void Rule_ClassDecl2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= local <Normal Class> */
void Rule_ClassDecl_local(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= local <Abstract Class> */
void Rule_ClassDecl_local2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Class> ::= class <Class Name> '{' <CDecls> '}' */
void Rule_NormalClass_class_LBrace_RBrace(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Class> ::= class <Class Name> extends <Extend Class Name List> '{' <CDecls> '}' */
void Rule_NormalClass_class_extends_LBrace_RBrace(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Abstract Class> ::= abstract class <Class Name> '{' <ACDecls> '}' */
void Rule_AbstractClass_abstract_class_LBrace_RBrace(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Abstract Class> ::= abstract class <Class Name> extends <Extend Class Name List> '{' <ACDecls> '}' */
void Rule_AbstractClass_abstract_class_extends_LBrace_RBrace(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Name> ::= Id */
void Rule_ClassName_Id(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Name> ::= Id '<' <Id List> '>' */
void Rule_ClassName_Id_Lt_Gt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name> ::= <Pkg> */
void Rule_ExtendClassName(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name> ::= <Pkg> '<' <Extend Class Name List> '>' */
void Rule_ExtendClassName_Lt_Gt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name List> ::= <Extend Class Name> ',' <Extend Class Name List> */
void Rule_ExtendClassNameList_Comma(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name List> ::= <Extend Class Name> */
void Rule_ExtendClassNameList(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecls> ::= <CDecl> <CDecls> */
void Rule_CDecls(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecls> ::=  */
void Rule_CDecls2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecls> ::= <ACDecl> <ACDecls> */
void Rule_ACDecls(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecls> ::=  */
void Rule_ACDecls2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <CFunc Decl> */
void Rule_CDecl(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <CVar Decl> */
void Rule_CDecl2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <Operator Impl> */
void Rule_CDecl3(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CFunc Decl> */
void Rule_ACDecl(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CFunc Proto> */
void Rule_ACDecl2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CVar Decl> */
void Rule_ACDecl3(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <Operator Impl> */
void Rule_ACDecl4(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <Operator Proto> */
void Rule_ACDecl5(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator Impl> ::= operator <Operator> <Op Header Impl> '=' <Expr> */
void Rule_OperatorImpl_operator_Eq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator Impl> ::= operator <Operator> <Op Header Impl> <Block> */
void Rule_OperatorImpl_operator(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator Proto> ::= operator <Operator> <Op Header Proto> */
void Rule_OperatorProto_operator(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefStruct> ::= extern struct Id '{' <Params> '}' */
void Rule_CDefStruct_extern_struct_Id_LBrace_RBrace(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '+' */
void Rule_Operator_Plus(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '-' */
void Rule_Operator_Minus(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '*' */
void Rule_Operator_Times(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '/' */
void Rule_Operator_Div(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '%' */
void Rule_Operator_Percent(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '^' */
void Rule_Operator_Caret(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&' */
void Rule_Operator_Amp(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '|' */
void Rule_Operator_Pipe(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '~' */
void Rule_Operator_Tilde(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '!' */
void Rule_Operator_Exclam(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '=' */
void Rule_Operator_Eq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<' */
void Rule_Operator_Lt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>' */
void Rule_Operator_Gt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '+=' */
void Rule_Operator_PlusEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '-=' */
void Rule_Operator_MinusEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '*=' */
void Rule_Operator_TimesEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '/=' */
void Rule_Operator_DivEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '%=' */
void Rule_Operator_PercentEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '^=' */
void Rule_Operator_CaretEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&=' */
void Rule_Operator_AmpEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '|=' */
void Rule_Operator_PipeEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<<' */
void Rule_Operator_LtLt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>>' */
void Rule_Operator_GtGt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>>=' */
void Rule_Operator_GtGtEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<<=' */
void Rule_Operator_LtLtEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '==' */
void Rule_Operator_EqEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '!=' */
void Rule_Operator_ExclamEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<=' */
void Rule_Operator_LtEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>=' */
void Rule_Operator_GtEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&&' */
void Rule_Operator_AmpAmp(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '||' */
void Rule_Operator_PipePipe(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '++' */
void Rule_Operator_PlusPlus(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '--' */
void Rule_Operator_MinusMinus(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= ',' */
void Rule_Operator_Comma(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '(' ')' */
void Rule_Operator_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '[' ']' */
void Rule_Operator_LBracket_RBracket(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Params> ')' */
void Rule_OpHeaderProto_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Params> ')' '->' <Type> */
void Rule_OpHeaderProto_LParen_RParen_MinusGt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Types> ')' */
void Rule_OpHeaderProto_LParen_RParen2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Types> ')' '->' <Type> */
void Rule_OpHeaderProto_LParen_RParen_MinusGt2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' ')' */
void Rule_OpHeaderProto_LParen_RParen3(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' ')' '->' <Type> */
void Rule_OpHeaderProto_LParen_RParen_MinusGt3(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' <Params> ')' */
void Rule_OpHeaderImpl_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' <Params> ')' '->' <Type> */
void Rule_OpHeaderImpl_LParen_RParen_MinusGt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' ')' */
void Rule_OpHeaderImpl_LParen_RParen2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' ')' '->' <Type> */
void Rule_OpHeaderImpl_LParen_RParen_MinusGt2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let final <Var Header> */
void Rule_VarDecl_let_final(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let <Var Header> */
void Rule_VarDecl_let(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let local <Var Header> */
void Rule_VarDecl_let_local(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let local final <Var Header> */
void Rule_VarDecl_let_local_final(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let final local <Var Header> */
void Rule_VarDecl_let_final_local(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <private final static inherited> <Var Header> */
void Rule_CVarDecl_let(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> ':' <Type> '=' <Expr> */
void Rule_VarHeader_Colon_Eq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> ':' <Type> */
void Rule_VarHeader_Colon(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> '=' <Expr> */
void Rule_VarHeader_Eq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Decl> ::= enum Id '{' <Enum Def> '}' */
void Rule_EnumDecl_enum_Id_LBrace_RBrace(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Decl> ::= local enum Id '{' <Enum Def> '}' */
void Rule_EnumDecl_local_enum_Id_LBrace_RBrace(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Def> ::= Id ',' <Enum Def> */
void Rule_EnumDef_Id_Comma(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Def> ::= Id */
void Rule_EnumDef_Id(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Base> */
void Rule_Type(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Fn Type> */
void Rule_Type2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Pkg> */
void Rule_Type3(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Pkg> '<' <Types> '>' */
void Rule_Type_Lt_Gt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Type> '[' ']' */
void Rule_Type_LBracket_RBracket(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= '(' <Types> ')' */
void Rule_Type_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' ')' */
void Rule_FnType_fn_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' ')' '->' <Type> */
void Rule_FnType_fn_LParen_RParen_MinusGt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' <Types> ')' */
void Rule_FnType_fn_LParen_RParen2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' <Types> ')' '->' <Type> */
void Rule_FnType_fn_LParen_RParen_MinusGt2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= <Sign> <Scalar> */
void Rule_Base(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'size_t' */
void Rule_Base_size_t(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::= signed */
void Rule_Sign_signed(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::= unsigned */
void Rule_Sign_unsigned(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::=  */
void Rule_Sign(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= char */
void Rule_Scalar_char(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= int */
void Rule_Scalar_int(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= short */
void Rule_Scalar_short(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= long */
void Rule_Scalar_long(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= short int */
void Rule_Scalar_short_int(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= long int */
void Rule_Scalar_long_int(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= float */
void Rule_Scalar_float(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= double */
void Rule_Scalar_double(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= byte */
void Rule_Scalar_byte(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <Var Decl> */
void Rule_Stm(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <If Stm> */
void Rule_Stm2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= while <Expr> <Block> */
void Rule_Stm_while(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= for <Arg> ';' <Arg> ';' <Arg> <Block> */
void Rule_Stm_for_Semi_Semi(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= foreach Id in <Expr> <Block> */
void Rule_Stm_foreach_Id_in(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <Normal Stm> */
void Rule_Stm3(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Using Stm> ::= using <Pkg> */
void Rule_UsingStm_using(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Using Stms> ::= <Using Stm> <Using Stms> */
void Rule_UsingStms(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Using Stms> ::=  */
void Rule_UsingStms2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg> ::= Id '.' <Pkg> */
void Rule_Pkg_Id_Dot(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg> ::= Id */
void Rule_Pkg_Id(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <If Stm> ::= if <Expr> <Block> <else-if> */
void Rule_IfStm_if(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::= else if <Expr> <Block> <else-if> */
void Rule_elseif_else_if(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::= else <Block> */
void Rule_elseif_else(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::=  */
void Rule_elseif(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= do <Block> while <Expr> */
void Rule_NormalStm_do_while(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= match <Expr> '{' <Case Stms> '}' */
void Rule_NormalStm_match_LBrace_RBrace(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= <Block> */
void Rule_NormalStm(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= <Expr> */
void Rule_NormalStm2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= break */
void Rule_NormalStm_break(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= continue */
void Rule_NormalStm_continue(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= return <Expr> */
void Rule_NormalStm_return(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= return */
void Rule_NormalStm_return2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= ';' */
void Rule_NormalStm_Semi(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Arg> ::= <Expr> */
void Rule_Arg(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Arg> ::=  */
void Rule_Arg2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= case <Expr> when <Expr> <Block> <Case Stms> */
void Rule_CaseStms_case_when(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= case <Expr> <Block> <Case Stms> */
void Rule_CaseStms_case(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= else <Block> */
void Rule_CaseStms_else(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Block> ::= '{' <Using Stms> <Stm List> '}' */
void Rule_Block_LBrace_RBrace(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm List> ::= <Stm> <Stm List> */
void Rule_StmList(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm List> ::=  */
void Rule_StmList2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CSE> ::= <Expr> */
void Rule_CSE(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CSE> ::= <CSE> ',' <Expr> */
void Rule_CSE_Comma(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Var Decl> in <Expr> */
void Rule_Expr_in(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= match <Expr> '{' <Case Exprs> '}' */
void Rule_Expr_match_LBrace_RBrace(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Op Assign> */
void Rule_Expr(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '=' <Op Assign> */
void Rule_OpAssign_Eq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '+=' <Op Assign> */
void Rule_OpAssign_PlusEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '-=' <Op Assign> */
void Rule_OpAssign_MinusEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '*=' <Op Assign> */
void Rule_OpAssign_TimesEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '/=' <Op Assign> */
void Rule_OpAssign_DivEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '%=' <Op Assign> */
void Rule_OpAssign_PercentEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '^=' <Op Assign> */
void Rule_OpAssign_CaretEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '&=' <Op Assign> */
void Rule_OpAssign_AmpEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '|=' <Op Assign> */
void Rule_OpAssign_PipeEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '>>=' <Op Assign> */
void Rule_OpAssign_GtGtEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '<<=' <Op Assign> */
void Rule_OpAssign_LtLtEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> */
void Rule_OpAssign(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Or> ::= <Op Or> '||' <Op And> */
void Rule_OpOr_PipePipe(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Or> ::= <Op And> */
void Rule_OpOr(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op And> ::= <Op And> '&&' <Op BinOR> */
void Rule_OpAnd_AmpAmp(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op And> ::= <Op BinOR> */
void Rule_OpAnd(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> */
void Rule_OpBinOR_Pipe(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinOR> ::= <Op BinXOR> */
void Rule_OpBinOR(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> */
void Rule_OpBinXOR_Caret(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinXOR> ::= <Op BinAND> */
void Rule_OpBinXOR(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinAND> ::= <Op BinAND> '&' <Op Equate> */
void Rule_OpBinAND_Amp(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinAND> ::= <Op Equate> */
void Rule_OpBinAND(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Equate> '==' <Op Compare> */
void Rule_OpEquate_EqEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Equate> '!=' <Op Compare> */
void Rule_OpEquate_ExclamEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Compare> */
void Rule_OpEquate(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '<' <Op Shift> */
void Rule_OpCompare_Lt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '>' <Op Shift> */
void Rule_OpCompare_Gt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '<=' <Op Shift> */
void Rule_OpCompare_LtEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '>=' <Op Shift> */
void Rule_OpCompare_GtEq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> is <Type> */
void Rule_OpCompare_is(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Shift> */
void Rule_OpCompare(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Shift> '<<' <Op Add> */
void Rule_OpShift_LtLt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Shift> '>>' <Op Add> */
void Rule_OpShift_GtGt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Add> */
void Rule_OpShift(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Add> '+' <Op Mult> */
void Rule_OpAdd_Plus(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Add> '-' <Op Mult> */
void Rule_OpAdd_Minus(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Mult> */
void Rule_OpAdd(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '*' <Op Unary> */
void Rule_OpMult_Times(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '/' <Op Unary> */
void Rule_OpMult_Div(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '%' <Op Unary> */
void Rule_OpMult_Percent(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Unary> */
void Rule_OpMult(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '!' <Op Unary> */
void Rule_OpUnary_Exclam(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '~' <Op Unary> */
void Rule_OpUnary_Tilde(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '-' <Op Unary> */
void Rule_OpUnary_Minus(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '++' <Op Unary> */
void Rule_OpUnary_PlusPlus(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '--' <Op Unary> */
void Rule_OpUnary_MinusMinus(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> '++' */
void Rule_OpUnary_PlusPlus2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> '--' */
void Rule_OpUnary_MinusMinus2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Unary> as <Type> */
void Rule_OpUnary_as(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <New Expr> */
void Rule_OpUnary(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= delete <Op Pointer> */
void Rule_OpUnary_delete(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= sizeof '(' <Type> ')' */
void Rule_OpUnary_sizeof_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> */
void Rule_OpUnary2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '.' <Value> */
void Rule_OpPointer_Dot(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '[' <CSE> ']' */
void Rule_OpPointer_LBracket_RBracket(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '(' <CSE> ')' */
void Rule_OpPointer_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '(' ')' */
void Rule_OpPointer_LParen_RParen2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Value> */
void Rule_OpPointer(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= OctLiteral */
void Rule_Value_OctLiteral(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= HexLiteral */
void Rule_Value_HexLiteral(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= DecLiteral */
void Rule_Value_DecLiteral(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= BinLiteral */
void Rule_Value_BinLiteral(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= StringLiteral */
void Rule_Value_StringLiteral(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= CharLiteral */
void Rule_Value_CharLiteral(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= FloatLiteral */
void Rule_Value_FloatLiteral(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= null */
void Rule_Value_null(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '_' */
void Rule_Value__(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= <Pkg> */
void Rule_Value(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= <Lambda Expr> */
void Rule_Value2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '(' <CSE> ')' */
void Rule_Value_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Id ':' <Type> in <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Id_Colon_in_EqGt_RBracket(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Id in <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Id_in_EqGt_RBracket(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' <CSE> ']' */
void Rule_Value_LBracket_RBracket(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' <Block> */
void Rule_LambdaExpr_lambda_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> */
void Rule_LambdaExpr_lambda_LParen_RParen_Eq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> */
void Rule_LambdaExpr_lambda_LParen_RParen_MinusGt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> */
void Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> */
void Rule_CaseExprs_case_when_EqGt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> */
void Rule_CaseExprs_case_EqGt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= else '=>' <Expr> */
void Rule_CaseExprs_else_EqGt(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> '(' ')' */
void Rule_NewExpr_new_LParen_RParen(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> '(' <Expr> ')' */
void Rule_NewExpr_new_LParen_RParen2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> */
void Rule_NewExpr_new(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> '(' ')' '{' <CDecl> '}' */
void Rule_NewExpr_new_LParen_RParen_LBrace_RBrace(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> '(' <Expr> ')' '{' <CDecl> '}' */
void Rule_NewExpr_new_LParen_RParen_LBrace_RBrace2(struct TokenStruct *Token, ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/***** Rule jumptable *******************************************************/




void (*RuleJumpTable[])(struct TokenStruct *Token, ContextStruct *Context) = {

  /* 0. <Decls> ::= <Using Stms> <Decl List> */
  Rule_Decls,

  /* 1. <Decls> ::=  */
  Rule_Decls2,

  /* 2. <Decl List> ::= <Decl> <Decl List> */
  Rule_DeclList,

  /* 3. <Decl List> ::= <Decl> */
  Rule_DeclList2,

  /* 4. <Decl> ::= <Func Decl> */
  Rule_Decl,

  /* 5. <Decl> ::= <Class Decl> */
  Rule_Decl2,

  /* 6. <Decl> ::= <Enum Decl> */
  Rule_Decl3,

  /* 7. <Decl> ::= extern type Id */
  Rule_Decl_extern_type_Id,

  /* 8. <Decl> ::= local extern type Id */
  Rule_Decl_local_extern_type_Id,

  /* 9. <Decl> ::= extern local type Id */
  Rule_Decl_extern_local_type_Id,

  /* 10. <Decl> ::= <Var Decl> */
  Rule_Decl4,

  /* 11. <Decl> ::= <Import> */
  Rule_Decl5,

  /* 12. <Decl> ::= <CDefFunc Decl> */
  Rule_Decl6,

  /* 13. <Import> ::= import <File Path All> */
  Rule_Import_import,

  /* 14. <Import> ::= import <File Path> as Id */
  Rule_Import_import_as_Id,

  /* 15. <Import> ::= from <File Path> import <File Path List> */
  Rule_Import_from_import,

  /* 16. <File Path> ::= Id '.' <File Path> */
  Rule_FilePath_Id_Dot,

  /* 17. <File Path> ::= Id */
  Rule_FilePath_Id,

  /* 18. <File Path All> ::= Id '.' <File Path All> */
  Rule_FilePathAll_Id_Dot,

  /* 19. <File Path All> ::= Id '.*' */
  Rule_FilePathAll_Id_DotTimes,

  /* 20. <File Path All> ::= Id */
  Rule_FilePathAll_Id,

  /* 21. <File Path List> ::= <File Path> ',' <File Path List> */
  Rule_FilePathList_Comma,

  /* 22. <File Path List> ::= <File Path> */
  Rule_FilePathList,

  /* 23. <Fn Header Proto> ::= Id '(' <Params> ')' */
  Rule_FnHeaderProto_Id_LParen_RParen,

  /* 24. <Fn Header Proto> ::= Id '(' <Params> ')' '->' <Type> */
  Rule_FnHeaderProto_Id_LParen_RParen_MinusGt,

  /* 25. <Fn Header Proto> ::= Id '(' <Types> ')' */
  Rule_FnHeaderProto_Id_LParen_RParen2,

  /* 26. <Fn Header Proto> ::= Id '(' <Types> ')' '->' <Type> */
  Rule_FnHeaderProto_Id_LParen_RParen_MinusGt2,

  /* 27. <Fn Header Proto> ::= Id '(' ')' */
  Rule_FnHeaderProto_Id_LParen_RParen3,

  /* 28. <Fn Header Proto> ::= Id '(' ')' '->' <Type> */
  Rule_FnHeaderProto_Id_LParen_RParen_MinusGt3,

  /* 29. <Fn Header Impl> ::= Id '(' <Params> ')' */
  Rule_FnHeaderImpl_Id_LParen_RParen,

  /* 30. <Fn Header Impl> ::= Id '(' <Params> ')' '->' <Type> */
  Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt,

  /* 31. <Fn Header Impl> ::= Id '(' ')' */
  Rule_FnHeaderImpl_Id_LParen_RParen2,

  /* 32. <Fn Header Impl> ::= Id '(' ')' '->' <Type> */
  Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt2,

  /* 33. <Func Decl> ::= function <Fn Header Impl> <Block> */
  Rule_FuncDecl_function,

  /* 34. <Func Decl> ::= function <Fn Header Impl> '=' <Expr> */
  Rule_FuncDecl_function_Eq,

  /* 35. <Func Decl> ::= local function <Fn Header Impl> <Block> */
  Rule_FuncDecl_local_function,

  /* 36. <Func Decl> ::= local function <Fn Header Impl> '=' <Expr> */
  Rule_FuncDecl_local_function_Eq,

  /* 37. <CFunc Proto> ::= <private final static inherited> function <Fn Header Proto> */
  Rule_CFuncProto_function,

  /* 38. <CFunc Decl> ::= <private final static inherited> function <Fn Header Impl> <Block> */
  Rule_CFuncDecl_function,

  /* 39. <CFunc Decl> ::= <private final static inherited> function <Fn Header Impl> '=' <Expr> */
  Rule_CFuncDecl_function_Eq,

  /* 40. <private final static inherited> ::= private */
  Rule_privatefinalstaticinherited_private,

  /* 41. <private final static inherited> ::= static */
  Rule_privatefinalstaticinherited_static,

  /* 42. <private final static inherited> ::= final */
  Rule_privatefinalstaticinherited_final,

  /* 43. <private final static inherited> ::= inherited */
  Rule_privatefinalstaticinherited_inherited,

  /* 44. <private final static inherited> ::= private static */
  Rule_privatefinalstaticinherited_private_static,

  /* 45. <private final static inherited> ::= static private */
  Rule_privatefinalstaticinherited_static_private,

  /* 46. <private final static inherited> ::= private inherited */
  Rule_privatefinalstaticinherited_private_inherited,

  /* 47. <private final static inherited> ::= inherited private */
  Rule_privatefinalstaticinherited_inherited_private,

  /* 48. <private final static inherited> ::= static final */
  Rule_privatefinalstaticinherited_static_final,

  /* 49. <private final static inherited> ::= final static */
  Rule_privatefinalstaticinherited_final_static,

  /* 50. <private final static inherited> ::= private final */
  Rule_privatefinalstaticinherited_private_final,

  /* 51. <private final static inherited> ::= final static private */
  Rule_privatefinalstaticinherited_final_static_private,

  /* 52. <private final static inherited> ::= final private static */
  Rule_privatefinalstaticinherited_final_private_static,

  /* 53. <private final static inherited> ::= static final private */
  Rule_privatefinalstaticinherited_static_final_private,

  /* 54. <private final static inherited> ::= static private final */
  Rule_privatefinalstaticinherited_static_private_final,

  /* 55. <private final static inherited> ::= private final static */
  Rule_privatefinalstaticinherited_private_final_static,

  /* 56. <private final static inherited> ::= private static final */
  Rule_privatefinalstaticinherited_private_static_final,

  /* 57. <private final static inherited> ::=  */
  Rule_privatefinalstaticinherited,

  /* 58. <CDefFunc Decl> ::= extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_extern_function,

  /* 59. <CDefFunc Decl> ::= local extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_local_extern_function,

  /* 60. <CDefFunc Decl> ::= extern local function <Fn Header Proto> */
  Rule_CDefFuncDecl_extern_local_function,

  /* 61. <Params> ::= <Param> ',' <Params> */
  Rule_Params_Comma,

  /* 62. <Params> ::= <Param> */
  Rule_Params,

  /* 63. <Param> ::= final Id ':' <Type> */
  Rule_Param_final_Id_Colon,

  /* 64. <Param> ::= Id ':' <Type> */
  Rule_Param_Id_Colon,

  /* 65. <Types> ::= <Type> ',' <Types> */
  Rule_Types_Comma,

  /* 66. <Types> ::= <Type> */
  Rule_Types,

  /* 67. <Id List> ::= Id ',' <Id List> */
  Rule_IdList_Id_Comma,

  /* 68. <Id List> ::= Id */
  Rule_IdList_Id,

  /* 69. <Class Decl> ::= <Normal Class> */
  Rule_ClassDecl,

  /* 70. <Class Decl> ::= <Abstract Class> */
  Rule_ClassDecl2,

  /* 71. <Class Decl> ::= local <Normal Class> */
  Rule_ClassDecl_local,

  /* 72. <Class Decl> ::= local <Abstract Class> */
  Rule_ClassDecl_local2,

  /* 73. <Normal Class> ::= class <Class Name> '{' <CDecls> '}' */
  Rule_NormalClass_class_LBrace_RBrace,

  /* 74. <Normal Class> ::= class <Class Name> extends <Extend Class Name List> '{' <CDecls> '}' */
  Rule_NormalClass_class_extends_LBrace_RBrace,

  /* 75. <Abstract Class> ::= abstract class <Class Name> '{' <ACDecls> '}' */
  Rule_AbstractClass_abstract_class_LBrace_RBrace,

  /* 76. <Abstract Class> ::= abstract class <Class Name> extends <Extend Class Name List> '{' <ACDecls> '}' */
  Rule_AbstractClass_abstract_class_extends_LBrace_RBrace,

  /* 77. <Class Name> ::= Id */
  Rule_ClassName_Id,

  /* 78. <Class Name> ::= Id '<' <Id List> '>' */
  Rule_ClassName_Id_Lt_Gt,

  /* 79. <Extend Class Name> ::= <Pkg> */
  Rule_ExtendClassName,

  /* 80. <Extend Class Name> ::= <Pkg> '<' <Extend Class Name List> '>' */
  Rule_ExtendClassName_Lt_Gt,

  /* 81. <Extend Class Name List> ::= <Extend Class Name> ',' <Extend Class Name List> */
  Rule_ExtendClassNameList_Comma,

  /* 82. <Extend Class Name List> ::= <Extend Class Name> */
  Rule_ExtendClassNameList,

  /* 83. <CDecls> ::= <CDecl> <CDecls> */
  Rule_CDecls,

  /* 84. <CDecls> ::=  */
  Rule_CDecls2,

  /* 85. <ACDecls> ::= <ACDecl> <ACDecls> */
  Rule_ACDecls,

  /* 86. <ACDecls> ::=  */
  Rule_ACDecls2,

  /* 87. <CDecl> ::= <CFunc Decl> */
  Rule_CDecl,

  /* 88. <CDecl> ::= <CVar Decl> */
  Rule_CDecl2,

  /* 89. <CDecl> ::= <Operator Impl> */
  Rule_CDecl3,

  /* 90. <ACDecl> ::= <CFunc Decl> */
  Rule_ACDecl,

  /* 91. <ACDecl> ::= <CFunc Proto> */
  Rule_ACDecl2,

  /* 92. <ACDecl> ::= <CVar Decl> */
  Rule_ACDecl3,

  /* 93. <ACDecl> ::= <Operator Impl> */
  Rule_ACDecl4,

  /* 94. <ACDecl> ::= <Operator Proto> */
  Rule_ACDecl5,

  /* 95. <Operator Impl> ::= operator <Operator> <Op Header Impl> '=' <Expr> */
  Rule_OperatorImpl_operator_Eq,

  /* 96. <Operator Impl> ::= operator <Operator> <Op Header Impl> <Block> */
  Rule_OperatorImpl_operator,

  /* 97. <Operator Proto> ::= operator <Operator> <Op Header Proto> */
  Rule_OperatorProto_operator,

  /* 98. <CDefStruct> ::= extern struct Id '{' <Params> '}' */
  Rule_CDefStruct_extern_struct_Id_LBrace_RBrace,

  /* 99. <Operator> ::= '+' */
  Rule_Operator_Plus,

  /* 100. <Operator> ::= '-' */
  Rule_Operator_Minus,

  /* 101. <Operator> ::= '*' */
  Rule_Operator_Times,

  /* 102. <Operator> ::= '/' */
  Rule_Operator_Div,

  /* 103. <Operator> ::= '%' */
  Rule_Operator_Percent,

  /* 104. <Operator> ::= '^' */
  Rule_Operator_Caret,

  /* 105. <Operator> ::= '&' */
  Rule_Operator_Amp,

  /* 106. <Operator> ::= '|' */
  Rule_Operator_Pipe,

  /* 107. <Operator> ::= '~' */
  Rule_Operator_Tilde,

  /* 108. <Operator> ::= '!' */
  Rule_Operator_Exclam,

  /* 109. <Operator> ::= '=' */
  Rule_Operator_Eq,

  /* 110. <Operator> ::= '<' */
  Rule_Operator_Lt,

  /* 111. <Operator> ::= '>' */
  Rule_Operator_Gt,

  /* 112. <Operator> ::= '+=' */
  Rule_Operator_PlusEq,

  /* 113. <Operator> ::= '-=' */
  Rule_Operator_MinusEq,

  /* 114. <Operator> ::= '*=' */
  Rule_Operator_TimesEq,

  /* 115. <Operator> ::= '/=' */
  Rule_Operator_DivEq,

  /* 116. <Operator> ::= '%=' */
  Rule_Operator_PercentEq,

  /* 117. <Operator> ::= '^=' */
  Rule_Operator_CaretEq,

  /* 118. <Operator> ::= '&=' */
  Rule_Operator_AmpEq,

  /* 119. <Operator> ::= '|=' */
  Rule_Operator_PipeEq,

  /* 120. <Operator> ::= '<<' */
  Rule_Operator_LtLt,

  /* 121. <Operator> ::= '>>' */
  Rule_Operator_GtGt,

  /* 122. <Operator> ::= '>>=' */
  Rule_Operator_GtGtEq,

  /* 123. <Operator> ::= '<<=' */
  Rule_Operator_LtLtEq,

  /* 124. <Operator> ::= '==' */
  Rule_Operator_EqEq,

  /* 125. <Operator> ::= '!=' */
  Rule_Operator_ExclamEq,

  /* 126. <Operator> ::= '<=' */
  Rule_Operator_LtEq,

  /* 127. <Operator> ::= '>=' */
  Rule_Operator_GtEq,

  /* 128. <Operator> ::= '&&' */
  Rule_Operator_AmpAmp,

  /* 129. <Operator> ::= '||' */
  Rule_Operator_PipePipe,

  /* 130. <Operator> ::= '++' */
  Rule_Operator_PlusPlus,

  /* 131. <Operator> ::= '--' */
  Rule_Operator_MinusMinus,

  /* 132. <Operator> ::= ',' */
  Rule_Operator_Comma,

  /* 133. <Operator> ::= '(' ')' */
  Rule_Operator_LParen_RParen,

  /* 134. <Operator> ::= '[' ']' */
  Rule_Operator_LBracket_RBracket,

  /* 135. <Op Header Proto> ::= '(' <Params> ')' */
  Rule_OpHeaderProto_LParen_RParen,

  /* 136. <Op Header Proto> ::= '(' <Params> ')' '->' <Type> */
  Rule_OpHeaderProto_LParen_RParen_MinusGt,

  /* 137. <Op Header Proto> ::= '(' <Types> ')' */
  Rule_OpHeaderProto_LParen_RParen2,

  /* 138. <Op Header Proto> ::= '(' <Types> ')' '->' <Type> */
  Rule_OpHeaderProto_LParen_RParen_MinusGt2,

  /* 139. <Op Header Proto> ::= '(' ')' */
  Rule_OpHeaderProto_LParen_RParen3,

  /* 140. <Op Header Proto> ::= '(' ')' '->' <Type> */
  Rule_OpHeaderProto_LParen_RParen_MinusGt3,

  /* 141. <Op Header Impl> ::= '(' <Params> ')' */
  Rule_OpHeaderImpl_LParen_RParen,

  /* 142. <Op Header Impl> ::= '(' <Params> ')' '->' <Type> */
  Rule_OpHeaderImpl_LParen_RParen_MinusGt,

  /* 143. <Op Header Impl> ::= '(' ')' */
  Rule_OpHeaderImpl_LParen_RParen2,

  /* 144. <Op Header Impl> ::= '(' ')' '->' <Type> */
  Rule_OpHeaderImpl_LParen_RParen_MinusGt2,

  /* 145. <Var Decl> ::= let final <Var Header> */
  Rule_VarDecl_let_final,

  /* 146. <Var Decl> ::= let <Var Header> */
  Rule_VarDecl_let,

  /* 147. <Var Decl> ::= let local <Var Header> */
  Rule_VarDecl_let_local,

  /* 148. <Var Decl> ::= let local final <Var Header> */
  Rule_VarDecl_let_local_final,

  /* 149. <Var Decl> ::= let final local <Var Header> */
  Rule_VarDecl_let_final_local,

  /* 150. <CVar Decl> ::= let <private final static inherited> <Var Header> */
  Rule_CVarDecl_let,

  /* 151. <Var Header> ::= <Id List> ':' <Type> '=' <Expr> */
  Rule_VarHeader_Colon_Eq,

  /* 152. <Var Header> ::= <Id List> ':' <Type> */
  Rule_VarHeader_Colon,

  /* 153. <Var Header> ::= <Id List> '=' <Expr> */
  Rule_VarHeader_Eq,

  /* 154. <Enum Decl> ::= enum Id '{' <Enum Def> '}' */
  Rule_EnumDecl_enum_Id_LBrace_RBrace,

  /* 155. <Enum Decl> ::= local enum Id '{' <Enum Def> '}' */
  Rule_EnumDecl_local_enum_Id_LBrace_RBrace,

  /* 156. <Enum Def> ::= Id ',' <Enum Def> */
  Rule_EnumDef_Id_Comma,

  /* 157. <Enum Def> ::= Id */
  Rule_EnumDef_Id,

  /* 158. <Type> ::= <Base> */
  Rule_Type,

  /* 159. <Type> ::= <Fn Type> */
  Rule_Type2,

  /* 160. <Type> ::= <Pkg> */
  Rule_Type3,

  /* 161. <Type> ::= <Pkg> '<' <Types> '>' */
  Rule_Type_Lt_Gt,

  /* 162. <Type> ::= <Type> '[' ']' */
  Rule_Type_LBracket_RBracket,

  /* 163. <Type> ::= '(' <Types> ')' */
  Rule_Type_LParen_RParen,

  /* 164. <Fn Type> ::= fn '(' ')' */
  Rule_FnType_fn_LParen_RParen,

  /* 165. <Fn Type> ::= fn '(' ')' '->' <Type> */
  Rule_FnType_fn_LParen_RParen_MinusGt,

  /* 166. <Fn Type> ::= fn '(' <Types> ')' */
  Rule_FnType_fn_LParen_RParen2,

  /* 167. <Fn Type> ::= fn '(' <Types> ')' '->' <Type> */
  Rule_FnType_fn_LParen_RParen_MinusGt2,

  /* 168. <Base> ::= <Sign> <Scalar> */
  Rule_Base,

  /* 169. <Base> ::= 'size_t' */
  Rule_Base_size_t,

  /* 170. <Sign> ::= signed */
  Rule_Sign_signed,

  /* 171. <Sign> ::= unsigned */
  Rule_Sign_unsigned,

  /* 172. <Sign> ::=  */
  Rule_Sign,

  /* 173. <Scalar> ::= char */
  Rule_Scalar_char,

  /* 174. <Scalar> ::= int */
  Rule_Scalar_int,

  /* 175. <Scalar> ::= short */
  Rule_Scalar_short,

  /* 176. <Scalar> ::= long */
  Rule_Scalar_long,

  /* 177. <Scalar> ::= short int */
  Rule_Scalar_short_int,

  /* 178. <Scalar> ::= long int */
  Rule_Scalar_long_int,

  /* 179. <Scalar> ::= float */
  Rule_Scalar_float,

  /* 180. <Scalar> ::= double */
  Rule_Scalar_double,

  /* 181. <Scalar> ::= byte */
  Rule_Scalar_byte,

  /* 182. <Stm> ::= <Var Decl> */
  Rule_Stm,

  /* 183. <Stm> ::= <If Stm> */
  Rule_Stm2,

  /* 184. <Stm> ::= while <Expr> <Block> */
  Rule_Stm_while,

  /* 185. <Stm> ::= for <Arg> ';' <Arg> ';' <Arg> <Block> */
  Rule_Stm_for_Semi_Semi,

  /* 186. <Stm> ::= foreach Id in <Expr> <Block> */
  Rule_Stm_foreach_Id_in,

  /* 187. <Stm> ::= <Normal Stm> */
  Rule_Stm3,

  /* 188. <Using Stm> ::= using <Pkg> */
  Rule_UsingStm_using,

  /* 189. <Using Stms> ::= <Using Stm> <Using Stms> */
  Rule_UsingStms,

  /* 190. <Using Stms> ::=  */
  Rule_UsingStms2,

  /* 191. <Pkg> ::= Id '.' <Pkg> */
  Rule_Pkg_Id_Dot,

  /* 192. <Pkg> ::= Id */
  Rule_Pkg_Id,

  /* 193. <If Stm> ::= if <Expr> <Block> <else-if> */
  Rule_IfStm_if,

  /* 194. <else-if> ::= else if <Expr> <Block> <else-if> */
  Rule_elseif_else_if,

  /* 195. <else-if> ::= else <Block> */
  Rule_elseif_else,

  /* 196. <else-if> ::=  */
  Rule_elseif,

  /* 197. <Normal Stm> ::= do <Block> while <Expr> */
  Rule_NormalStm_do_while,

  /* 198. <Normal Stm> ::= match <Expr> '{' <Case Stms> '}' */
  Rule_NormalStm_match_LBrace_RBrace,

  /* 199. <Normal Stm> ::= <Block> */
  Rule_NormalStm,

  /* 200. <Normal Stm> ::= <Expr> */
  Rule_NormalStm2,

  /* 201. <Normal Stm> ::= break */
  Rule_NormalStm_break,

  /* 202. <Normal Stm> ::= continue */
  Rule_NormalStm_continue,

  /* 203. <Normal Stm> ::= return <Expr> */
  Rule_NormalStm_return,

  /* 204. <Normal Stm> ::= return */
  Rule_NormalStm_return2,

  /* 205. <Normal Stm> ::= ';' */
  Rule_NormalStm_Semi,

  /* 206. <Arg> ::= <Expr> */
  Rule_Arg,

  /* 207. <Arg> ::=  */
  Rule_Arg2,

  /* 208. <Case Stms> ::= case <Expr> when <Expr> <Block> <Case Stms> */
  Rule_CaseStms_case_when,

  /* 209. <Case Stms> ::= case <Expr> <Block> <Case Stms> */
  Rule_CaseStms_case,

  /* 210. <Case Stms> ::= else <Block> */
  Rule_CaseStms_else,

  /* 211. <Block> ::= '{' <Using Stms> <Stm List> '}' */
  Rule_Block_LBrace_RBrace,

  /* 212. <Stm List> ::= <Stm> <Stm List> */
  Rule_StmList,

  /* 213. <Stm List> ::=  */
  Rule_StmList2,

  /* 214. <CSE> ::= <Expr> */
  Rule_CSE,

  /* 215. <CSE> ::= <CSE> ',' <Expr> */
  Rule_CSE_Comma,

  /* 216. <Expr> ::= <Var Decl> in <Expr> */
  Rule_Expr_in,

  /* 217. <Expr> ::= match <Expr> '{' <Case Exprs> '}' */
  Rule_Expr_match_LBrace_RBrace,

  /* 218. <Expr> ::= <Op Assign> */
  Rule_Expr,

  /* 219. <Op Assign> ::= <Op Or> '=' <Op Assign> */
  Rule_OpAssign_Eq,

  /* 220. <Op Assign> ::= <Op Or> '+=' <Op Assign> */
  Rule_OpAssign_PlusEq,

  /* 221. <Op Assign> ::= <Op Or> '-=' <Op Assign> */
  Rule_OpAssign_MinusEq,

  /* 222. <Op Assign> ::= <Op Or> '*=' <Op Assign> */
  Rule_OpAssign_TimesEq,

  /* 223. <Op Assign> ::= <Op Or> '/=' <Op Assign> */
  Rule_OpAssign_DivEq,

  /* 224. <Op Assign> ::= <Op Or> '%=' <Op Assign> */
  Rule_OpAssign_PercentEq,

  /* 225. <Op Assign> ::= <Op Or> '^=' <Op Assign> */
  Rule_OpAssign_CaretEq,

  /* 226. <Op Assign> ::= <Op Or> '&=' <Op Assign> */
  Rule_OpAssign_AmpEq,

  /* 227. <Op Assign> ::= <Op Or> '|=' <Op Assign> */
  Rule_OpAssign_PipeEq,

  /* 228. <Op Assign> ::= <Op Or> '>>=' <Op Assign> */
  Rule_OpAssign_GtGtEq,

  /* 229. <Op Assign> ::= <Op Or> '<<=' <Op Assign> */
  Rule_OpAssign_LtLtEq,

  /* 230. <Op Assign> ::= <Op Or> */
  Rule_OpAssign,

  /* 231. <Op Or> ::= <Op Or> '||' <Op And> */
  Rule_OpOr_PipePipe,

  /* 232. <Op Or> ::= <Op And> */
  Rule_OpOr,

  /* 233. <Op And> ::= <Op And> '&&' <Op BinOR> */
  Rule_OpAnd_AmpAmp,

  /* 234. <Op And> ::= <Op BinOR> */
  Rule_OpAnd,

  /* 235. <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> */
  Rule_OpBinOR_Pipe,

  /* 236. <Op BinOR> ::= <Op BinXOR> */
  Rule_OpBinOR,

  /* 237. <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> */
  Rule_OpBinXOR_Caret,

  /* 238. <Op BinXOR> ::= <Op BinAND> */
  Rule_OpBinXOR,

  /* 239. <Op BinAND> ::= <Op BinAND> '&' <Op Equate> */
  Rule_OpBinAND_Amp,

  /* 240. <Op BinAND> ::= <Op Equate> */
  Rule_OpBinAND,

  /* 241. <Op Equate> ::= <Op Equate> '==' <Op Compare> */
  Rule_OpEquate_EqEq,

  /* 242. <Op Equate> ::= <Op Equate> '!=' <Op Compare> */
  Rule_OpEquate_ExclamEq,

  /* 243. <Op Equate> ::= <Op Compare> */
  Rule_OpEquate,

  /* 244. <Op Compare> ::= <Op Compare> '<' <Op Shift> */
  Rule_OpCompare_Lt,

  /* 245. <Op Compare> ::= <Op Compare> '>' <Op Shift> */
  Rule_OpCompare_Gt,

  /* 246. <Op Compare> ::= <Op Compare> '<=' <Op Shift> */
  Rule_OpCompare_LtEq,

  /* 247. <Op Compare> ::= <Op Compare> '>=' <Op Shift> */
  Rule_OpCompare_GtEq,

  /* 248. <Op Compare> ::= <Op Compare> is <Type> */
  Rule_OpCompare_is,

  /* 249. <Op Compare> ::= <Op Shift> */
  Rule_OpCompare,

  /* 250. <Op Shift> ::= <Op Shift> '<<' <Op Add> */
  Rule_OpShift_LtLt,

  /* 251. <Op Shift> ::= <Op Shift> '>>' <Op Add> */
  Rule_OpShift_GtGt,

  /* 252. <Op Shift> ::= <Op Add> */
  Rule_OpShift,

  /* 253. <Op Add> ::= <Op Add> '+' <Op Mult> */
  Rule_OpAdd_Plus,

  /* 254. <Op Add> ::= <Op Add> '-' <Op Mult> */
  Rule_OpAdd_Minus,

  /* 255. <Op Add> ::= <Op Mult> */
  Rule_OpAdd,

  /* 256. <Op Mult> ::= <Op Mult> '*' <Op Unary> */
  Rule_OpMult_Times,

  /* 257. <Op Mult> ::= <Op Mult> '/' <Op Unary> */
  Rule_OpMult_Div,

  /* 258. <Op Mult> ::= <Op Mult> '%' <Op Unary> */
  Rule_OpMult_Percent,

  /* 259. <Op Mult> ::= <Op Unary> */
  Rule_OpMult,

  /* 260. <Op Unary> ::= '!' <Op Unary> */
  Rule_OpUnary_Exclam,

  /* 261. <Op Unary> ::= '~' <Op Unary> */
  Rule_OpUnary_Tilde,

  /* 262. <Op Unary> ::= '-' <Op Unary> */
  Rule_OpUnary_Minus,

  /* 263. <Op Unary> ::= '++' <Op Unary> */
  Rule_OpUnary_PlusPlus,

  /* 264. <Op Unary> ::= '--' <Op Unary> */
  Rule_OpUnary_MinusMinus,

  /* 265. <Op Unary> ::= <Op Pointer> '++' */
  Rule_OpUnary_PlusPlus2,

  /* 266. <Op Unary> ::= <Op Pointer> '--' */
  Rule_OpUnary_MinusMinus2,

  /* 267. <Op Unary> ::= <Op Unary> as <Type> */
  Rule_OpUnary_as,

  /* 268. <Op Unary> ::= <New Expr> */
  Rule_OpUnary,

  /* 269. <Op Unary> ::= delete <Op Pointer> */
  Rule_OpUnary_delete,

  /* 270. <Op Unary> ::= sizeof '(' <Type> ')' */
  Rule_OpUnary_sizeof_LParen_RParen,

  /* 271. <Op Unary> ::= <Op Pointer> */
  Rule_OpUnary2,

  /* 272. <Op Pointer> ::= <Op Pointer> '.' <Value> */
  Rule_OpPointer_Dot,

  /* 273. <Op Pointer> ::= <Op Pointer> '[' <CSE> ']' */
  Rule_OpPointer_LBracket_RBracket,

  /* 274. <Op Pointer> ::= <Op Pointer> '(' <CSE> ')' */
  Rule_OpPointer_LParen_RParen,

  /* 275. <Op Pointer> ::= <Op Pointer> '(' ')' */
  Rule_OpPointer_LParen_RParen2,

  /* 276. <Op Pointer> ::= <Value> */
  Rule_OpPointer,

  /* 277. <Value> ::= OctLiteral */
  Rule_Value_OctLiteral,

  /* 278. <Value> ::= HexLiteral */
  Rule_Value_HexLiteral,

  /* 279. <Value> ::= DecLiteral */
  Rule_Value_DecLiteral,

  /* 280. <Value> ::= BinLiteral */
  Rule_Value_BinLiteral,

  /* 281. <Value> ::= StringLiteral */
  Rule_Value_StringLiteral,

  /* 282. <Value> ::= CharLiteral */
  Rule_Value_CharLiteral,

  /* 283. <Value> ::= FloatLiteral */
  Rule_Value_FloatLiteral,

  /* 284. <Value> ::= null */
  Rule_Value_null,

  /* 285. <Value> ::= '_' */
  Rule_Value__,

  /* 286. <Value> ::= <Pkg> */
  Rule_Value,

  /* 287. <Value> ::= <Lambda Expr> */
  Rule_Value2,

  /* 288. <Value> ::= '(' <CSE> ')' */
  Rule_Value_LParen_RParen,

  /* 289. <Value> ::= '[' for Id ':' <Type> in <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Id_Colon_in_EqGt_RBracket,

  /* 290. <Value> ::= '[' for Id in <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Id_in_EqGt_RBracket,

  /* 291. <Value> ::= '[' <CSE> ']' */
  Rule_Value_LBracket_RBracket,

  /* 292. <Lambda Expr> ::= lambda '(' <Params> ')' <Block> */
  Rule_LambdaExpr_lambda_LParen_RParen,

  /* 293. <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> */
  Rule_LambdaExpr_lambda_LParen_RParen_Eq,

  /* 294. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> */
  Rule_LambdaExpr_lambda_LParen_RParen_MinusGt,

  /* 295. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> */
  Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq,

  /* 296. <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> */
  Rule_CaseExprs_case_when_EqGt,

  /* 297. <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> */
  Rule_CaseExprs_case_EqGt,

  /* 298. <Case Exprs> ::= else '=>' <Expr> */
  Rule_CaseExprs_else_EqGt,

  /* 299. <New Expr> ::= new <Type> '(' ')' */
  Rule_NewExpr_new_LParen_RParen,

  /* 300. <New Expr> ::= new <Type> '(' <Expr> ')' */
  Rule_NewExpr_new_LParen_RParen2,

  /* 301. <New Expr> ::= new <Type> */
  Rule_NewExpr_new,

  /* 302. <New Expr> ::= new <Type> '(' ')' '{' <CDecl> '}' */
  Rule_NewExpr_new_LParen_RParen_LBrace_RBrace,

  /* 303. <New Expr> ::= new <Type> '(' <Expr> ')' '{' <CDecl> '}' */
  Rule_NewExpr_new_LParen_RParen_LBrace_RBrace2 
  };

ContextStruct* parseAst(struct TokenStruct *Token, ContextStruct *parent)
{
    RuleJumpTable[Token->ReductionRule](Token, parent);
    size_t i = 0;
      /*
    for(; i < parent->imports->size; i++)
    {
        ImportExpr* ie = getElement(parent->imports, i);
        char* path = calloc(ie->filePathSize+1, sizeof(char));
        wcstombs(path, ie->filePath, ie->filePathSize+1);


        if(!fileExists(path))
        {
            char* path2 = calloc(strlen(path)+strlen(getLibDir())+1, sizeof(char));
            strcat(path2, getLibDir());
            strcat(path2, path);

            if(fileExists(path2))
            {
                 report_Print("compiling %s", path2);
                 //compile(path2);
            }

        }
        else{
            report_Print("compiling %s", path);
            //compile(path);
        }

    }
*/
/*
    for (i = 0; i < parent->funcs->size; i++)
    {
        addElement(parentExpr->funcs, getElement(parent->funcs, i));
    }
    for (i = 0; i < parent->classes->size; i++)
    {
        addElement(parentExpr->classes, getElement(parent->classes, i));
    }
    for (i = 0; i < parent->enums->size; i++)
    {
        addElement(parentExpr->enums, getElement(parent->enums, i));
    }
    for (i = 0; i < parent->ctypes->size; i++)
    {
        addElement(parentExpr->ctypes, getElement(parent->ctypes, i));
    }
    for (i = 0; i < parent->vars->size; i++)
    {
        addElement(parentExpr->vars, getElement(parent->vars, i));
    }
    for (i = 0; i < parent->modules->size; i++)
    {
        addElement(parentExpr->modules, getElement(parent->modules, i));
    }
    for (i = 0; i < parent->cdefs->size; i++)
    {
        addElement(parentExpr->cdefs, getElement(parent->cdefs, i));
    }
    */

    return NULL;
}

#define space ShowIndent(n)

void dumpAST(ContextStruct *e, int n)
{
    /*
    ShowIndent(n);
    switch(e->type)
    {
      case ET_arrayExpr:
        space;printf("const array\n");
        dumpAST(e->arrayExpr->elements, n+1);
        break;
      case ET_asExpr:
        space;printf("BOP as\n");
        space;printf("Expr:\n");
    }*/
}
