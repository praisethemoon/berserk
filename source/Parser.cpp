/*

     ***** **                                                              *
  ******  ***                                                            **
 **   *  * **                                                            **
*    *  *  **                                                            **
    *  *   *              ***  ****       ****              ***  ****    **
   ** **  *        ***     **** **** *   * **** *    ***     **** **** * **  ***
   ** ** *        * ***     **   ****   **  ****    * ***     **   ****  ** * ***
   ** ***        *   ***    **         ****        *   ***    **         ***   *
   ** ** ***    **    ***   **           ***      **    ***   **         **   *
   ** **   ***  ********    **             ***    ********    **         **  *
   *  **     ** *******     **               ***  *******     **         ** **
      *      ** **          **          ****  **  **          **         ******
  ****     ***  ****    *   ***        * **** *   ****    *   ***        **  ***
 *  ********     *******     ***          ****     *******     ***       **   *** *
*     ****        *****                             *****                 **   ***
*
 **

Written by Soulaymen Chouri
Contact me @ akaisora@tuta.io

Copyright (c) 2016,Soulaymen Chouri (akaisora@tuta.io). All rights reserved.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the author nor the names of other contributors may be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>                  /* wchar_t */
#include <sys/stat.h>
#include <assert.h>
#include <string.h>

#include "Engine.h"                 /* The Kessels engine. */
#include "Grammar.h"                /* Generated by GOLD. */
#include "Parser.h"
#include "Defines.h"

#define TRIMREDUCTIONS 0            /* 0=off, 1=on */
#define DEBUG          1            /* 0=off, 1=on */


#define parseExpr(i, p) RuleJumpTable[Token->Tokens[i]->ReductionRule](Token->Tokens[i], p)
#define switchCaseExpr(i) case ET_##i: e->i = calloc(1, sizeof(e->i)); break
#define getToken(i) Token->Tokens[i]
#define match(t) assert(parent->type == t);


/***** Helper subroutines ***************************************************/


/* Make a readable copy of a string. All characters outside 32...127 are
displayed as a HEX number in square brackets, for example "[0A]". */
void ReadableString(wchar_t *Input, wchar_t *Output, long Width) {
    char s1[BUFSIZ];
    long i1;
    long i2;

    /* Sanity check. */
    if ((Output == NULL) || (Width < 1)) return;
    Output[0] = 0;
    if (Input == NULL) return;

    i1 = 0;
    i2 = 0;
    while ((i2 < Width - 1) && (Input[i1] != 0)) {
        if ((Input[i1] >= 32) && (Input[i1] <= 127)) {
            Output[i2++] = Input[i1];
        }
        else {
            if (Width - i2 > 4) {
                sprintf(s1, "%02X", Input[i1]);
                Output[i2++] = '[';
                Output[i2++] = s1[0];
                Output[i2++] = s1[1];
                Output[i2++] = ']';
            }
        }
        i1++;
    }
    Output[i2] = 0;
}


void ShowIndent(int Indent) {
    /*int i;
    for (i = 0; i < Indent; i++)
        report_Print("  ");*/
}


extern void (*RuleJumpTable[])(struct TokenStruct *Token, ContextStruct *Context);

/***** Rule subroutine template *********************************************/

/* This subroutine is a template of things that can happen in the
subroutine of a rule. It shows how to access the value of symbols
and how to call rules, and how to transport results and stuff via
the parent.

For example the rule:

<Increment> ::= <Expression> '+' Number

Has 3 sub-tokens:

Token->Tokens[0] = token for <Expression>, a rule
Token->Tokens[1] = token for '+', a symbol
Token->Tokens[2] = token for Number, a symbol

We know Token->Tokens[0] is a rule, because that's what the grammar
says. We may assume that the engine has fully populated the sub-tokens
and don't have to perform any checks. We can immediately call the
subroutine of the rule, like this:

RuleJumpTable[Token->Tokens[0]->ReductionRule](Token->Tokens[0],parent);

The subroutine should hand back it's results via the parent. Here
is an example of how to store a result in the parent:

parent->ReturnValue = (wchar_t *)wcsdup(....);

Symbols are literal strings from the input (that was parsed by the
engine), stored in the sub-token. We can get the value of the "Number"
symbol like this:

Value = (wchar_t *)wcsdup(Token->Tokens[2]->Data);

Further reading:
- See "engine.h" for the definition of the TokenStruct.
- See "readme.txt" for a short discussion on how to use the content
of a Token.
- See "example4.c" for a working template example.
*/

void RuleTemplate(struct TokenStruct *Token, ContextStruct *parent) {
    int i;

    /* Debugging: show the description of the rule. */
    if (parent->Debug > 0) {
        ShowIndent(parent->Indent);
        printf("Executing rule: %ls\n", Grammar.RuleArray[Token->ReductionRule].Description);
    }

    /* For all the sub-Tokens. */
    for (i = 0; i < Grammar.RuleArray[Token->ReductionRule].SymbolsCount; i++) {
        /* See if the Token is a Symbol or a Rule. */
        if (Token->Tokens[i]->ReductionRule < 0) {
            /* It's a Symbol. Make a copy of the Data. Most symbols are grammar,
            for example '+', 'function', 'while', and such, and you won't
            need to look at the Data. Other symbols are literals from the input
            script, for example numbers, strings, variable names, and such. */
            if (parent->ReturnValue != NULL) free(parent->ReturnValue);
            parent->ReturnValue = (wchar_t *)wcsdup(Token->Tokens[i]->Data);

            /* Debugging: show a description of the Symbol, and it's value. */
            if (parent->Debug > 0) {
                ShowIndent(parent->Indent + 1);
                printf("Token[%u] = Symbol('%ls') = '%ls'\n", i,
                    Grammar.SymbolArray[Token->Tokens[i]->Symbol].Name,
                    parent->ReturnValue);
            }

        }
        else {
            /* It's a rule. */

            /* Debugging: show a description of the rule. */
            if (parent->Debug > 0) {
                ShowIndent(parent->Indent + 1);
                printf("Token[%u] = Rule = %ls\n", i,
                    Grammar.RuleArray[Token->Tokens[i]->ReductionRule].Description);
            }

            /* Call the rule's subroutine via the RuleJumpTable. */
            parent->Indent = parent->Indent + 1;
            RuleJumpTable[Token->Tokens[i]->ReductionRule](Token->Tokens[i], parent);
            parent->Indent = parent->Indent - 1;

            /* At this point you will probably want to save the parent->ReturnValue
            somewhere. */

            /* Debugging: show the value that was returned by the rule's subroutine. */
            if (parent->Debug > 0) {
                ShowIndent(parent->Indent + 2);
                printf("Result value = %ls\n", parent->ReturnValue);
            }
        }
    }

    /* Do whatever processing is needed by the rule. Remember to free() the
    Values you have saved. */
}


/***** Rule subroutines *****************************************************/




/* <Decls> ::= <Imports> <Using Stms> <Decl List> */
void Rule_Decls(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decls> ::=  */
void Rule_Decls2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl List> ::= <Decl> <Decl List> */
void Rule_DeclList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl List> ::= <Decl> */
void Rule_DeclList2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Func Decl> */
void Rule_Decl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Class Decl> */
void Rule_Decl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Enum Decl> */
void Rule_Decl3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Var Decl> */
void Rule_Decl4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <CDefFunc Decl> */
void Rule_Decl5(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Imports> ::= <Import> <Imports> */
void Rule_Imports(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Imports> ::=  */
void Rule_Imports2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= import <File Path All> */
void Rule_Import_import(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= import <File Path> as Id */
void Rule_Import_import_as_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= from <File Path> import <File Path List> */
void Rule_Import_from_import(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path> ::= Id '.' <File Path> */
void Rule_FilePath_Id_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path> ::= Id */
void Rule_FilePath_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path All> ::= Id '.' <File Path All> */
void Rule_FilePathAll_Id_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path All> ::= Id '.*' */
void Rule_FilePathAll_Id_DotTimes(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path All> ::= Id */
void Rule_FilePathAll_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path List> ::= <File Path> ',' <File Path List> */
void Rule_FilePathList_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path List> ::= <File Path> */
void Rule_FilePathList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Params> ')' */
void Rule_FnHeaderProto_Id_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Params> ')' '->' <Type> */
void Rule_FnHeaderProto_Id_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Types> ')' */
void Rule_FnHeaderProto_Id_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Types> ')' '->' <Type> */
void Rule_FnHeaderProto_Id_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' ')' */
void Rule_FnHeaderProto_Id_LParen_RParen3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' ')' '->' <Type> */
void Rule_FnHeaderProto_Id_LParen_RParen_MinusGt3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' <Params> ')' */
void Rule_FnHeaderImpl_Id_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' <Params> ')' '->' <Type> */
void Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' ')' */
void Rule_FnHeaderImpl_Id_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' ')' '->' <Type> */
void Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= local function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_local_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= synchronized function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_synchronized_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= synchronized local function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_synchronized_local_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= local synchronized function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_local_synchronized_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= pure function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_pure_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= local pure function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_local_pure_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= pure local function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_pure_local_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Body> ::= '=' <Expr> */
void Rule_FuncBody_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Body> ::= <Block> */
void Rule_FuncBody(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= function <Fn Header Proto> */
void Rule_CFuncProto_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure function <Fn Header Proto> */
void Rule_CFuncProto_pure_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static function <Fn Header Proto> */
void Rule_CFuncProto_static_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Visibility> function <Fn Header Proto> */
void Rule_CFuncProto_function2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Inherited> function <Fn Header Proto> */
void Rule_CFuncProto_function3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure static function <Fn Header Proto> */
void Rule_CFuncProto_pure_static_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure <Visibility> function <Fn Header Proto> */
void Rule_CFuncProto_pure_function2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure <Inherited> function <Fn Header Proto> */
void Rule_CFuncProto_pure_function3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static pure function <Fn Header Proto> */
void Rule_CFuncProto_static_pure_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static <Visibility> function <Fn Header Proto> */
void Rule_CFuncProto_static_function2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static <Inherited> function <Fn Header Proto> */
void Rule_CFuncProto_static_function3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Visibility> pure function <Fn Header Proto> */
void Rule_CFuncProto_pure_function4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Visibility> static function <Fn Header Proto> */
void Rule_CFuncProto_static_function4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Visibility> <Inherited> function <Fn Header Proto> */
void Rule_CFuncProto_function4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Inherited> pure function <Fn Header Proto> */
void Rule_CFuncProto_pure_function5(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Inherited> <Visibility> function <Fn Header Proto> */
void Rule_CFuncProto_function5(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Inherited> static function <Fn Header Proto> */
void Rule_CFuncProto_static_function5(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure static <Visibility> function <Fn Header Proto> */
void Rule_CFuncProto_pure_static_function2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure <Visibility> static function <Fn Header Proto> */
void Rule_CFuncProto_pure_static_function3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure <Visibility> <Inherited> function <Fn Header Proto> */
void Rule_CFuncProto_pure_function6(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure <Inherited> <Visibility> function <Fn Header Proto> */
void Rule_CFuncProto_pure_function7(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static pure <Visibility> function <Fn Header Proto> */
void Rule_CFuncProto_static_pure_function2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static <Visibility> pure function <Fn Header Proto> */
void Rule_CFuncProto_static_pure_function3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static <Visibility> <Inherited> function <Fn Header Proto> */
void Rule_CFuncProto_static_function6(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static <Inherited> <Visibility> function <Fn Header Proto> */
void Rule_CFuncProto_static_function7(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Inherited> <Visibility> pure function <Fn Header Proto> */
void Rule_CFuncProto_pure_function8(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Inherited> pure <Visibility> function <Fn Header Proto> */
void Rule_CFuncProto_pure_function9(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Inherited> pure static function <Fn Header Proto> */
void Rule_CFuncProto_pure_static_function4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Decl> ::= <CFunc Proto> <Func Body> */
void Rule_CFuncDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_extern_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= extern pure function <Fn Header Proto> */
void Rule_CDefFuncDecl_extern_pure_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= extern local function <Fn Header Proto> */
void Rule_CDefFuncDecl_extern_local_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= local extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_local_extern_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= local pure extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_local_pure_extern_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= local extern pure function <Fn Header Proto> */
void Rule_CDefFuncDecl_local_extern_pure_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= pure extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_pure_extern_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= pure local extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_pure_local_extern_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= pure extern local function <Fn Header Proto> */
void Rule_CDefFuncDecl_pure_extern_local_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Visibility> ::= public */
void Rule_Visibility_public(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Visibility> ::= private */
void Rule_Visibility_private(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Visibility> ::= protected */
void Rule_Visibility_protected(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Inherited> ::= inherited '(' <Pkg List> ')' */
void Rule_Inherited_inherited_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Inherited> ::= inherited */
void Rule_Inherited_inherited(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Params> ::= <Param> ',' <Params> */
void Rule_Params_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Params> ::= <Param> */
void Rule_Params(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Param> ::= final Id ':' <Type> */
void Rule_Param_final_Id_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Param> ::= Id ':' <Type> */
void Rule_Param_Id_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Types> ::= <Type> ',' <Types> */
void Rule_Types_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Types> ::= <Type> */
void Rule_Types(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Id List> ::= Id ',' <Id List> */
void Rule_IdList_Id_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Id List> ::= Id */
void Rule_IdList_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= <Normal Class> */
void Rule_ClassDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= <Abstract Class> */
void Rule_ClassDecl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= local <Normal Class> */
void Rule_ClassDecl_local(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= local <Abstract Class> */
void Rule_ClassDecl_local2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Class> ::= class <Class Name> '{' <CDecls> '}' */
void Rule_NormalClass_class_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Class> ::= class <Class Name> extends <Extend Class Name List> '{' <CDecls> '}' */
void Rule_NormalClass_class_extends_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Abstract Class> ::= abstract class <Class Name> '{' <ACDecls> '}' */
void Rule_AbstractClass_abstract_class_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Abstract Class> ::= abstract class <Class Name> extends <Extend Class Name List> '{' <ACDecls> '}' */
void Rule_AbstractClass_abstract_class_extends_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Name> ::= Id */
void Rule_ClassName_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Name> ::= Id '<' <Id List> '>' */
void Rule_ClassName_Id_Lt_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name List> ::= <Extend Class Name> ',' <Extend Class Name List> */
void Rule_ExtendClassNameList_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name List> ::= <Extend Class Name> */
void Rule_ExtendClassNameList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name> ::= <Pkg> */
void Rule_ExtendClassName(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name> ::= <Pkg> '<' <Extend Class Name List> '>' */
void Rule_ExtendClassName_Lt_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecls> ::= <CDecl> <CDecls> */
void Rule_CDecls(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecls> ::=  */
void Rule_CDecls2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecls> ::= <ACDecl> <ACDecls> */
void Rule_ACDecls(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecls> ::=  */
void Rule_ACDecls2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <CFunc Decl> */
void Rule_CDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <CVar Decl> */
void Rule_CDecl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <Operator Impl> */
void Rule_CDecl3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CFunc Decl> */
void Rule_ACDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CFunc Proto> */
void Rule_ACDecl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CVar Decl> */
void Rule_ACDecl3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <Operator Impl> */
void Rule_ACDecl4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <Operator Proto> */
void Rule_ACDecl5(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator Impl> ::= operator <Operator> <Op Header Impl> '=' <Expr> */
void Rule_OperatorImpl_operator_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator Impl> ::= operator <Operator> <Op Header Impl> <Block> */
void Rule_OperatorImpl_operator(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator Proto> ::= operator <Operator> <Op Header Proto> */
void Rule_OperatorProto_operator(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefStruct> ::= extern struct Id '{' <Params> '}' */
void Rule_CDefStruct_extern_struct_Id_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '+' */
void Rule_Operator_Plus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '-' */
void Rule_Operator_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '*' */
void Rule_Operator_Times(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '/' */
void Rule_Operator_Div(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '%' */
void Rule_Operator_Percent(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '^' */
void Rule_Operator_Caret(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&' */
void Rule_Operator_Amp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '|' */
void Rule_Operator_Pipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '~' */
void Rule_Operator_Tilde(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '!' */
void Rule_Operator_Exclam(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '=' */
void Rule_Operator_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<' */
void Rule_Operator_Lt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>' */
void Rule_Operator_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '+=' */
void Rule_Operator_PlusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '-=' */
void Rule_Operator_MinusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '*=' */
void Rule_Operator_TimesEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '/=' */
void Rule_Operator_DivEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '%=' */
void Rule_Operator_PercentEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '^=' */
void Rule_Operator_CaretEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&=' */
void Rule_Operator_AmpEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '|=' */
void Rule_Operator_PipeEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<<' */
void Rule_Operator_LtLt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>>' */
void Rule_Operator_GtGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>>=' */
void Rule_Operator_GtGtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<<=' */
void Rule_Operator_LtLtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '==' */
void Rule_Operator_EqEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '!=' */
void Rule_Operator_ExclamEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<=' */
void Rule_Operator_LtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>=' */
void Rule_Operator_GtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&&' */
void Rule_Operator_AmpAmp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '||' */
void Rule_Operator_PipePipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '++' */
void Rule_Operator_PlusPlus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '--' */
void Rule_Operator_MinusMinus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= ',' */
void Rule_Operator_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '(' ')' */
void Rule_Operator_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '[' ']' */
void Rule_Operator_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Params> ')' */
void Rule_OpHeaderProto_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Params> ')' '->' <Type> */
void Rule_OpHeaderProto_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Types> ')' */
void Rule_OpHeaderProto_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Types> ')' '->' <Type> */
void Rule_OpHeaderProto_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' ')' */
void Rule_OpHeaderProto_LParen_RParen3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' ')' '->' <Type> */
void Rule_OpHeaderProto_LParen_RParen_MinusGt3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' <Params> ')' */
void Rule_OpHeaderImpl_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' <Params> ')' '->' <Type> */
void Rule_OpHeaderImpl_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' ')' */
void Rule_OpHeaderImpl_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' ')' '->' <Type> */
void Rule_OpHeaderImpl_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let final <Var Header> */
void Rule_VarDecl_let_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let <Var Header> */
void Rule_VarDecl_let(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let local <Var Header> */
void Rule_VarDecl_let_local(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let local final <Var Header> */
void Rule_VarDecl_let_local_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let final local <Var Header> */
void Rule_VarDecl_let_final_local(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let atomic <Var Header> */
void Rule_VarDecl_let_atomic(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let local atomic <Var Header> */
void Rule_VarDecl_let_local_atomic(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let atomic local <Var Header> */
void Rule_VarDecl_let_atomic_local(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Var Header> */
void Rule_CVarDecl_let(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let final <Var Header> */
void Rule_CVarDecl_let_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let final static <Var Header> */
void Rule_CVarDecl_let_final_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let final <Visibility> <Var Header> */
void Rule_CVarDecl_let_final2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let final <Visibility> static <Var Header> */
void Rule_CVarDecl_let_final_static2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let final static <Visibility> <Var Header> */
void Rule_CVarDecl_let_final_static3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static <Var Header> */
void Rule_CVarDecl_let_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static final <Var Header> */
void Rule_CVarDecl_let_static_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static atomic <Var Header> */
void Rule_CVarDecl_let_static_atomic(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static <Visibility> <Var Header> */
void Rule_CVarDecl_let_static2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static <Visibility> atomic <Var Header> */
void Rule_CVarDecl_let_static_atomic2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static <Visibility> final <Var Header> */
void Rule_CVarDecl_let_static_final2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static atomic <Visibility> <Var Header> */
void Rule_CVarDecl_let_static_atomic3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> <Var Header> */
void Rule_CVarDecl_let2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> static <Var Header> */
void Rule_CVarDecl_let_static3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> static atomic <Var Header> */
void Rule_CVarDecl_let_static_atomic4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> final <Var Header> */
void Rule_CVarDecl_let_final3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> static final <Var Header> */
void Rule_CVarDecl_let_static_final3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> final static <Var Header> */
void Rule_CVarDecl_let_final_static4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> atomic static */
void Rule_CVarDecl_let_atomic_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let atomic <Var Header> */
void Rule_CVarDecl_let_atomic(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let atomic <Visibility> <Var Header> */
void Rule_CVarDecl_let_atomic2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let atomic static <Var Header> */
void Rule_CVarDecl_let_atomic_static2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let atomic <Visibility> static <Var Header> */
void Rule_CVarDecl_let_atomic_static3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let atomic static <Visibility> <Var Header> */
void Rule_CVarDecl_let_atomic_static4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> ':' <Type> '=' <CSE> */
void Rule_VarHeader_Colon_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> ':' <Type> */
void Rule_VarHeader_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> '=' <CSE> */
void Rule_VarHeader_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Decl> ::= enum Id '{' <Enum Def> '}' */
void Rule_EnumDecl_enum_Id_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Decl> ::= local enum Id '{' <Enum Def> '}' */
void Rule_EnumDecl_local_enum_Id_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Def> ::= Id ',' <Enum Def> */
void Rule_EnumDef_Id_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Def> ::= Id */
void Rule_EnumDef_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Base> */
void Rule_Type(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Fn Type> */
void Rule_Type2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Pkg Template> */
void Rule_Type3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Type> '[' ']' */
void Rule_Type_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= '(' <Types> ')' */
void Rule_Type_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' ')' */
void Rule_FnType_fn_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' ')' '->' <Type> */
void Rule_FnType_fn_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' <Types> ')' */
void Rule_FnType_fn_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' <Types> ')' '->' <Type> */
void Rule_FnType_fn_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg Template> ::= <Pkg> */
void Rule_PkgTemplate(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg Template> ::= <Pkg> '<' <Types> '>' */
void Rule_PkgTemplate_Lt_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= <Sign> <Scalar> */
void Rule_Base(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'size_t' */
void Rule_Base_size_t(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= byte */
void Rule_Base_byte(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= float */
void Rule_Base_float(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= double */
void Rule_Base_double(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= bool */
void Rule_Base_bool(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= long double */
void Rule_Base_long_double(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::= signed */
void Rule_Sign_signed(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::= unsigned */
void Rule_Sign_unsigned(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::=  */
void Rule_Sign(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= char */
void Rule_Scalar_char(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= int */
void Rule_Scalar_int(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= short */
void Rule_Scalar_short(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= long */
void Rule_Scalar_long(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= short int */
void Rule_Scalar_short_int(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= long int */
void Rule_Scalar_long_int(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <Var Decl> */
void Rule_Stm(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <If Stm> */
void Rule_Stm2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= while <Expr> <Block> */
void Rule_Stm_while(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= for <Arg> ';' <Arg> ';' <Arg> <Block> */
void Rule_Stm_for_Semi_Semi(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= foreach <Param> in <Expr> <Block> */
void Rule_Stm_foreach_in(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <Normal Stm> */
void Rule_Stm3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Using Stm> ::= using <Pkg> */
void Rule_UsingStm_using(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Using Stms> ::= <Using Stm> <Using Stms> */
void Rule_UsingStms(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Using Stms> ::=  */
void Rule_UsingStms2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg> ::= Id '.' <Pkg> */
void Rule_Pkg_Id_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg> ::= Id */
void Rule_Pkg_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg List> ::= <Pkg> ',' <Pkg List> */
void Rule_PkgList_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg List> ::= <Pkg> */
void Rule_PkgList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <If Stm> ::= if <Expr> <Block> <else-if> */
void Rule_IfStm_if(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::= else if <Expr> <Block> <else-if> */
void Rule_elseif_else_if(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::= else <Block> */
void Rule_elseif_else(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::=  */
void Rule_elseif(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= do <Block> while <Expr> */
void Rule_NormalStm_do_while(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= match <Expr> '{' <Case Stms> '}' */
void Rule_NormalStm_match_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= <Block> */
void Rule_NormalStm(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= <Expr> */
void Rule_NormalStm2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= break */
void Rule_NormalStm_break(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= continue */
void Rule_NormalStm_continue(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= return <Expr> */
void Rule_NormalStm_return(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= return */
void Rule_NormalStm_return2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= ';' */
void Rule_NormalStm_Semi(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Arg> ::= <Expr> */
void Rule_Arg(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Arg> ::=  */
void Rule_Arg2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= case <Expr> when <Expr> <Block> <Case Stms> */
void Rule_CaseStms_case_when(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= case <Expr> <Block> <Case Stms> */
void Rule_CaseStms_case(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= else <Block> */
void Rule_CaseStms_else(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Block> ::= '{' <Using Stms> <Stm List> '}' */
void Rule_Block_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Block> ::= synchronized '{' <Using Stms> <Stm List> '}' */
void Rule_Block_synchronized_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm List> ::= <Stm> <Stm List> */
void Rule_StmList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm List> ::=  */
void Rule_StmList2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CSE> ::= <Expr> */
void Rule_CSE(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CSE> ::= <CSE> ',' <Expr> */
void Rule_CSE_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Var Decl> in <Expr> */
void Rule_Expr_in(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= match <Expr> '{' <Case Exprs> '}' */
void Rule_Expr_match_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Op Assign> */
void Rule_Expr(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '=' <Op Assign> */
void Rule_OpAssign_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '+=' <Op Assign> */
void Rule_OpAssign_PlusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '-=' <Op Assign> */
void Rule_OpAssign_MinusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '*=' <Op Assign> */
void Rule_OpAssign_TimesEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '/=' <Op Assign> */
void Rule_OpAssign_DivEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '%=' <Op Assign> */
void Rule_OpAssign_PercentEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '^=' <Op Assign> */
void Rule_OpAssign_CaretEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '&=' <Op Assign> */
void Rule_OpAssign_AmpEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '|=' <Op Assign> */
void Rule_OpAssign_PipeEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '>>=' <Op Assign> */
void Rule_OpAssign_GtGtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '<<=' <Op Assign> */
void Rule_OpAssign_LtLtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> */
void Rule_OpAssign(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Or> ::= <Op Or> '||' <Op And> */
void Rule_OpOr_PipePipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Or> ::= <Op And> */
void Rule_OpOr(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op And> ::= <Op And> '&&' <Op BinOR> */
void Rule_OpAnd_AmpAmp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op And> ::= <Op BinOR> */
void Rule_OpAnd(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> */
void Rule_OpBinOR_Pipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinOR> ::= <Op BinXOR> */
void Rule_OpBinOR(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> */
void Rule_OpBinXOR_Caret(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinXOR> ::= <Op BinAND> */
void Rule_OpBinXOR(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinAND> ::= <Op BinAND> '&' <Op Equate> */
void Rule_OpBinAND_Amp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinAND> ::= <Op Equate> */
void Rule_OpBinAND(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Equate> '==' <Op Compare> */
void Rule_OpEquate_EqEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Equate> '!=' <Op Compare> */
void Rule_OpEquate_ExclamEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Compare> */
void Rule_OpEquate(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '<' <Op Shift> */
void Rule_OpCompare_Lt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '>' <Op Shift> */
void Rule_OpCompare_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '<=' <Op Shift> */
void Rule_OpCompare_LtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '>=' <Op Shift> */
void Rule_OpCompare_GtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> is <Type> */
void Rule_OpCompare_is(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Shift> */
void Rule_OpCompare(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Shift> '<<' <Op Add> */
void Rule_OpShift_LtLt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Shift> '>>' <Op Add> */
void Rule_OpShift_GtGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Add> */
void Rule_OpShift(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Add> '+' <Op Mult> */
void Rule_OpAdd_Plus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Add> '-' <Op Mult> */
void Rule_OpAdd_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Mult> */
void Rule_OpAdd(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '*' <Op Unary> */
void Rule_OpMult_Times(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '/' <Op Unary> */
void Rule_OpMult_Div(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '%' <Op Unary> */
void Rule_OpMult_Percent(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Unary> */
void Rule_OpMult(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '!' <Op Unary> */
void Rule_OpUnary_Exclam(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '~' <Op Unary> */
void Rule_OpUnary_Tilde(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '-' <Op Unary> */
void Rule_OpUnary_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '++' <Op Unary> */
void Rule_OpUnary_PlusPlus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '--' <Op Unary> */
void Rule_OpUnary_MinusMinus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> '++' */
void Rule_OpUnary_PlusPlus2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> '--' */
void Rule_OpUnary_MinusMinus2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Unary> as <Type> */
void Rule_OpUnary_as(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <New Expr> */
void Rule_OpUnary(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= delete <Op Pointer> */
void Rule_OpUnary_delete(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= sizeof '(' <Type> ')' */
void Rule_OpUnary_sizeof_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> */
void Rule_OpUnary2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '.' <Value> */
void Rule_OpPointer_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '[' <CSE> ']' */
void Rule_OpPointer_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '(' <CSE> ')' */
void Rule_OpPointer_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '(' ')' */
void Rule_OpPointer_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Value> */
void Rule_OpPointer(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= OctLiteral */
void Rule_Value_OctLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= HexLiteral */
void Rule_Value_HexLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= DecLiteral */
void Rule_Value_DecLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= BinLiteral */
void Rule_Value_BinLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= StringLiteral */
void Rule_Value_StringLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= CharLiteral */
void Rule_Value_CharLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= FloatLiteral */
void Rule_Value_FloatLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= null */
void Rule_Value_null(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '_' */
void Rule_Value__(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= true */
void Rule_Value_true(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= false */
void Rule_Value_false(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= <Pkg> */
void Rule_Value(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= <Lambda Expr> */
void Rule_Value2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '(' <CSE> ')' */
void Rule_Value_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Id ':' <Type> in <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Id_Colon_in_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Id in <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Id_in_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Id ':' <Type> in <Expr> if <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Id_Colon_in_if_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Id in <Expr> if <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Id_in_if_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' <CSE> ']' */
void Rule_Value_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' <Block> */
void Rule_LambdaExpr_lambda_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> */
void Rule_LambdaExpr_lambda_LParen_RParen_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> */
void Rule_LambdaExpr_lambda_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> */
void Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> */
void Rule_CaseExprs_case_when_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> */
void Rule_CaseExprs_case_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= else '=>' <Expr> */
void Rule_CaseExprs_else_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Pkg Template> '(' ')' */
void Rule_NewExpr_new_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Pkg Template> '(' <Expr> ')' */
void Rule_NewExpr_new_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Pkg Template> '(' ')' '{' <CDecl> '}' */
void Rule_NewExpr_new_LParen_RParen_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Pkg Template> '(' <Expr> ')' '{' <CDecl> '}' */
void Rule_NewExpr_new_LParen_RParen_LBrace_RBrace2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> */
void Rule_NewExpr_new(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> '[' <Expr> ']' */
void Rule_NewExpr_new_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/***** Rule jumptable *******************************************************/




void (*RuleJumpTable[])(struct TokenStruct *Token, struct ContextStruct *Context) = {

  /* 0. <Decls> ::= <Imports> <Using Stms> <Decl List> */
  Rule_Decls,

  /* 1. <Decls> ::=  */
  Rule_Decls2,

  /* 2. <Decl List> ::= <Decl> <Decl List> */
  Rule_DeclList,

  /* 3. <Decl List> ::= <Decl> */
  Rule_DeclList2,

  /* 4. <Decl> ::= <Func Decl> */
  Rule_Decl,

  /* 5. <Decl> ::= <Class Decl> */
  Rule_Decl2,

  /* 6. <Decl> ::= <Enum Decl> */
  Rule_Decl3,

  /* 7. <Decl> ::= <Var Decl> */
  Rule_Decl4,

  /* 8. <Decl> ::= <CDefFunc Decl> */
  Rule_Decl5,

  /* 9. <Imports> ::= <Import> <Imports> */
  Rule_Imports,

  /* 10. <Imports> ::=  */
  Rule_Imports2,

  /* 11. <Import> ::= import <File Path All> */
  Rule_Import_import,

  /* 12. <Import> ::= import <File Path> as Id */
  Rule_Import_import_as_Id,

  /* 13. <Import> ::= from <File Path> import <File Path List> */
  Rule_Import_from_import,

  /* 14. <File Path> ::= Id '.' <File Path> */
  Rule_FilePath_Id_Dot,

  /* 15. <File Path> ::= Id */
  Rule_FilePath_Id,

  /* 16. <File Path All> ::= Id '.' <File Path All> */
  Rule_FilePathAll_Id_Dot,

  /* 17. <File Path All> ::= Id '.*' */
  Rule_FilePathAll_Id_DotTimes,

  /* 18. <File Path All> ::= Id */
  Rule_FilePathAll_Id,

  /* 19. <File Path List> ::= <File Path> ',' <File Path List> */
  Rule_FilePathList_Comma,

  /* 20. <File Path List> ::= <File Path> */
  Rule_FilePathList,

  /* 21. <Fn Header Proto> ::= Id '(' <Params> ')' */
  Rule_FnHeaderProto_Id_LParen_RParen,

  /* 22. <Fn Header Proto> ::= Id '(' <Params> ')' '->' <Type> */
  Rule_FnHeaderProto_Id_LParen_RParen_MinusGt,

  /* 23. <Fn Header Proto> ::= Id '(' <Types> ')' */
  Rule_FnHeaderProto_Id_LParen_RParen2,

  /* 24. <Fn Header Proto> ::= Id '(' <Types> ')' '->' <Type> */
  Rule_FnHeaderProto_Id_LParen_RParen_MinusGt2,

  /* 25. <Fn Header Proto> ::= Id '(' ')' */
  Rule_FnHeaderProto_Id_LParen_RParen3,

  /* 26. <Fn Header Proto> ::= Id '(' ')' '->' <Type> */
  Rule_FnHeaderProto_Id_LParen_RParen_MinusGt3,

  /* 27. <Fn Header Impl> ::= Id '(' <Params> ')' */
  Rule_FnHeaderImpl_Id_LParen_RParen,

  /* 28. <Fn Header Impl> ::= Id '(' <Params> ')' '->' <Type> */
  Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt,

  /* 29. <Fn Header Impl> ::= Id '(' ')' */
  Rule_FnHeaderImpl_Id_LParen_RParen2,

  /* 30. <Fn Header Impl> ::= Id '(' ')' '->' <Type> */
  Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt2,

  /* 31. <Func Decl> ::= function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_function,

  /* 32. <Func Decl> ::= local function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_local_function,

  /* 33. <Func Decl> ::= synchronized function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_synchronized_function,

  /* 34. <Func Decl> ::= synchronized local function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_synchronized_local_function,

  /* 35. <Func Decl> ::= local synchronized function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_local_synchronized_function,

  /* 36. <Func Decl> ::= pure function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_pure_function,

  /* 37. <Func Decl> ::= local pure function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_local_pure_function,

  /* 38. <Func Decl> ::= pure local function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_pure_local_function,

  /* 39. <Func Body> ::= '=' <Expr> */
  Rule_FuncBody_Eq,

  /* 40. <Func Body> ::= <Block> */
  Rule_FuncBody,

  /* 41. <CFunc Proto> ::= function <Fn Header Proto> */
  Rule_CFuncProto_function,

  /* 42. <CFunc Proto> ::= pure function <Fn Header Proto> */
  Rule_CFuncProto_pure_function,

  /* 43. <CFunc Proto> ::= static function <Fn Header Proto> */
  Rule_CFuncProto_static_function,

  /* 44. <CFunc Proto> ::= <Visibility> function <Fn Header Proto> */
  Rule_CFuncProto_function2,

  /* 45. <CFunc Proto> ::= <Inherited> function <Fn Header Proto> */
  Rule_CFuncProto_function3,

  /* 46. <CFunc Proto> ::= pure static function <Fn Header Proto> */
  Rule_CFuncProto_pure_static_function,

  /* 47. <CFunc Proto> ::= pure <Visibility> function <Fn Header Proto> */
  Rule_CFuncProto_pure_function2,

  /* 48. <CFunc Proto> ::= pure <Inherited> function <Fn Header Proto> */
  Rule_CFuncProto_pure_function3,

  /* 49. <CFunc Proto> ::= static pure function <Fn Header Proto> */
  Rule_CFuncProto_static_pure_function,

  /* 50. <CFunc Proto> ::= static <Visibility> function <Fn Header Proto> */
  Rule_CFuncProto_static_function2,

  /* 51. <CFunc Proto> ::= static <Inherited> function <Fn Header Proto> */
  Rule_CFuncProto_static_function3,

  /* 52. <CFunc Proto> ::= <Visibility> pure function <Fn Header Proto> */
  Rule_CFuncProto_pure_function4,

  /* 53. <CFunc Proto> ::= <Visibility> static function <Fn Header Proto> */
  Rule_CFuncProto_static_function4,

  /* 54. <CFunc Proto> ::= <Visibility> <Inherited> function <Fn Header Proto> */
  Rule_CFuncProto_function4,

  /* 55. <CFunc Proto> ::= <Inherited> pure function <Fn Header Proto> */
  Rule_CFuncProto_pure_function5,

  /* 56. <CFunc Proto> ::= <Inherited> <Visibility> function <Fn Header Proto> */
  Rule_CFuncProto_function5,

  /* 57. <CFunc Proto> ::= <Inherited> static function <Fn Header Proto> */
  Rule_CFuncProto_static_function5,

  /* 58. <CFunc Proto> ::= pure static <Visibility> function <Fn Header Proto> */
  Rule_CFuncProto_pure_static_function2,

  /* 59. <CFunc Proto> ::= pure <Visibility> static function <Fn Header Proto> */
  Rule_CFuncProto_pure_static_function3,

  /* 60. <CFunc Proto> ::= pure <Visibility> <Inherited> function <Fn Header Proto> */
  Rule_CFuncProto_pure_function6,

  /* 61. <CFunc Proto> ::= pure <Inherited> <Visibility> function <Fn Header Proto> */
  Rule_CFuncProto_pure_function7,

  /* 62. <CFunc Proto> ::= static pure <Visibility> function <Fn Header Proto> */
  Rule_CFuncProto_static_pure_function2,

  /* 63. <CFunc Proto> ::= static <Visibility> pure function <Fn Header Proto> */
  Rule_CFuncProto_static_pure_function3,

  /* 64. <CFunc Proto> ::= static <Visibility> <Inherited> function <Fn Header Proto> */
  Rule_CFuncProto_static_function6,

  /* 65. <CFunc Proto> ::= static <Inherited> <Visibility> function <Fn Header Proto> */
  Rule_CFuncProto_static_function7,

  /* 66. <CFunc Proto> ::= <Inherited> <Visibility> pure function <Fn Header Proto> */
  Rule_CFuncProto_pure_function8,

  /* 67. <CFunc Proto> ::= <Inherited> pure <Visibility> function <Fn Header Proto> */
  Rule_CFuncProto_pure_function9,

  /* 68. <CFunc Proto> ::= <Inherited> pure static function <Fn Header Proto> */
  Rule_CFuncProto_pure_static_function4,

  /* 69. <CFunc Decl> ::= <CFunc Proto> <Func Body> */
  Rule_CFuncDecl,

  /* 70. <CDefFunc Decl> ::= extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_extern_function,

  /* 71. <CDefFunc Decl> ::= extern pure function <Fn Header Proto> */
  Rule_CDefFuncDecl_extern_pure_function,

  /* 72. <CDefFunc Decl> ::= extern local function <Fn Header Proto> */
  Rule_CDefFuncDecl_extern_local_function,

  /* 73. <CDefFunc Decl> ::= local extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_local_extern_function,

  /* 74. <CDefFunc Decl> ::= local pure extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_local_pure_extern_function,

  /* 75. <CDefFunc Decl> ::= local extern pure function <Fn Header Proto> */
  Rule_CDefFuncDecl_local_extern_pure_function,

  /* 76. <CDefFunc Decl> ::= pure extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_pure_extern_function,

  /* 77. <CDefFunc Decl> ::= pure local extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_pure_local_extern_function,

  /* 78. <CDefFunc Decl> ::= pure extern local function <Fn Header Proto> */
  Rule_CDefFuncDecl_pure_extern_local_function,

  /* 79. <Visibility> ::= public */
  Rule_Visibility_public,

  /* 80. <Visibility> ::= private */
  Rule_Visibility_private,

  /* 81. <Visibility> ::= protected */
  Rule_Visibility_protected,

  /* 82. <Inherited> ::= inherited '(' <Pkg List> ')' */
  Rule_Inherited_inherited_LParen_RParen,

  /* 83. <Inherited> ::= inherited */
  Rule_Inherited_inherited,

  /* 84. <Params> ::= <Param> ',' <Params> */
  Rule_Params_Comma,

  /* 85. <Params> ::= <Param> */
  Rule_Params,

  /* 86. <Param> ::= final Id ':' <Type> */
  Rule_Param_final_Id_Colon,

  /* 87. <Param> ::= Id ':' <Type> */
  Rule_Param_Id_Colon,

  /* 88. <Types> ::= <Type> ',' <Types> */
  Rule_Types_Comma,

  /* 89. <Types> ::= <Type> */
  Rule_Types,

  /* 90. <Id List> ::= Id ',' <Id List> */
  Rule_IdList_Id_Comma,

  /* 91. <Id List> ::= Id */
  Rule_IdList_Id,

  /* 92. <Class Decl> ::= <Normal Class> */
  Rule_ClassDecl,

  /* 93. <Class Decl> ::= <Abstract Class> */
  Rule_ClassDecl2,

  /* 94. <Class Decl> ::= local <Normal Class> */
  Rule_ClassDecl_local,

  /* 95. <Class Decl> ::= local <Abstract Class> */
  Rule_ClassDecl_local2,

  /* 96. <Normal Class> ::= class <Class Name> '{' <CDecls> '}' */
  Rule_NormalClass_class_LBrace_RBrace,

  /* 97. <Normal Class> ::= class <Class Name> extends <Extend Class Name List> '{' <CDecls> '}' */
  Rule_NormalClass_class_extends_LBrace_RBrace,

  /* 98. <Abstract Class> ::= abstract class <Class Name> '{' <ACDecls> '}' */
  Rule_AbstractClass_abstract_class_LBrace_RBrace,

  /* 99. <Abstract Class> ::= abstract class <Class Name> extends <Extend Class Name List> '{' <ACDecls> '}' */
  Rule_AbstractClass_abstract_class_extends_LBrace_RBrace,

  /* 100. <Class Name> ::= Id */
  Rule_ClassName_Id,

  /* 101. <Class Name> ::= Id '<' <Id List> '>' */
  Rule_ClassName_Id_Lt_Gt,

  /* 102. <Extend Class Name List> ::= <Extend Class Name> ',' <Extend Class Name List> */
  Rule_ExtendClassNameList_Comma,

  /* 103. <Extend Class Name List> ::= <Extend Class Name> */
  Rule_ExtendClassNameList,

  /* 104. <Extend Class Name> ::= <Pkg> */
  Rule_ExtendClassName,

  /* 105. <Extend Class Name> ::= <Pkg> '<' <Extend Class Name List> '>' */
  Rule_ExtendClassName_Lt_Gt,

  /* 106. <CDecls> ::= <CDecl> <CDecls> */
  Rule_CDecls,

  /* 107. <CDecls> ::=  */
  Rule_CDecls2,

  /* 108. <ACDecls> ::= <ACDecl> <ACDecls> */
  Rule_ACDecls,

  /* 109. <ACDecls> ::=  */
  Rule_ACDecls2,

  /* 110. <CDecl> ::= <CFunc Decl> */
  Rule_CDecl,

  /* 111. <CDecl> ::= <CVar Decl> */
  Rule_CDecl2,

  /* 112. <CDecl> ::= <Operator Impl> */
  Rule_CDecl3,

  /* 113. <ACDecl> ::= <CFunc Decl> */
  Rule_ACDecl,

  /* 114. <ACDecl> ::= <CFunc Proto> */
  Rule_ACDecl2,

  /* 115. <ACDecl> ::= <CVar Decl> */
  Rule_ACDecl3,

  /* 116. <ACDecl> ::= <Operator Impl> */
  Rule_ACDecl4,

  /* 117. <ACDecl> ::= <Operator Proto> */
  Rule_ACDecl5,

  /* 118. <Operator Impl> ::= operator <Operator> <Op Header Impl> '=' <Expr> */
  Rule_OperatorImpl_operator_Eq,

  /* 119. <Operator Impl> ::= operator <Operator> <Op Header Impl> <Block> */
  Rule_OperatorImpl_operator,

  /* 120. <Operator Proto> ::= operator <Operator> <Op Header Proto> */
  Rule_OperatorProto_operator,

  /* 121. <CDefStruct> ::= extern struct Id '{' <Params> '}' */
  Rule_CDefStruct_extern_struct_Id_LBrace_RBrace,

  /* 122. <Operator> ::= '+' */
  Rule_Operator_Plus,

  /* 123. <Operator> ::= '-' */
  Rule_Operator_Minus,

  /* 124. <Operator> ::= '*' */
  Rule_Operator_Times,

  /* 125. <Operator> ::= '/' */
  Rule_Operator_Div,

  /* 126. <Operator> ::= '%' */
  Rule_Operator_Percent,

  /* 127. <Operator> ::= '^' */
  Rule_Operator_Caret,

  /* 128. <Operator> ::= '&' */
  Rule_Operator_Amp,

  /* 129. <Operator> ::= '|' */
  Rule_Operator_Pipe,

  /* 130. <Operator> ::= '~' */
  Rule_Operator_Tilde,

  /* 131. <Operator> ::= '!' */
  Rule_Operator_Exclam,

  /* 132. <Operator> ::= '=' */
  Rule_Operator_Eq,

  /* 133. <Operator> ::= '<' */
  Rule_Operator_Lt,

  /* 134. <Operator> ::= '>' */
  Rule_Operator_Gt,

  /* 135. <Operator> ::= '+=' */
  Rule_Operator_PlusEq,

  /* 136. <Operator> ::= '-=' */
  Rule_Operator_MinusEq,

  /* 137. <Operator> ::= '*=' */
  Rule_Operator_TimesEq,

  /* 138. <Operator> ::= '/=' */
  Rule_Operator_DivEq,

  /* 139. <Operator> ::= '%=' */
  Rule_Operator_PercentEq,

  /* 140. <Operator> ::= '^=' */
  Rule_Operator_CaretEq,

  /* 141. <Operator> ::= '&=' */
  Rule_Operator_AmpEq,

  /* 142. <Operator> ::= '|=' */
  Rule_Operator_PipeEq,

  /* 143. <Operator> ::= '<<' */
  Rule_Operator_LtLt,

  /* 144. <Operator> ::= '>>' */
  Rule_Operator_GtGt,

  /* 145. <Operator> ::= '>>=' */
  Rule_Operator_GtGtEq,

  /* 146. <Operator> ::= '<<=' */
  Rule_Operator_LtLtEq,

  /* 147. <Operator> ::= '==' */
  Rule_Operator_EqEq,

  /* 148. <Operator> ::= '!=' */
  Rule_Operator_ExclamEq,

  /* 149. <Operator> ::= '<=' */
  Rule_Operator_LtEq,

  /* 150. <Operator> ::= '>=' */
  Rule_Operator_GtEq,

  /* 151. <Operator> ::= '&&' */
  Rule_Operator_AmpAmp,

  /* 152. <Operator> ::= '||' */
  Rule_Operator_PipePipe,

  /* 153. <Operator> ::= '++' */
  Rule_Operator_PlusPlus,

  /* 154. <Operator> ::= '--' */
  Rule_Operator_MinusMinus,

  /* 155. <Operator> ::= ',' */
  Rule_Operator_Comma,

  /* 156. <Operator> ::= '(' ')' */
  Rule_Operator_LParen_RParen,

  /* 157. <Operator> ::= '[' ']' */
  Rule_Operator_LBracket_RBracket,

  /* 158. <Op Header Proto> ::= '(' <Params> ')' */
  Rule_OpHeaderProto_LParen_RParen,

  /* 159. <Op Header Proto> ::= '(' <Params> ')' '->' <Type> */
  Rule_OpHeaderProto_LParen_RParen_MinusGt,

  /* 160. <Op Header Proto> ::= '(' <Types> ')' */
  Rule_OpHeaderProto_LParen_RParen2,

  /* 161. <Op Header Proto> ::= '(' <Types> ')' '->' <Type> */
  Rule_OpHeaderProto_LParen_RParen_MinusGt2,

  /* 162. <Op Header Proto> ::= '(' ')' */
  Rule_OpHeaderProto_LParen_RParen3,

  /* 163. <Op Header Proto> ::= '(' ')' '->' <Type> */
  Rule_OpHeaderProto_LParen_RParen_MinusGt3,

  /* 164. <Op Header Impl> ::= '(' <Params> ')' */
  Rule_OpHeaderImpl_LParen_RParen,

  /* 165. <Op Header Impl> ::= '(' <Params> ')' '->' <Type> */
  Rule_OpHeaderImpl_LParen_RParen_MinusGt,

  /* 166. <Op Header Impl> ::= '(' ')' */
  Rule_OpHeaderImpl_LParen_RParen2,

  /* 167. <Op Header Impl> ::= '(' ')' '->' <Type> */
  Rule_OpHeaderImpl_LParen_RParen_MinusGt2,

  /* 168. <Var Decl> ::= let final <Var Header> */
  Rule_VarDecl_let_final,

  /* 169. <Var Decl> ::= let <Var Header> */
  Rule_VarDecl_let,

  /* 170. <Var Decl> ::= let local <Var Header> */
  Rule_VarDecl_let_local,

  /* 171. <Var Decl> ::= let local final <Var Header> */
  Rule_VarDecl_let_local_final,

  /* 172. <Var Decl> ::= let final local <Var Header> */
  Rule_VarDecl_let_final_local,

  /* 173. <Var Decl> ::= let atomic <Var Header> */
  Rule_VarDecl_let_atomic,

  /* 174. <Var Decl> ::= let local atomic <Var Header> */
  Rule_VarDecl_let_local_atomic,

  /* 175. <Var Decl> ::= let atomic local <Var Header> */
  Rule_VarDecl_let_atomic_local,

  /* 176. <CVar Decl> ::= let <Var Header> */
  Rule_CVarDecl_let,

  /* 177. <CVar Decl> ::= let final <Var Header> */
  Rule_CVarDecl_let_final,

  /* 178. <CVar Decl> ::= let final static <Var Header> */
  Rule_CVarDecl_let_final_static,

  /* 179. <CVar Decl> ::= let final <Visibility> <Var Header> */
  Rule_CVarDecl_let_final2,

  /* 180. <CVar Decl> ::= let final <Visibility> static <Var Header> */
  Rule_CVarDecl_let_final_static2,

  /* 181. <CVar Decl> ::= let final static <Visibility> <Var Header> */
  Rule_CVarDecl_let_final_static3,

  /* 182. <CVar Decl> ::= let static <Var Header> */
  Rule_CVarDecl_let_static,

  /* 183. <CVar Decl> ::= let static final <Var Header> */
  Rule_CVarDecl_let_static_final,

  /* 184. <CVar Decl> ::= let static atomic <Var Header> */
  Rule_CVarDecl_let_static_atomic,

  /* 185. <CVar Decl> ::= let static <Visibility> <Var Header> */
  Rule_CVarDecl_let_static2,

  /* 186. <CVar Decl> ::= let static <Visibility> atomic <Var Header> */
  Rule_CVarDecl_let_static_atomic2,

  /* 187. <CVar Decl> ::= let static <Visibility> final <Var Header> */
  Rule_CVarDecl_let_static_final2,

  /* 188. <CVar Decl> ::= let static atomic <Visibility> <Var Header> */
  Rule_CVarDecl_let_static_atomic3,

  /* 189. <CVar Decl> ::= let <Visibility> <Var Header> */
  Rule_CVarDecl_let2,

  /* 190. <CVar Decl> ::= let <Visibility> static <Var Header> */
  Rule_CVarDecl_let_static3,

  /* 191. <CVar Decl> ::= let <Visibility> static atomic <Var Header> */
  Rule_CVarDecl_let_static_atomic4,

  /* 192. <CVar Decl> ::= let <Visibility> final <Var Header> */
  Rule_CVarDecl_let_final3,

  /* 193. <CVar Decl> ::= let <Visibility> static final <Var Header> */
  Rule_CVarDecl_let_static_final3,

  /* 194. <CVar Decl> ::= let <Visibility> final static <Var Header> */
  Rule_CVarDecl_let_final_static4,

  /* 195. <CVar Decl> ::= let <Visibility> atomic static */
  Rule_CVarDecl_let_atomic_static,

  /* 196. <CVar Decl> ::= let atomic <Var Header> */
  Rule_CVarDecl_let_atomic,

  /* 197. <CVar Decl> ::= let atomic <Visibility> <Var Header> */
  Rule_CVarDecl_let_atomic2,

  /* 198. <CVar Decl> ::= let atomic static <Var Header> */
  Rule_CVarDecl_let_atomic_static2,

  /* 199. <CVar Decl> ::= let atomic <Visibility> static <Var Header> */
  Rule_CVarDecl_let_atomic_static3,

  /* 200. <CVar Decl> ::= let atomic static <Visibility> <Var Header> */
  Rule_CVarDecl_let_atomic_static4,

  /* 201. <Var Header> ::= <Id List> ':' <Type> '=' <CSE> */
  Rule_VarHeader_Colon_Eq,

  /* 202. <Var Header> ::= <Id List> ':' <Type> */
  Rule_VarHeader_Colon,

  /* 203. <Var Header> ::= <Id List> '=' <CSE> */
  Rule_VarHeader_Eq,

  /* 204. <Enum Decl> ::= enum Id '{' <Enum Def> '}' */
  Rule_EnumDecl_enum_Id_LBrace_RBrace,

  /* 205. <Enum Decl> ::= local enum Id '{' <Enum Def> '}' */
  Rule_EnumDecl_local_enum_Id_LBrace_RBrace,

  /* 206. <Enum Def> ::= Id ',' <Enum Def> */
  Rule_EnumDef_Id_Comma,

  /* 207. <Enum Def> ::= Id */
  Rule_EnumDef_Id,

  /* 208. <Type> ::= <Base> */
  Rule_Type,

  /* 209. <Type> ::= <Fn Type> */
  Rule_Type2,

  /* 210. <Type> ::= <Pkg Template> */
  Rule_Type3,

  /* 211. <Type> ::= <Type> '[' ']' */
  Rule_Type_LBracket_RBracket,

  /* 212. <Type> ::= '(' <Types> ')' */
  Rule_Type_LParen_RParen,

  /* 213. <Fn Type> ::= fn '(' ')' */
  Rule_FnType_fn_LParen_RParen,

  /* 214. <Fn Type> ::= fn '(' ')' '->' <Type> */
  Rule_FnType_fn_LParen_RParen_MinusGt,

  /* 215. <Fn Type> ::= fn '(' <Types> ')' */
  Rule_FnType_fn_LParen_RParen2,

  /* 216. <Fn Type> ::= fn '(' <Types> ')' '->' <Type> */
  Rule_FnType_fn_LParen_RParen_MinusGt2,

  /* 217. <Pkg Template> ::= <Pkg> */
  Rule_PkgTemplate,

  /* 218. <Pkg Template> ::= <Pkg> '<' <Types> '>' */
  Rule_PkgTemplate_Lt_Gt,

  /* 219. <Base> ::= <Sign> <Scalar> */
  Rule_Base,

  /* 220. <Base> ::= 'size_t' */
  Rule_Base_size_t,

  /* 221. <Base> ::= byte */
  Rule_Base_byte,

  /* 222. <Base> ::= float */
  Rule_Base_float,

  /* 223. <Base> ::= double */
  Rule_Base_double,

  /* 224. <Base> ::= bool */
  Rule_Base_bool,

  /* 225. <Base> ::= long double */
  Rule_Base_long_double,

  /* 226. <Sign> ::= signed */
  Rule_Sign_signed,

  /* 227. <Sign> ::= unsigned */
  Rule_Sign_unsigned,

  /* 228. <Sign> ::=  */
  Rule_Sign,

  /* 229. <Scalar> ::= char */
  Rule_Scalar_char,

  /* 230. <Scalar> ::= int */
  Rule_Scalar_int,

  /* 231. <Scalar> ::= short */
  Rule_Scalar_short,

  /* 232. <Scalar> ::= long */
  Rule_Scalar_long,

  /* 233. <Scalar> ::= short int */
  Rule_Scalar_short_int,

  /* 234. <Scalar> ::= long int */
  Rule_Scalar_long_int,

  /* 235. <Stm> ::= <Var Decl> */
  Rule_Stm,

  /* 236. <Stm> ::= <If Stm> */
  Rule_Stm2,

  /* 237. <Stm> ::= while <Expr> <Block> */
  Rule_Stm_while,

  /* 238. <Stm> ::= for <Arg> ';' <Arg> ';' <Arg> <Block> */
  Rule_Stm_for_Semi_Semi,

  /* 239. <Stm> ::= foreach <Param> in <Expr> <Block> */
  Rule_Stm_foreach_in,

  /* 240. <Stm> ::= <Normal Stm> */
  Rule_Stm3,

  /* 241. <Using Stm> ::= using <Pkg> */
  Rule_UsingStm_using,

  /* 242. <Using Stms> ::= <Using Stm> <Using Stms> */
  Rule_UsingStms,

  /* 243. <Using Stms> ::=  */
  Rule_UsingStms2,

  /* 244. <Pkg> ::= Id '.' <Pkg> */
  Rule_Pkg_Id_Dot,

  /* 245. <Pkg> ::= Id */
  Rule_Pkg_Id,

  /* 246. <Pkg List> ::= <Pkg> ',' <Pkg List> */
  Rule_PkgList_Comma,

  /* 247. <Pkg List> ::= <Pkg> */
  Rule_PkgList,

  /* 248. <If Stm> ::= if <Expr> <Block> <else-if> */
  Rule_IfStm_if,

  /* 249. <else-if> ::= else if <Expr> <Block> <else-if> */
  Rule_elseif_else_if,

  /* 250. <else-if> ::= else <Block> */
  Rule_elseif_else,

  /* 251. <else-if> ::=  */
  Rule_elseif,

  /* 252. <Normal Stm> ::= do <Block> while <Expr> */
  Rule_NormalStm_do_while,

  /* 253. <Normal Stm> ::= match <Expr> '{' <Case Stms> '}' */
  Rule_NormalStm_match_LBrace_RBrace,

  /* 254. <Normal Stm> ::= <Block> */
  Rule_NormalStm,

  /* 255. <Normal Stm> ::= <Expr> */
  Rule_NormalStm2,

  /* 256. <Normal Stm> ::= break */
  Rule_NormalStm_break,

  /* 257. <Normal Stm> ::= continue */
  Rule_NormalStm_continue,

  /* 258. <Normal Stm> ::= return <Expr> */
  Rule_NormalStm_return,

  /* 259. <Normal Stm> ::= return */
  Rule_NormalStm_return2,

  /* 260. <Normal Stm> ::= ';' */
  Rule_NormalStm_Semi,

  /* 261. <Arg> ::= <Expr> */
  Rule_Arg,

  /* 262. <Arg> ::=  */
  Rule_Arg2,

  /* 263. <Case Stms> ::= case <Expr> when <Expr> <Block> <Case Stms> */
  Rule_CaseStms_case_when,

  /* 264. <Case Stms> ::= case <Expr> <Block> <Case Stms> */
  Rule_CaseStms_case,

  /* 265. <Case Stms> ::= else <Block> */
  Rule_CaseStms_else,

  /* 266. <Block> ::= '{' <Using Stms> <Stm List> '}' */
  Rule_Block_LBrace_RBrace,

  /* 267. <Block> ::= synchronized '{' <Using Stms> <Stm List> '}' */
  Rule_Block_synchronized_LBrace_RBrace,

  /* 268. <Stm List> ::= <Stm> <Stm List> */
  Rule_StmList,

  /* 269. <Stm List> ::=  */
  Rule_StmList2,

  /* 270. <CSE> ::= <Expr> */
  Rule_CSE,

  /* 271. <CSE> ::= <CSE> ',' <Expr> */
  Rule_CSE_Comma,

  /* 272. <Expr> ::= <Var Decl> in <Expr> */
  Rule_Expr_in,

  /* 273. <Expr> ::= match <Expr> '{' <Case Exprs> '}' */
  Rule_Expr_match_LBrace_RBrace,

  /* 274. <Expr> ::= <Op Assign> */
  Rule_Expr,

  /* 275. <Op Assign> ::= <Op Or> '=' <Op Assign> */
  Rule_OpAssign_Eq,

  /* 276. <Op Assign> ::= <Op Or> '+=' <Op Assign> */
  Rule_OpAssign_PlusEq,

  /* 277. <Op Assign> ::= <Op Or> '-=' <Op Assign> */
  Rule_OpAssign_MinusEq,

  /* 278. <Op Assign> ::= <Op Or> '*=' <Op Assign> */
  Rule_OpAssign_TimesEq,

  /* 279. <Op Assign> ::= <Op Or> '/=' <Op Assign> */
  Rule_OpAssign_DivEq,

  /* 280. <Op Assign> ::= <Op Or> '%=' <Op Assign> */
  Rule_OpAssign_PercentEq,

  /* 281. <Op Assign> ::= <Op Or> '^=' <Op Assign> */
  Rule_OpAssign_CaretEq,

  /* 282. <Op Assign> ::= <Op Or> '&=' <Op Assign> */
  Rule_OpAssign_AmpEq,

  /* 283. <Op Assign> ::= <Op Or> '|=' <Op Assign> */
  Rule_OpAssign_PipeEq,

  /* 284. <Op Assign> ::= <Op Or> '>>=' <Op Assign> */
  Rule_OpAssign_GtGtEq,

  /* 285. <Op Assign> ::= <Op Or> '<<=' <Op Assign> */
  Rule_OpAssign_LtLtEq,

  /* 286. <Op Assign> ::= <Op Or> */
  Rule_OpAssign,

  /* 287. <Op Or> ::= <Op Or> '||' <Op And> */
  Rule_OpOr_PipePipe,

  /* 288. <Op Or> ::= <Op And> */
  Rule_OpOr,

  /* 289. <Op And> ::= <Op And> '&&' <Op BinOR> */
  Rule_OpAnd_AmpAmp,

  /* 290. <Op And> ::= <Op BinOR> */
  Rule_OpAnd,

  /* 291. <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> */
  Rule_OpBinOR_Pipe,

  /* 292. <Op BinOR> ::= <Op BinXOR> */
  Rule_OpBinOR,

  /* 293. <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> */
  Rule_OpBinXOR_Caret,

  /* 294. <Op BinXOR> ::= <Op BinAND> */
  Rule_OpBinXOR,

  /* 295. <Op BinAND> ::= <Op BinAND> '&' <Op Equate> */
  Rule_OpBinAND_Amp,

  /* 296. <Op BinAND> ::= <Op Equate> */
  Rule_OpBinAND,

  /* 297. <Op Equate> ::= <Op Equate> '==' <Op Compare> */
  Rule_OpEquate_EqEq,

  /* 298. <Op Equate> ::= <Op Equate> '!=' <Op Compare> */
  Rule_OpEquate_ExclamEq,

  /* 299. <Op Equate> ::= <Op Compare> */
  Rule_OpEquate,

  /* 300. <Op Compare> ::= <Op Compare> '<' <Op Shift> */
  Rule_OpCompare_Lt,

  /* 301. <Op Compare> ::= <Op Compare> '>' <Op Shift> */
  Rule_OpCompare_Gt,

  /* 302. <Op Compare> ::= <Op Compare> '<=' <Op Shift> */
  Rule_OpCompare_LtEq,

  /* 303. <Op Compare> ::= <Op Compare> '>=' <Op Shift> */
  Rule_OpCompare_GtEq,

  /* 304. <Op Compare> ::= <Op Compare> is <Type> */
  Rule_OpCompare_is,

  /* 305. <Op Compare> ::= <Op Shift> */
  Rule_OpCompare,

  /* 306. <Op Shift> ::= <Op Shift> '<<' <Op Add> */
  Rule_OpShift_LtLt,

  /* 307. <Op Shift> ::= <Op Shift> '>>' <Op Add> */
  Rule_OpShift_GtGt,

  /* 308. <Op Shift> ::= <Op Add> */
  Rule_OpShift,

  /* 309. <Op Add> ::= <Op Add> '+' <Op Mult> */
  Rule_OpAdd_Plus,

  /* 310. <Op Add> ::= <Op Add> '-' <Op Mult> */
  Rule_OpAdd_Minus,

  /* 311. <Op Add> ::= <Op Mult> */
  Rule_OpAdd,

  /* 312. <Op Mult> ::= <Op Mult> '*' <Op Unary> */
  Rule_OpMult_Times,

  /* 313. <Op Mult> ::= <Op Mult> '/' <Op Unary> */
  Rule_OpMult_Div,

  /* 314. <Op Mult> ::= <Op Mult> '%' <Op Unary> */
  Rule_OpMult_Percent,

  /* 315. <Op Mult> ::= <Op Unary> */
  Rule_OpMult,

  /* 316. <Op Unary> ::= '!' <Op Unary> */
  Rule_OpUnary_Exclam,

  /* 317. <Op Unary> ::= '~' <Op Unary> */
  Rule_OpUnary_Tilde,

  /* 318. <Op Unary> ::= '-' <Op Unary> */
  Rule_OpUnary_Minus,

  /* 319. <Op Unary> ::= '++' <Op Unary> */
  Rule_OpUnary_PlusPlus,

  /* 320. <Op Unary> ::= '--' <Op Unary> */
  Rule_OpUnary_MinusMinus,

  /* 321. <Op Unary> ::= <Op Pointer> '++' */
  Rule_OpUnary_PlusPlus2,

  /* 322. <Op Unary> ::= <Op Pointer> '--' */
  Rule_OpUnary_MinusMinus2,

  /* 323. <Op Unary> ::= <Op Unary> as <Type> */
  Rule_OpUnary_as,

  /* 324. <Op Unary> ::= <New Expr> */
  Rule_OpUnary,

  /* 325. <Op Unary> ::= delete <Op Pointer> */
  Rule_OpUnary_delete,

  /* 326. <Op Unary> ::= sizeof '(' <Type> ')' */
  Rule_OpUnary_sizeof_LParen_RParen,

  /* 327. <Op Unary> ::= <Op Pointer> */
  Rule_OpUnary2,

  /* 328. <Op Pointer> ::= <Op Pointer> '.' <Value> */
  Rule_OpPointer_Dot,

  /* 329. <Op Pointer> ::= <Op Pointer> '[' <CSE> ']' */
  Rule_OpPointer_LBracket_RBracket,

  /* 330. <Op Pointer> ::= <Op Pointer> '(' <CSE> ')' */
  Rule_OpPointer_LParen_RParen,

  /* 331. <Op Pointer> ::= <Op Pointer> '(' ')' */
  Rule_OpPointer_LParen_RParen2,

  /* 332. <Op Pointer> ::= <Value> */
  Rule_OpPointer,

  /* 333. <Value> ::= OctLiteral */
  Rule_Value_OctLiteral,

  /* 334. <Value> ::= HexLiteral */
  Rule_Value_HexLiteral,

  /* 335. <Value> ::= DecLiteral */
  Rule_Value_DecLiteral,

  /* 336. <Value> ::= BinLiteral */
  Rule_Value_BinLiteral,

  /* 337. <Value> ::= StringLiteral */
  Rule_Value_StringLiteral,

  /* 338. <Value> ::= CharLiteral */
  Rule_Value_CharLiteral,

  /* 339. <Value> ::= FloatLiteral */
  Rule_Value_FloatLiteral,

  /* 340. <Value> ::= null */
  Rule_Value_null,

  /* 341. <Value> ::= '_' */
  Rule_Value__,

  /* 342. <Value> ::= true */
  Rule_Value_true,

  /* 343. <Value> ::= false */
  Rule_Value_false,

  /* 344. <Value> ::= <Pkg> */
  Rule_Value,

  /* 345. <Value> ::= <Lambda Expr> */
  Rule_Value2,

  /* 346. <Value> ::= '(' <CSE> ')' */
  Rule_Value_LParen_RParen,

  /* 347. <Value> ::= '[' for Id ':' <Type> in <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Id_Colon_in_EqGt_RBracket,

  /* 348. <Value> ::= '[' for Id in <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Id_in_EqGt_RBracket,

  /* 349. <Value> ::= '[' for Id ':' <Type> in <Expr> if <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Id_Colon_in_if_EqGt_RBracket,

  /* 350. <Value> ::= '[' for Id in <Expr> if <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Id_in_if_EqGt_RBracket,

  /* 351. <Value> ::= '[' <CSE> ']' */
  Rule_Value_LBracket_RBracket,

  /* 352. <Lambda Expr> ::= lambda '(' <Params> ')' <Block> */
  Rule_LambdaExpr_lambda_LParen_RParen,

  /* 353. <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> */
  Rule_LambdaExpr_lambda_LParen_RParen_Eq,

  /* 354. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> */
  Rule_LambdaExpr_lambda_LParen_RParen_MinusGt,

  /* 355. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> */
  Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq,

  /* 356. <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> */
  Rule_CaseExprs_case_when_EqGt,

  /* 357. <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> */
  Rule_CaseExprs_case_EqGt,

  /* 358. <Case Exprs> ::= else '=>' <Expr> */
  Rule_CaseExprs_else_EqGt,

  /* 359. <New Expr> ::= new <Pkg Template> '(' ')' */
  Rule_NewExpr_new_LParen_RParen,

  /* 360. <New Expr> ::= new <Pkg Template> '(' <Expr> ')' */
  Rule_NewExpr_new_LParen_RParen2,

  /* 361. <New Expr> ::= new <Pkg Template> '(' ')' '{' <CDecl> '}' */
  Rule_NewExpr_new_LParen_RParen_LBrace_RBrace,

  /* 362. <New Expr> ::= new <Pkg Template> '(' <Expr> ')' '{' <CDecl> '}' */
  Rule_NewExpr_new_LParen_RParen_LBrace_RBrace2,

  /* 363. <New Expr> ::= new <Type> */
  Rule_NewExpr_new,

  /* 364. <New Expr> ::= new <Type> '[' <Expr> ']' */
  Rule_NewExpr_new_LBracket_RBracket
  };


ContextStruct* parseAst(struct TokenStruct *Token, ContextStruct *parent)
{
    RuleJumpTable[Token->ReductionRule](Token, parent);
    size_t i = 0;
      /*
    for(; i < parent->imports->size; i++)
    {
        ImportExpr* ie = getElement(parent->imports, i);
        char* path = calloc(ie->filePathSize+1, sizeof(char));
        wcstombs(path, ie->filePath, ie->filePathSize+1);


        if(!fileExists(path))
        {
            char* path2 = calloc(strlen(path)+strlen(getLibDir())+1, sizeof(char));
            strcat(path2, getLibDir());
            strcat(path2, path);

            if(fileExists(path2))
            {
                 report_Print("compiling %s", path2);
                 //compile(path2);
            }

        }
        else{
            report_Print("compiling %s", path);
            //compile(path);
        }

    }
*/
/*
    for (i = 0; i < parent->funcs->size; i++)
    {
        addElement(parentExpr->funcs, getElement(parent->funcs, i));
    }
    for (i = 0; i < parent->classes->size; i++)
    {
        addElement(parentExpr->classes, getElement(parent->classes, i));
    }
    for (i = 0; i < parent->enums->size; i++)
    {
        addElement(parentExpr->enums, getElement(parent->enums, i));
    }
    for (i = 0; i < parent->ctypes->size; i++)
    {
        addElement(parentExpr->ctypes, getElement(parent->ctypes, i));
    }
    for (i = 0; i < parent->vars->size; i++)
    {
        addElement(parentExpr->vars, getElement(parent->vars, i));
    }
    for (i = 0; i < parent->modules->size; i++)
    {
        addElement(parentExpr->modules, getElement(parent->modules, i));
    }
    for (i = 0; i < parent->cdefs->size; i++)
    {
        addElement(parentExpr->cdefs, getElement(parent->cdefs, i));
    }
    */

    return NULL;
}

#define space ShowIndent(n)

void dumpAST(ContextStruct *e, int n)
{
    /*
    ShowIndent(n);
    switch(e->type)
    {
      case ET_arrayExpr:
        space;printf("const array\n");
        dumpAST(e->arrayExpr->elements, n+1);
        break;
      case ET_asExpr:
        space;printf("BOP as\n");
        space;printf("Expr:\n");
    }*/
}
