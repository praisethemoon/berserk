
--[[

This file was generated by the "C - Kessels engine template.c" template.

]]

local table = table
local string = string
local io = io

-- <Decls> ::= <Imports> <Using Stms> <Decl List> 
function Rule_Decls(token, parent)
  parseExpr(1, token, parent)
  parseExpr(2, token, parent)
  parseExpr(3, token, parent)
end


-- <Decls> ::=  
function Rule_Decls2(token, parent)

end


-- <Decl List> ::= <Decl> <Decl List> 
function Rule_DeclList(token, parent)
  parseExpr(1, token, parent)
  parseExpr(2, token, parent)
end


-- <Decl List> ::= <Decl> 
function Rule_DeclList2(token, parent)
  parseExpr(1, token, parent)
end


-- <Decl> ::= <Func Decl> 
function Rule_Decl(token, parent)
  parseExpr(1, token, parent)
end


-- <Decl> ::= <Class Decl> 
function Rule_Decl2(token, parent)
  parseExpr(1, token, parent)
end


-- <Decl> ::= <Enum Decl> 
function Rule_Decl3(token, parent)
  parseExpr(1, token, parent)
end


-- <Decl> ::= <Var Decl> 
function Rule_Decl4(token, parent)
  parseExpr(1, token, parent)
end


-- <Decl> ::= <CDefFunc Decl> 
function Rule_Decl5(token, parent)
  parseExpr(1, token, parent)
end


-- <Imports> ::= <Import> <Imports> 
function Rule_Imports(token, parent)
  parseExpr(1, token, parent)
  parseExpr(2, token, parent)
end


-- <Imports> ::=  
function Rule_Imports2(token, parent)

end


-- <Import> ::= import <File Path All> 
function Rule_Import_import(token, parent)
  
  local pkg = {}

  parseExpr(2, token, pkg)

  table.insert(parent.imports, {type = "import", pkg = pkg})
  dumpImport(pkg)
 
end


-- <Import> ::= import <File Path> as Id 
function Rule_Import_import_as_Id(token, parent)
  local pkg = {}
  parseExpr(2, token, pkg)
  table.insert(parent.imports, { type = "importAs", pkg = pkg, as = token.tokens[4].data })
  dumpImport(pkg)
end


-- <Import> ::= from <File Path> import <File Path List> 
function Rule_Import_from_import(token, parent)
  local from = {}
  parseExpr(2, token, from)
  local imports = {}
  parseExpr(4, token, imports)

  local all = {}

  for _,v in ipairs(imports) do
    local t = {}

    for _, w in ipairs(from) do
      table.insert(t, w)
    end

    for _, w in ipairs(v) do
      table.insert(t, w)
    end

    table.insert(parent.imports, {type="import", pkg = t})
    dumpImport(t)

  end
end


-- <File Path> ::= Id '.' <File Path> 
function Rule_FilePath_Id_Dot(token, parent)
  table.insert(parent, token.tokens[1].data)
  parseExpr(3, token, parent)
end


-- <File Path> ::= Id 
function Rule_FilePath_Id(token, parent)
  table.insert(parent, token.tokens[1].data)
end


-- <File Path All> ::= Id '.' <File Path All> 
function Rule_FilePathAll_Id_Dot(token, parent)
  table.insert(parent, token.tokens[1].data)
  parseExpr(3, token, parent)
end


-- <File Path All> ::= Id '.*' 
function Rule_FilePathAll_Id_DotTimes(token, parent)
  table.insert(parent, token.tokens[1].data)
  table.insert(parent, '*')
end


-- <File Path All> ::= Id 
function Rule_FilePathAll_Id(token, parent)
  table.insert(parent, token.tokens[1].data)
end


-- <File Path List> ::= <File Path> ',' <File Path List> 
function Rule_FilePathList_Comma(token, parent)
  local pkg = {}
  parseExpr(1, token, pkg)
  table.insert(parent, pkg)
  parseExpr(3, token, parent)
end


-- <File Path List> ::= <File Path> 
function Rule_FilePathList(token, parent)
  local pkg = {}
  parseExpr(1, token, pkg)
  
  table.insert(parent, pkg)
end


-- <Fn Header Proto> ::= Id '(' <Params> ')' 
function Rule_FnHeaderProto_Id_LParen_RParen(token, parent)
  assert(parent.type == "FnHeaderProto")

  local params = {}
  parseExpr(3, token, params)

  parent.name = token.tokens[1].data
  parent.params = params
end


-- <Fn Header Proto> ::= Id '(' <Params> ')' '->' <Type> 
function Rule_FnHeaderProto_Id_LParen_RParen_MinusGt(token, parent)
  assert(parent.type == "FnHeaderProto")

  local params = {}
  parseExpr(3, token, params)
  
  local type = {}
  parseExpr(6, token, type)

  parent.name = token.tokens[1].data
  parent.params = params
  parent.returnType = type
end


-- <Fn Header Proto> ::= Id '(' <Types> ')' 
function Rule_FnHeaderProto_Id_LParen_RParen2(token, parent)
  assert(parent.type == "FnHeaderProto")

  local types = {}
  parseExpr(3, token, types)

  parent.name = token.tokens[1].data
  parent.types = params
end


-- <Fn Header Proto> ::= Id '(' <Types> ')' '->' <Type> 
function Rule_FnHeaderProto_Id_LParen_RParen_MinusGt2(token, parent)
  assert(parent.type == "FnHeaderProto")

  local types = {}
  parseExpr(3, token, types)
  
  local type = {}
  parseExpr(6, token, type)

  parent.name = token.tokens[1].data
  parent.types = types
  parent.returnType = type
end


-- <Fn Header Proto> ::= Id '(' ')' 
function Rule_FnHeaderProto_Id_LParen_RParen3(token, parent)
  assert(parent.type == "FnHeaderProto")
  
  parent.name = token.tokens[1].data
end


-- <Fn Header Proto> ::= Id '(' ')' '->' <Type> 
function Rule_FnHeaderProto_Id_LParen_RParen_MinusGt3(token, parent)
  assert(parent.type == "FnHeaderProto")

  local type = {}
  parseExpr(5, token, type)

  parent.name = token.tokens[1].data
  parent.returnType = type
end


-- <Fn Header Impl> ::= Id '(' <Params> ')' 
function Rule_FnHeaderImpl_Id_LParen_RParen(token, parent)
  assert(parent.type == "FnHeaderImpl")

  local params = {}
  parseExpr(3, token, params)
  

  parent.name = token.tokens[1].data
  parent.params = params
end


-- <Fn Header Impl> ::= Id '(' <Params> ')' '->' <Type> 
function Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt(token, parent)
  assert(parent.type == "FnHeaderImpl")

  local params = {}
  parseExpr(3, token, params)
  
  local type = {}
  parseExpr(6, token, type)

  parent.name = token.tokens[1].data
  parent.params = params
  parent.returnType = type
end


-- <Fn Header Impl> ::= Id '(' ')' 
function Rule_FnHeaderImpl_Id_LParen_RParen2(token, parent)
  assert(parent.type == "FnHeaderImpl")
  parent.name = token.tokens[1].data
end


-- <Fn Header Impl> ::= Id '(' ')' '->' <Type> 
function Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt2(token, parent)
  assert(parent.type == "FnHeaderImpl")

  local type = {}
  parseExpr(5, token, type)

  parent.name = token.tokens[1].data
  parent.returnType = type
end


-- <Func Decl> ::= function <Fn Header Impl> <Func Body> 
function Rule_FuncDecl_function(token, parent)
  assert(parent.type == "FuncDecl")

  local fnHeader = {type="FnHeaderImpl"}
  parseExpr(2, token, fnHeader)

  local fnBody = {type="FuncBody", parent=parent}
  parseExpr(3, token, fnBody)

  parent.header = fnHeader
  parent.body = fnBody
end


-- <Func Decl> ::= local function <Fn Header Impl> <Func Body> 
function Rule_FuncDecl_local_function(token, parent)
  assert(parent.type == "FuncDecl")

  local fnHeader = {type="FnHeaderImpl"}
  parseExpr(3, token, fnHeader)

  local fnBody = {type="FuncBody", parent=parent}
  parseExpr(4, token, fnBody)

  parent.header = fnHeader
  parent.body = fnBody
  parent.isLocal = true
end


-- <Func Decl> ::= synchronized function <Fn Header Impl> <Func Body> 
function Rule_FuncDecl_synchronized_function(token, parent)
  assert(parent.type == "FuncDecl")

  local fnHeader = {type="FnHeaderImpl"}
  parseExpr(3, token, fnHeader)

  local fnBody = {type="FuncBody", parent=parent}
  parseExpr(4, token, fnBody)

  parent.header = fnHeader
  parent.body = fnBody
  parent.isSync = true
end


-- <Func Decl> ::= synchronized local function <Fn Header Impl> <Func Body> 
function Rule_FuncDecl_synchronized_local_function(token, parent)
  assert(parent.type == "FuncDecl")

  local fnHeader = {type="FnHeaderImpl"}
  parseExpr(4, token, fnHeader)

  local fnBody = {type="FuncBody", parent=parent}
  parseExpr(5, token, fnBody)

  parent.header = fnHeader
  parent.body = fnBody
  parent.isLocal = true
  parent.isSync = true
end


-- <Func Decl> ::= local synchronized function <Fn Header Impl> <Func Body> 
function Rule_FuncDecl_local_synchronized_function(token, parent)
  -- same as
  Rule_FuncDecl_synchronized_local_function(token, parent)
end


-- <Func Decl> ::= pure function <Fn Header Impl> <Func Body> 
function Rule_FuncDecl_pure_function(token, parent)
  assert(parent.type == "FuncDecl")

  local fnHeader = {type="FnHeaderImpl"}
  parseExpr(3, token, fnHeader)

  local fnBody = {type="FuncBody", parent=parent}
  parseExpr(4, token, fnBody)

  parent.header = fnHeader
  parent.body = fnBody
  parent.isPure = true
end


-- <Func Decl> ::= local pure function <Fn Header Impl> <Func Body> 
function Rule_FuncDecl_local_pure_function(token, parent)
  assert(parent.type == "FuncDecl")

  local fnHeader = {type="FnHeaderImpl"}
  parseExpr(4, token, fnHeader)

  local fnBody = {type="FuncBody", parent=parent}
  parseExpr(5, token, fnBody)

  parent.header = fnHeader
  parent.body = fnBody
  parent.isLocal = true
  parent.isPure = true
end


-- <Func Decl> ::= pure local function <Fn Header Impl> <Func Body> 
function Rule_FuncDecl_pure_local_function(token, parent)
  -- same as 
  Rule_FuncDecl_local_pure_function(token, parent)
end


-- <Func Body> ::= '=' <Expr> 
function Rule_FuncBody_Eq(token, parent)
  assert(parent.type == "FuncBody")

  local expr = {type="expr"}
  parseExpr(2, token, expr)

  parent.expr = expr
end


-- <Func Body> ::= <Block> 
function Rule_FuncBody(token, parent)
  assert(parent.type == "FuncBody")

  local block = {type="block"}
  parseExpr(2, token, block)

  parent.block = block
end


-- <CFunc Proto> ::= function <Fn Header Proto> 
function Rule_CFuncProto_function(token, parent)
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(2, token, fnHeader)

  parent.header = fnHeader
end


-- <CFunc Proto> ::= pure function <Fn Header Proto> 
function Rule_CFuncProto_pure_function(token, parent)
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(3, token, fnHeader)

  parent.header = fnHeader
  parent.isPure = true
end


-- <CFunc Proto> ::= static function <Fn Header Proto> 
function Rule_CFuncProto_static_function(token, parent)
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(3, token, fnHeader)

  parent.header = fnHeader
  parent.isStatic = true
end


-- <CFunc Proto> ::= <Visibility> function <Fn Header Proto> 
function Rule_CFuncProto_function2(token, parent)  
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(3, token, fnHeader)

  parseExpr(1, token, parent)

  parent.header = fnHeader
end


-- <CFunc Proto> ::= <Inherited> function <Fn Header Proto> 
function Rule_CFuncProto_function3(token, parent)
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(3, token, fnHeader)

  parseExpr(1, token, parent)
  
  parent.header = fnHeader
end


-- <CFunc Proto> ::= pure static function <Fn Header Proto> 
function Rule_CFuncProto_pure_static_function(token, parent)
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(4, token, fnHeader)

  parent.header = fnHeader
  parent.isStatic = true
  parent.isPure = true
end


-- <CFunc Proto> ::= pure <Visibility> function <Fn Header Proto> 
function Rule_CFuncProto_pure_function2(token, parent)
  
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(4, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true}
  parseExpr(2, token, cfuncProto)

  parent.header = fnHeader
  parent.isPure = true
end

--FIX This
-- <CFunc Proto> ::= pure <Inherited> function <Fn Header Proto> 
function Rule_CFuncProto_pure_function3(token, parent)
  
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(4, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isStatic=true}
  parseExpr(2, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= static pure function <Fn Header Proto> 
function Rule_CFuncProto_static_pure_function(token, parent)
  -- same as 
  Rule_CFuncProto_pure_static_function(token, parent)
end


-- <CFunc Proto> ::= static <Visibility> function <Fn Header Proto> 
function Rule_CFuncProto_static_function2(token, parent)
  
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(4, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isStatic=true}
  parseExpr(2, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= static <Inherited> function <Fn Header Proto> 
function Rule_CFuncProto_static_function3(token, parent)
  
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(4, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isStatic=true}
  parseExpr(2, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= <Visibility> pure function <Fn Header Proto> 
function Rule_CFuncProto_pure_function4(token, parent)
  
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(4, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true}
  parseExpr(1, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= <Visibility> static function <Fn Header Proto> 
function Rule_CFuncProto_static_function4(token, parent)
  
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(4, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isStatic=true}
  parseExpr(1, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= <Visibility> <Inherited> function <Fn Header Proto> 
function Rule_CFuncProto_function4(token, parent)
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(4, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true}
  parseExpr(1, token, cfuncProto)
  parseExpr(2, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= <Inherited> pure function <Fn Header Proto> 
function Rule_CFuncProto_pure_function5(token, parent)
  
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(4, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true}
  parseExpr(1, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= <Inherited> <Visibility> function <Fn Header Proto> 
function Rule_CFuncProto_function5(token, parent)
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(4, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true}
  parseExpr(1, token, cfuncProto)
  parseExpr(2, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= <Inherited> static function <Fn Header Proto> 
function Rule_CFuncProto_static_function5(token, parent)
  
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(4, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isStatic=true}
  parseExpr(1, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= pure static <Visibility> function <Fn Header Proto> 
function Rule_CFuncProto_pure_static_function2(token, parent)
  
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(5, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true, isStatic=true}
  parseExpr(3, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= pure <Visibility> static function <Fn Header Proto> 
function Rule_CFuncProto_pure_static_function3(token, parent)
  
  assert(parent.type == "CFuncProto")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(5, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true, isStatic=true}
  parseExpr(2, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= pure <Visibility> <Inherited> function <Fn Header Proto> 
function Rule_CFuncProto_pure_function6(token, parent)
  
  assert(parent.type == "class")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(5, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true}
  parseExpr(2, token, cfuncProto)
  parseExpr(3, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= pure <Inherited> <Visibility> function <Fn Header Proto> 
function Rule_CFuncProto_pure_function6(token, parent)
  --same as
  Rule_CFuncProto_pure_function7
end


-- <CFunc Proto> ::= static pure <Visibility> function <Fn Header Proto> 
function Rule_CFuncProto_static_pure_function2(token, parent)
  
  assert(parent.type == "class")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(5, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true, isStatic=true}
  parseExpr(3, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= static <Visibility> pure function <Fn Header Proto> 
function Rule_CFuncProto_static_pure_function3(token, parent)
  
  assert(parent.type == "class")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(5, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true, isStatic=true}
  parseExpr(2, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= static <Visibility> <Inherited> function <Fn Header Proto> 
function Rule_CFuncProto_static_function6(token, parent)
  
  assert(parent.type == "class")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(5, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isStatic=true}
  parseExpr(2, token, cfuncProto)
  parseExpr(3, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= static <Inherited> <Visibility> function <Fn Header Proto> 
function Rule_CFuncProto_static_function7(token, parent)
  
  assert(parent.type == "class")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(5, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isStatic=true}
  parseExpr(2, token, cfuncProto)
  parseExpr(3, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= <Inherited> <Visibility> pure function <Fn Header Proto> 
function Rule_CFuncProto_pure_function8(token, parent)
  
  assert(parent.type == "class")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(5, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true}
  parseExpr(1, token, cfuncProto)
  parseExpr(2, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= <Inherited> pure <Visibility> function <Fn Header Proto> 
function Rule_CFuncProto_pure_function9(token, parent)
  
  assert(parent.type == "class")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(5, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isPure=true}
  parseExpr(1, token, cfuncProto)
  parseExpr(3, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Proto> ::= <Inherited> pure static function <Fn Header Proto> 
function Rule_CFuncProto_pure_static_function4(token, parent)
  
  assert(parent.type == "class")

  local fnHeader = {type="FnHeaderProto"}
  parseExpr(5, token, fnHeader)

  local cfuncProto = {type="CFuncProto", header=fnHeader, isStatic=true, isPure=true}
  parseExpr(1, token, cfuncProto)

  table.insert(parent.prototypes, cfuncProto)
end


-- <CFunc Decl> ::= <CFunc Proto> <Func Body> 
function Rule_CFuncDecl(token, parent)
    parseExpr(1, token, parent)
    
    local proto = 

    local expr = {type="FuncBody", parent=}
    parseExpr(2, token, parent)
end


-- <CDefFunc Decl> ::= extern function <Fn Header Proto> 
function Rule_CDefFuncDecl_extern_function(token, parent)
  -- TODO: Rule_CDefFuncDecl_extern_function
end


-- <CDefFunc Decl> ::= extern pure function <Fn Header Proto> 
function Rule_CDefFuncDecl_extern_pure_function(token, parent)
  -- TODO: Rule_CDefFuncDecl_extern_pure_function
end


-- <CDefFunc Decl> ::= extern local function <Fn Header Proto> 
function Rule_CDefFuncDecl_extern_local_function(token, parent)
  -- TODO: Rule_CDefFuncDecl_extern_local_function
end


-- <CDefFunc Decl> ::= local extern function <Fn Header Proto> 
function Rule_CDefFuncDecl_local_extern_function(token, parent)
  -- TODO: Rule_CDefFuncDecl_local_extern_function
end


-- <CDefFunc Decl> ::= local pure extern function <Fn Header Proto> 
function Rule_CDefFuncDecl_local_pure_extern_function(token, parent)
  -- TODO: Rule_CDefFuncDecl_local_pure_extern_function
end


-- <CDefFunc Decl> ::= local extern pure function <Fn Header Proto> 
function Rule_CDefFuncDecl_local_extern_pure_function(token, parent)
  -- TODO: Rule_CDefFuncDecl_local_extern_pure_function
end


-- <CDefFunc Decl> ::= pure extern function <Fn Header Proto> 
function Rule_CDefFuncDecl_pure_extern_function(token, parent)
  -- TODO: Rule_CDefFuncDecl_pure_extern_function
end


-- <CDefFunc Decl> ::= pure local extern function <Fn Header Proto> 
function Rule_CDefFuncDecl_pure_local_extern_function(token, parent)
  -- TODO: Rule_CDefFuncDecl_pure_local_extern_function
end


-- <CDefFunc Decl> ::= pure extern local function <Fn Header Proto> 
function Rule_CDefFuncDecl_pure_extern_local_function(token, parent)
  -- TODO: Rule_CDefFuncDecl_pure_extern_local_function
end


-- <Visibility> ::= public 
function Rule_Visibility_public(token, parent)
  -- TODO: Rule_Visibility_public
end


-- <Visibility> ::= private 
function Rule_Visibility_private(token, parent)
  -- TODO: Rule_Visibility_private
end


-- <Visibility> ::= protected 
function Rule_Visibility_protected(token, parent)
  -- TODO: Rule_Visibility_protected
end


-- <Inherited> ::= inherited '(' <Pkg List> ')' 
function Rule_Inherited_inherited_LParen_RParen(token, parent)
  -- TODO: Rule_Inherited_inherited_LParen_RParen
end


-- <Inherited> ::= inherited 
function Rule_Inherited_inherited(token, parent)
  -- TODO: Rule_Inherited_inherited
end


-- <Params> ::= <Param> ',' <Params> 
function Rule_Params_Comma(token, parent)
  -- TODO: Rule_Params_Comma
end


-- <Params> ::= <Param> 
function Rule_Params(token, parent)
  -- TODO: Rule_Params
end


-- <Param> ::= final Id ':' <Type> 
function Rule_Param_final_Id_Colon(token, parent)
  -- TODO: Rule_Param_final_Id_Colon
end


-- <Param> ::= Id ':' <Type> 
function Rule_Param_Id_Colon(token, parent)
  -- TODO: Rule_Param_Id_Colon
end


-- <Types> ::= <Type> ',' <Types> 
function Rule_Types_Comma(token, parent)
  -- TODO: Rule_Types_Comma
end


-- <Types> ::= <Type> 
function Rule_Types(token, parent)
  -- TODO: Rule_Types
end


-- <Id List> ::= Id ',' <Id List> 
function Rule_IdList_Id_Comma(token, parent)
  -- TODO: Rule_IdList_Id_Comma
end


-- <Id List> ::= Id 
function Rule_IdList_Id(token, parent)
  -- TODO: Rule_IdList_Id
end


-- <Class Decl> ::= <Normal Class> 
function Rule_ClassDecl(token, parent)
  -- TODO: Rule_ClassDecl
end


-- <Class Decl> ::= <Abstract Class> 
function Rule_ClassDecl2(token, parent)
  -- TODO: Rule_ClassDecl2
end


-- <Class Decl> ::= local <Normal Class> 
function Rule_ClassDecl_local(token, parent)
  -- TODO: Rule_ClassDecl_local
end


-- <Class Decl> ::= local <Abstract Class> 
function Rule_ClassDecl_local2(token, parent)
  -- TODO: Rule_ClassDecl_local2
end


-- <Normal Class> ::= class <Class Name> '{' <CDecls> '}' 
function Rule_NormalClass_class_LBrace_RBrace(token, parent)
  -- TODO: Rule_NormalClass_class_LBrace_RBrace
end


-- <Normal Class> ::= class <Class Name> extends <Extend Class Name List> '{' <CDecls> '}' 
function Rule_NormalClass_class_extends_LBrace_RBrace(token, parent)
  -- TODO: Rule_NormalClass_class_extends_LBrace_RBrace
end


-- <Abstract Class> ::= abstract class <Class Name> '{' <ACDecls> '}' 
function Rule_AbstractClass_abstract_class_LBrace_RBrace(token, parent)
  -- TODO: Rule_AbstractClass_abstract_class_LBrace_RBrace
end


-- <Abstract Class> ::= abstract class <Class Name> extends <Extend Class Name List> '{' <ACDecls> '}' 
function Rule_AbstractClass_abstract_class_extends_LBrace_RBrace(token, parent)
  -- TODO: Rule_AbstractClass_abstract_class_extends_LBrace_RBrace
end


-- <Class Name> ::= Id 
function Rule_ClassName_Id(token, parent)
  -- TODO: Rule_ClassName_Id
end


-- <Class Name> ::= Id '<' <Id List> '>' 
function Rule_ClassName_Id_Lt_Gt(token, parent)
  -- TODO: Rule_ClassName_Id_Lt_Gt
end


-- <Extend Class Name List> ::= <Extend Class Name> ',' <Extend Class Name List> 
function Rule_ExtendClassNameList_Comma(token, parent)
  -- TODO: Rule_ExtendClassNameList_Comma
end


-- <Extend Class Name List> ::= <Extend Class Name> 
function Rule_ExtendClassNameList(token, parent)
  -- TODO: Rule_ExtendClassNameList
end


-- <Extend Class Name> ::= <Pkg> 
function Rule_ExtendClassName(token, parent)
  -- TODO: Rule_ExtendClassName
end


-- <Extend Class Name> ::= <Pkg> '<' <Extend Class Name List> '>' 
function Rule_ExtendClassName_Lt_Gt(token, parent)
  -- TODO: Rule_ExtendClassName_Lt_Gt
end


-- <CDecls> ::= <CDecl> <CDecls> 
function Rule_CDecls(token, parent)
  -- TODO: Rule_CDecls
end


-- <CDecls> ::=  
function Rule_CDecls2(token, parent)
  -- TODO: Rule_CDecls2
end


-- <ACDecls> ::= <ACDecl> <ACDecls> 
function Rule_ACDecls(token, parent)
  -- TODO: Rule_ACDecls
end


-- <ACDecls> ::=  
function Rule_ACDecls2(token, parent)
  -- TODO: Rule_ACDecls2
end


-- <CDecl> ::= <CFunc Decl> 
function Rule_CDecl(token, parent)
  -- TODO: Rule_CDecl
end


-- <CDecl> ::= <CVar Decl> 
function Rule_CDecl2(token, parent)
  -- TODO: Rule_CDecl2
end


-- <CDecl> ::= <Operator Impl> 
function Rule_CDecl3(token, parent)
  -- TODO: Rule_CDecl3
end


-- <ACDecl> ::= <CFunc Decl> 
function Rule_ACDecl(token, parent)
  -- TODO: Rule_ACDecl
end


-- <ACDecl> ::= <CFunc Proto> 
function Rule_ACDecl2(token, parent)
  -- TODO: Rule_ACDecl2
end


-- <ACDecl> ::= <CVar Decl> 
function Rule_ACDecl3(token, parent)
  -- TODO: Rule_ACDecl3
end


-- <ACDecl> ::= <Operator Impl> 
function Rule_ACDecl4(token, parent)
  -- TODO: Rule_ACDecl4
end


-- <ACDecl> ::= <Operator Proto> 
function Rule_ACDecl5(token, parent)
  -- TODO: Rule_ACDecl5
end


-- <Operator Impl> ::= operator <Operator> <Op Header Impl> '=' <Expr> 
function Rule_OperatorImpl_operator_Eq(token, parent)
  -- TODO: Rule_OperatorImpl_operator_Eq
end


-- <Operator Impl> ::= operator <Operator> <Op Header Impl> <Block> 
function Rule_OperatorImpl_operator(token, parent)
  -- TODO: Rule_OperatorImpl_operator
end


-- <Operator Proto> ::= operator <Operator> <Op Header Proto> 
function Rule_OperatorProto_operator(token, parent)
  -- TODO: Rule_OperatorProto_operator
end


-- <CDefStruct> ::= extern struct Id '{' <Params> '}' 
function Rule_CDefStruct_extern_struct_Id_LBrace_RBrace(token, parent)
  -- TODO: Rule_CDefStruct_extern_struct_Id_LBrace_RBrace
end


-- <Operator> ::= '+' 
function Rule_Operator_Plus(token, parent)
  -- TODO: Rule_Operator_Plus
end


-- <Operator> ::= '-' 
function Rule_Operator_Minus(token, parent)
  -- TODO: Rule_Operator_Minus
end


-- <Operator> ::= '*' 
function Rule_Operator_Times(token, parent)
  -- TODO: Rule_Operator_Times
end


-- <Operator> ::= '/' 
function Rule_Operator_Div(token, parent)
  -- TODO: Rule_Operator_Div
end


-- <Operator> ::= '%' 
function Rule_Operator_Percent(token, parent)
  -- TODO: Rule_Operator_Percent
end


-- <Operator> ::= '^' 
function Rule_Operator_Caret(token, parent)
  -- TODO: Rule_Operator_Caret
end


-- <Operator> ::= '&' 
function Rule_Operator_Amp(token, parent)
  -- TODO: Rule_Operator_Amp
end


-- <Operator> ::= '|' 
function Rule_Operator_Pipe(token, parent)
  -- TODO: Rule_Operator_Pipe
end


-- <Operator> ::= '~' 
function Rule_Operator_Tilde(token, parent)
  -- TODO: Rule_Operator_Tilde
end


-- <Operator> ::= '!' 
function Rule_Operator_Exclam(token, parent)
  -- TODO: Rule_Operator_Exclam
end


-- <Operator> ::= '=' 
function Rule_Operator_Eq(token, parent)
  -- TODO: Rule_Operator_Eq
end


-- <Operator> ::= '<' 
function Rule_Operator_Lt(token, parent)
  -- TODO: Rule_Operator_Lt
end


-- <Operator> ::= '>' 
function Rule_Operator_Gt(token, parent)
  -- TODO: Rule_Operator_Gt
end


-- <Operator> ::= '+=' 
function Rule_Operator_PlusEq(token, parent)
  -- TODO: Rule_Operator_PlusEq
end


-- <Operator> ::= '-=' 
function Rule_Operator_MinusEq(token, parent)
  -- TODO: Rule_Operator_MinusEq
end


-- <Operator> ::= '*=' 
function Rule_Operator_TimesEq(token, parent)
  -- TODO: Rule_Operator_TimesEq
end


-- <Operator> ::= '/=' 
function Rule_Operator_DivEq(token, parent)
  -- TODO: Rule_Operator_DivEq
end


-- <Operator> ::= '%=' 
function Rule_Operator_PercentEq(token, parent)
  -- TODO: Rule_Operator_PercentEq
end


-- <Operator> ::= '^=' 
function Rule_Operator_CaretEq(token, parent)
  -- TODO: Rule_Operator_CaretEq
end


-- <Operator> ::= '&=' 
function Rule_Operator_AmpEq(token, parent)
  -- TODO: Rule_Operator_AmpEq
end


-- <Operator> ::= '|=' 
function Rule_Operator_PipeEq(token, parent)
  -- TODO: Rule_Operator_PipeEq
end


-- <Operator> ::= '<<' 
function Rule_Operator_LtLt(token, parent)
  -- TODO: Rule_Operator_LtLt
end


-- <Operator> ::= '>>' 
function Rule_Operator_GtGt(token, parent)
  -- TODO: Rule_Operator_GtGt
end


-- <Operator> ::= '>>=' 
function Rule_Operator_GtGtEq(token, parent)
  -- TODO: Rule_Operator_GtGtEq
end


-- <Operator> ::= '<<=' 
function Rule_Operator_LtLtEq(token, parent)
  -- TODO: Rule_Operator_LtLtEq
end


-- <Operator> ::= '==' 
function Rule_Operator_EqEq(token, parent)
  -- TODO: Rule_Operator_EqEq
end


-- <Operator> ::= '!=' 
function Rule_Operator_ExclamEq(token, parent)
  -- TODO: Rule_Operator_ExclamEq
end


-- <Operator> ::= '<=' 
function Rule_Operator_LtEq(token, parent)
  -- TODO: Rule_Operator_LtEq
end


-- <Operator> ::= '>=' 
function Rule_Operator_GtEq(token, parent)
  -- TODO: Rule_Operator_GtEq
end


-- <Operator> ::= '&&' 
function Rule_Operator_AmpAmp(token, parent)
  -- TODO: Rule_Operator_AmpAmp
end


-- <Operator> ::= '||' 
function Rule_Operator_PipePipe(token, parent)
  -- TODO: Rule_Operator_PipePipe
end


-- <Operator> ::= '++' 
function Rule_Operator_PlusPlus(token, parent)
  -- TODO: Rule_Operator_PlusPlus
end


-- <Operator> ::= '--' 
function Rule_Operator_MinusMinus(token, parent)
  -- TODO: Rule_Operator_MinusMinus
end


-- <Operator> ::= ',' 
function Rule_Operator_Comma(token, parent)
  -- TODO: Rule_Operator_Comma
end


-- <Operator> ::= '(' ')' 
function Rule_Operator_LParen_RParen(token, parent)
  -- TODO: Rule_Operator_LParen_RParen
end


-- <Operator> ::= '[' ']' 
function Rule_Operator_LBracket_RBracket(token, parent)
  -- TODO: Rule_Operator_LBracket_RBracket
end


-- <Op Header Proto> ::= '(' <Params> ')' 
function Rule_OpHeaderProto_LParen_RParen(token, parent)
  -- TODO: Rule_OpHeaderProto_LParen_RParen
end


-- <Op Header Proto> ::= '(' <Params> ')' '->' <Type> 
function Rule_OpHeaderProto_LParen_RParen_MinusGt(token, parent)
  -- TODO: Rule_OpHeaderProto_LParen_RParen_MinusGt
end


-- <Op Header Proto> ::= '(' <Types> ')' 
function Rule_OpHeaderProto_LParen_RParen2(token, parent)
  -- TODO: Rule_OpHeaderProto_LParen_RParen2
end


-- <Op Header Proto> ::= '(' <Types> ')' '->' <Type> 
function Rule_OpHeaderProto_LParen_RParen_MinusGt2(token, parent)
  -- TODO: Rule_OpHeaderProto_LParen_RParen_MinusGt2
end


-- <Op Header Proto> ::= '(' ')' 
function Rule_OpHeaderProto_LParen_RParen3(token, parent)
  -- TODO: Rule_OpHeaderProto_LParen_RParen3
end


-- <Op Header Proto> ::= '(' ')' '->' <Type> 
function Rule_OpHeaderProto_LParen_RParen_MinusGt3(token, parent)
  -- TODO: Rule_OpHeaderProto_LParen_RParen_MinusGt3
end


-- <Op Header Impl> ::= '(' <Params> ')' 
function Rule_OpHeaderImpl_LParen_RParen(token, parent)
  -- TODO: Rule_OpHeaderImpl_LParen_RParen
end


-- <Op Header Impl> ::= '(' <Params> ')' '->' <Type> 
function Rule_OpHeaderImpl_LParen_RParen_MinusGt(token, parent)
  -- TODO: Rule_OpHeaderImpl_LParen_RParen_MinusGt
end


-- <Op Header Impl> ::= '(' ')' 
function Rule_OpHeaderImpl_LParen_RParen2(token, parent)
  -- TODO: Rule_OpHeaderImpl_LParen_RParen2
end


-- <Op Header Impl> ::= '(' ')' '->' <Type> 
function Rule_OpHeaderImpl_LParen_RParen_MinusGt2(token, parent)
  -- TODO: Rule_OpHeaderImpl_LParen_RParen_MinusGt2
end


-- <Var Decl> ::= let final <Var Header> 
function Rule_VarDecl_let_final(token, parent)
  -- TODO: Rule_VarDecl_let_final
end


-- <Var Decl> ::= let <Var Header> 
function Rule_VarDecl_let(token, parent)
  -- TODO: Rule_VarDecl_let
end


-- <Var Decl> ::= let local <Var Header> 
function Rule_VarDecl_let_local(token, parent)
  -- TODO: Rule_VarDecl_let_local
end


-- <Var Decl> ::= let local final <Var Header> 
function Rule_VarDecl_let_local_final(token, parent)
  -- TODO: Rule_VarDecl_let_local_final
end


-- <Var Decl> ::= let final local <Var Header> 
function Rule_VarDecl_let_final_local(token, parent)
  -- TODO: Rule_VarDecl_let_final_local
end


-- <Var Decl> ::= let atomic <Var Header> 
function Rule_VarDecl_let_atomic(token, parent)
  -- TODO: Rule_VarDecl_let_atomic
end


-- <Var Decl> ::= let local atomic <Var Header> 
function Rule_VarDecl_let_local_atomic(token, parent)
  -- TODO: Rule_VarDecl_let_local_atomic
end


-- <Var Decl> ::= let atomic local <Var Header> 
function Rule_VarDecl_let_atomic_local(token, parent)
  -- TODO: Rule_VarDecl_let_atomic_local
end


-- <CVar Decl> ::= let <Var Header> 
function Rule_CVarDecl_let(token, parent)
  -- TODO: Rule_CVarDecl_let
end


-- <CVar Decl> ::= let final <Var Header> 
function Rule_CVarDecl_let_final(token, parent)
  -- TODO: Rule_CVarDecl_let_final
end


-- <CVar Decl> ::= let final static <Var Header> 
function Rule_CVarDecl_let_final_static(token, parent)
  -- TODO: Rule_CVarDecl_let_final_static
end


-- <CVar Decl> ::= let final <Visibility> <Var Header> 
function Rule_CVarDecl_let_final2(token, parent)
  -- TODO: Rule_CVarDecl_let_final2
end


-- <CVar Decl> ::= let final <Visibility> static <Var Header> 
function Rule_CVarDecl_let_final_static2(token, parent)
  -- TODO: Rule_CVarDecl_let_final_static2
end


-- <CVar Decl> ::= let final static <Visibility> <Var Header> 
function Rule_CVarDecl_let_final_static3(token, parent)
  -- TODO: Rule_CVarDecl_let_final_static3
end


-- <CVar Decl> ::= let static <Var Header> 
function Rule_CVarDecl_let_static(token, parent)
  -- TODO: Rule_CVarDecl_let_static
end


-- <CVar Decl> ::= let static final <Var Header> 
function Rule_CVarDecl_let_static_final(token, parent)
  -- TODO: Rule_CVarDecl_let_static_final
end


-- <CVar Decl> ::= let static atomic <Var Header> 
function Rule_CVarDecl_let_static_atomic(token, parent)
  -- TODO: Rule_CVarDecl_let_static_atomic
end


-- <CVar Decl> ::= let static <Visibility> <Var Header> 
function Rule_CVarDecl_let_static2(token, parent)
  -- TODO: Rule_CVarDecl_let_static2
end


-- <CVar Decl> ::= let static <Visibility> atomic <Var Header> 
function Rule_CVarDecl_let_static_atomic2(token, parent)
  -- TODO: Rule_CVarDecl_let_static_atomic2
end


-- <CVar Decl> ::= let static <Visibility> final <Var Header> 
function Rule_CVarDecl_let_static_final2(token, parent)
  -- TODO: Rule_CVarDecl_let_static_final2
end


-- <CVar Decl> ::= let static atomic <Visibility> <Var Header> 
function Rule_CVarDecl_let_static_atomic3(token, parent)
  -- TODO: Rule_CVarDecl_let_static_atomic3
end


-- <CVar Decl> ::= let <Visibility> <Var Header> 
function Rule_CVarDecl_let2(token, parent)
  -- TODO: Rule_CVarDecl_let2
end


-- <CVar Decl> ::= let <Visibility> static <Var Header> 
function Rule_CVarDecl_let_static3(token, parent)
  -- TODO: Rule_CVarDecl_let_static3
end


-- <CVar Decl> ::= let <Visibility> static atomic <Var Header> 
function Rule_CVarDecl_let_static_atomic4(token, parent)
  -- TODO: Rule_CVarDecl_let_static_atomic4
end


-- <CVar Decl> ::= let <Visibility> final <Var Header> 
function Rule_CVarDecl_let_final3(token, parent)
  -- TODO: Rule_CVarDecl_let_final3
end


-- <CVar Decl> ::= let <Visibility> static final <Var Header> 
function Rule_CVarDecl_let_static_final3(token, parent)
  -- TODO: Rule_CVarDecl_let_static_final3
end


-- <CVar Decl> ::= let <Visibility> final static <Var Header> 
function Rule_CVarDecl_let_final_static4(token, parent)
  -- TODO: Rule_CVarDecl_let_final_static4
end


-- <CVar Decl> ::= let <Visibility> atomic static 
function Rule_CVarDecl_let_atomic_static(token, parent)
  -- TODO: Rule_CVarDecl_let_atomic_static
end


-- <CVar Decl> ::= let atomic <Var Header> 
function Rule_CVarDecl_let_atomic(token, parent)
  -- TODO: Rule_CVarDecl_let_atomic
end


-- <CVar Decl> ::= let atomic <Visibility> <Var Header> 
function Rule_CVarDecl_let_atomic2(token, parent)
  -- TODO: Rule_CVarDecl_let_atomic2
end


-- <CVar Decl> ::= let atomic static <Var Header> 
function Rule_CVarDecl_let_atomic_static2(token, parent)
  -- TODO: Rule_CVarDecl_let_atomic_static2
end


-- <CVar Decl> ::= let atomic <Visibility> static <Var Header> 
function Rule_CVarDecl_let_atomic_static3(token, parent)
  -- TODO: Rule_CVarDecl_let_atomic_static3
end


-- <CVar Decl> ::= let atomic static <Visibility> <Var Header> 
function Rule_CVarDecl_let_atomic_static4(token, parent)
  -- TODO: Rule_CVarDecl_let_atomic_static4
end


-- <Var Header> ::= <Id List> ':' <Type> '=' <CSE> 
function Rule_VarHeader_Colon_Eq(token, parent)
  -- TODO: Rule_VarHeader_Colon_Eq
end


-- <Var Header> ::= <Id List> ':' <Type> 
function Rule_VarHeader_Colon(token, parent)
  -- TODO: Rule_VarHeader_Colon
end


-- <Var Header> ::= <Id List> '=' <CSE> 
function Rule_VarHeader_Eq(token, parent)
  -- TODO: Rule_VarHeader_Eq
end


-- <Enum Decl> ::= enum Id '{' <Enum Def> '}' 
function Rule_EnumDecl_enum_Id_LBrace_RBrace(token, parent)
  -- TODO: Rule_EnumDecl_enum_Id_LBrace_RBrace
end


-- <Enum Decl> ::= local enum Id '{' <Enum Def> '}' 
function Rule_EnumDecl_local_enum_Id_LBrace_RBrace(token, parent)
  -- TODO: Rule_EnumDecl_local_enum_Id_LBrace_RBrace
end


-- <Enum Def> ::= Id ',' <Enum Def> 
function Rule_EnumDef_Id_Comma(token, parent)
  -- TODO: Rule_EnumDef_Id_Comma
end


-- <Enum Def> ::= Id 
function Rule_EnumDef_Id(token, parent)
  -- TODO: Rule_EnumDef_Id
end


-- <Type> ::= <Base> 
function Rule_Type(token, parent)
  -- TODO: Rule_Type
end


-- <Type> ::= <Fn Type> 
function Rule_Type2(token, parent)
  -- TODO: Rule_Type2
end


-- <Type> ::= <Pkg Template> 
function Rule_Type3(token, parent)
  -- TODO: Rule_Type3
end


-- <Type> ::= <Type> '[' ']' 
function Rule_Type_LBracket_RBracket(token, parent)
  -- TODO: Rule_Type_LBracket_RBracket
end


-- <Type> ::= '(' <Types> ')' 
function Rule_Type_LParen_RParen(token, parent)
  -- TODO: Rule_Type_LParen_RParen
end


-- <Fn Type> ::= fn '(' ')' 
function Rule_FnType_fn_LParen_RParen(token, parent)
  -- TODO: Rule_FnType_fn_LParen_RParen
end


-- <Fn Type> ::= fn '(' ')' '->' <Type> 
function Rule_FnType_fn_LParen_RParen_MinusGt(token, parent)
  -- TODO: Rule_FnType_fn_LParen_RParen_MinusGt
end


-- <Fn Type> ::= fn '(' <Types> ')' 
function Rule_FnType_fn_LParen_RParen2(token, parent)
  -- TODO: Rule_FnType_fn_LParen_RParen2
end


-- <Fn Type> ::= fn '(' <Types> ')' '->' <Type> 
function Rule_FnType_fn_LParen_RParen_MinusGt2(token, parent)
  -- TODO: Rule_FnType_fn_LParen_RParen_MinusGt2
end


-- <Pkg Template> ::= <Pkg> 
function Rule_PkgTemplate(token, parent)
  -- TODO: Rule_PkgTemplate
end


-- <Pkg Template> ::= <Pkg> '<' <Types> '>' 
function Rule_PkgTemplate_Lt_Gt(token, parent)
  -- TODO: Rule_PkgTemplate_Lt_Gt
end


-- <Base> ::= <Sign> <Scalar> 
function Rule_Base(token, parent)
  -- TODO: Rule_Base
end


-- <Base> ::= 'size_t' 
function Rule_Base_size_t(token, parent)
  -- TODO: Rule_Base_size_t
end


-- <Base> ::= byte 
function Rule_Base_byte(token, parent)
  -- TODO: Rule_Base_byte
end


-- <Base> ::= float 
function Rule_Base_float(token, parent)
  -- TODO: Rule_Base_float
end


-- <Base> ::= double 
function Rule_Base_double(token, parent)
  -- TODO: Rule_Base_double
end


-- <Base> ::= bool 
function Rule_Base_bool(token, parent)
  -- TODO: Rule_Base_bool
end


-- <Base> ::= long double 
function Rule_Base_long_double(token, parent)
  -- TODO: Rule_Base_long_double
end


-- <Sign> ::= signed 
function Rule_Sign_signed(token, parent)
  -- TODO: Rule_Sign_signed
end


-- <Sign> ::= unsigned 
function Rule_Sign_unsigned(token, parent)
  -- TODO: Rule_Sign_unsigned
end


-- <Sign> ::=  
function Rule_Sign(token, parent)
  -- TODO: Rule_Sign
end


-- <Scalar> ::= char 
function Rule_Scalar_char(token, parent)
  -- TODO: Rule_Scalar_char
end


-- <Scalar> ::= int 
function Rule_Scalar_int(token, parent)
  -- TODO: Rule_Scalar_int
end


-- <Scalar> ::= short 
function Rule_Scalar_short(token, parent)
  -- TODO: Rule_Scalar_short
end


-- <Scalar> ::= long 
function Rule_Scalar_long(token, parent)
  -- TODO: Rule_Scalar_long
end


-- <Scalar> ::= short int 
function Rule_Scalar_short_int(token, parent)
  -- TODO: Rule_Scalar_short_int
end


-- <Scalar> ::= long int 
function Rule_Scalar_long_int(token, parent)
  -- TODO: Rule_Scalar_long_int
end


-- <Stm> ::= <Var Decl> 
function Rule_Stm(token, parent)
  -- TODO: Rule_Stm
end


-- <Stm> ::= <If Stm> 
function Rule_Stm2(token, parent)
  -- TODO: Rule_Stm2
end


-- <Stm> ::= while <Expr> <Block> 
function Rule_Stm_while(token, parent)
  -- TODO: Rule_Stm_while
end


-- <Stm> ::= for <Arg> ';' <Arg> ';' <Arg> <Block> 
function Rule_Stm_for_Semi_Semi(token, parent)
  -- TODO: Rule_Stm_for_Semi_Semi
end


-- <Stm> ::= foreach <Param> in <Expr> <Block> 
function Rule_Stm_foreach_in(token, parent)
  -- TODO: Rule_Stm_foreach_in
end


-- <Stm> ::= <Normal Stm> 
function Rule_Stm3(token, parent)
  -- TODO: Rule_Stm3
end


-- <Using Stm> ::= using <Pkg> 
function Rule_UsingStm_using(token, parent)
  -- TODO: Rule_UsingStm_using
end


-- <Using Stms> ::= <Using Stm> <Using Stms> 
function Rule_UsingStms(token, parent)
  -- TODO: Rule_UsingStms
end


-- <Using Stms> ::=  
function Rule_UsingStms2(token, parent)
  -- TODO: Rule_UsingStms2
end


-- <Pkg> ::= Id '.' <Pkg> 
function Rule_Pkg_Id_Dot(token, parent)
  -- TODO: Rule_Pkg_Id_Dot
end


-- <Pkg> ::= Id 
function Rule_Pkg_Id(token, parent)
  -- TODO: Rule_Pkg_Id
end


-- <Pkg List> ::= <Pkg> ',' <Pkg List> 
function Rule_PkgList_Comma(token, parent)
  -- TODO: Rule_PkgList_Comma
end


-- <Pkg List> ::= <Pkg> 
function Rule_PkgList(token, parent)
  -- TODO: Rule_PkgList
end


-- <If Stm> ::= if <Expr> <Block> <else-if> 
function Rule_IfStm_if(token, parent)
  -- TODO: Rule_IfStm_if
end


-- <else-if> ::= else if <Expr> <Block> <else-if> 
function Rule_elseif_else_if(token, parent)
  -- TODO: Rule_elseif_else_if
end


-- <else-if> ::= else <Block> 
function Rule_elseif_else(token, parent)
  -- TODO: Rule_elseif_else
end


-- <else-if> ::=  
function Rule_elseif(token, parent)
  -- TODO: Rule_elseif
end


-- <Normal Stm> ::= do <Block> while <Expr> 
function Rule_NormalStm_do_while(token, parent)
  -- TODO: Rule_NormalStm_do_while
end


-- <Normal Stm> ::= match <Expr> '{' <Case Stms> '}' 
function Rule_NormalStm_match_LBrace_RBrace(token, parent)
  -- TODO: Rule_NormalStm_match_LBrace_RBrace
end


-- <Normal Stm> ::= <Block> 
function Rule_NormalStm(token, parent)
  -- TODO: Rule_NormalStm
end


-- <Normal Stm> ::= <Expr> 
function Rule_NormalStm2(token, parent)
  -- TODO: Rule_NormalStm2
end


-- <Normal Stm> ::= break 
function Rule_NormalStm_break(token, parent)
  -- TODO: Rule_NormalStm_break
end


-- <Normal Stm> ::= continue 
function Rule_NormalStm_continue(token, parent)
  -- TODO: Rule_NormalStm_continue
end


-- <Normal Stm> ::= return <Expr> 
function Rule_NormalStm_return(token, parent)
  -- TODO: Rule_NormalStm_return
end


-- <Normal Stm> ::= return 
function Rule_NormalStm_return2(token, parent)
  -- TODO: Rule_NormalStm_return2
end


-- <Normal Stm> ::= ';' 
function Rule_NormalStm_Semi(token, parent)
  -- TODO: Rule_NormalStm_Semi
end


-- <Arg> ::= <Expr> 
function Rule_Arg(token, parent)
  -- TODO: Rule_Arg
end


-- <Arg> ::=  
function Rule_Arg2(token, parent)
  -- TODO: Rule_Arg2
end


-- <Case Stms> ::= case <Expr> when <Expr> <Block> <Case Stms> 
function Rule_CaseStms_case_when(token, parent)
  -- TODO: Rule_CaseStms_case_when
end


-- <Case Stms> ::= case <Expr> <Block> <Case Stms> 
function Rule_CaseStms_case(token, parent)
  -- TODO: Rule_CaseStms_case
end


-- <Case Stms> ::= else <Block> 
function Rule_CaseStms_else(token, parent)
  -- TODO: Rule_CaseStms_else
end


-- <Block> ::= '{' <Using Stms> <Stm List> '}' 
function Rule_Block_LBrace_RBrace(token, parent)
  -- TODO: Rule_Block_LBrace_RBrace
end


-- <Block> ::= synchronized '{' <Using Stms> <Stm List> '}' 
function Rule_Block_synchronized_LBrace_RBrace(token, parent)
  -- TODO: Rule_Block_synchronized_LBrace_RBrace
end


-- <Stm List> ::= <Stm> <Stm List> 
function Rule_StmList(token, parent)
  -- TODO: Rule_StmList
end


-- <Stm List> ::=  
function Rule_StmList2(token, parent)
  -- TODO: Rule_StmList2
end


-- <CSE> ::= <Expr> 
function Rule_CSE(token, parent)
  -- TODO: Rule_CSE
end


-- <CSE> ::= <CSE> ',' <Expr> 
function Rule_CSE_Comma(token, parent)
  -- TODO: Rule_CSE_Comma
end


-- <Expr> ::= <Var Decl> in <Expr> 
function Rule_Expr_in(token, parent)
  -- TODO: Rule_Expr_in
end


-- <Expr> ::= match <Expr> '{' <Case Exprs> '}' 
function Rule_Expr_match_LBrace_RBrace(token, parent)
  -- TODO: Rule_Expr_match_LBrace_RBrace
end


-- <Expr> ::= <Op Assign> 
function Rule_Expr(token, parent)
  -- TODO: Rule_Expr
end


-- <Op Assign> ::= <Op Or> '=' <Op Assign> 
function Rule_OpAssign_Eq(token, parent)
  -- TODO: Rule_OpAssign_Eq
end


-- <Op Assign> ::= <Op Or> '+=' <Op Assign> 
function Rule_OpAssign_PlusEq(token, parent)
  -- TODO: Rule_OpAssign_PlusEq
end


-- <Op Assign> ::= <Op Or> '-=' <Op Assign> 
function Rule_OpAssign_MinusEq(token, parent)
  -- TODO: Rule_OpAssign_MinusEq
end


-- <Op Assign> ::= <Op Or> '*=' <Op Assign> 
function Rule_OpAssign_TimesEq(token, parent)
  -- TODO: Rule_OpAssign_TimesEq
end


-- <Op Assign> ::= <Op Or> '/=' <Op Assign> 
function Rule_OpAssign_DivEq(token, parent)
  -- TODO: Rule_OpAssign_DivEq
end


-- <Op Assign> ::= <Op Or> '%=' <Op Assign> 
function Rule_OpAssign_PercentEq(token, parent)
  -- TODO: Rule_OpAssign_PercentEq
end


-- <Op Assign> ::= <Op Or> '^=' <Op Assign> 
function Rule_OpAssign_CaretEq(token, parent)
  -- TODO: Rule_OpAssign_CaretEq
end


-- <Op Assign> ::= <Op Or> '&=' <Op Assign> 
function Rule_OpAssign_AmpEq(token, parent)
  -- TODO: Rule_OpAssign_AmpEq
end


-- <Op Assign> ::= <Op Or> '|=' <Op Assign> 
function Rule_OpAssign_PipeEq(token, parent)
  -- TODO: Rule_OpAssign_PipeEq
end


-- <Op Assign> ::= <Op Or> '>>=' <Op Assign> 
function Rule_OpAssign_GtGtEq(token, parent)
  -- TODO: Rule_OpAssign_GtGtEq
end


-- <Op Assign> ::= <Op Or> '<<=' <Op Assign> 
function Rule_OpAssign_LtLtEq(token, parent)
  -- TODO: Rule_OpAssign_LtLtEq
end


-- <Op Assign> ::= <Op Or> 
function Rule_OpAssign(token, parent)
  -- TODO: Rule_OpAssign
end


-- <Op Or> ::= <Op Or> '||' <Op And> 
function Rule_OpOr_PipePipe(token, parent)
  -- TODO: Rule_OpOr_PipePipe
end


-- <Op Or> ::= <Op And> 
function Rule_OpOr(token, parent)
  -- TODO: Rule_OpOr
end


-- <Op And> ::= <Op And> '&&' <Op BinOR> 
function Rule_OpAnd_AmpAmp(token, parent)
  -- TODO: Rule_OpAnd_AmpAmp
end


-- <Op And> ::= <Op BinOR> 
function Rule_OpAnd(token, parent)
  -- TODO: Rule_OpAnd
end


-- <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> 
function Rule_OpBinOR_Pipe(token, parent)
  -- TODO: Rule_OpBinOR_Pipe
end


-- <Op BinOR> ::= <Op BinXOR> 
function Rule_OpBinOR(token, parent)
  -- TODO: Rule_OpBinOR
end


-- <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> 
function Rule_OpBinXOR_Caret(token, parent)
  -- TODO: Rule_OpBinXOR_Caret
end


-- <Op BinXOR> ::= <Op BinAND> 
function Rule_OpBinXOR(token, parent)
  -- TODO: Rule_OpBinXOR
end


-- <Op BinAND> ::= <Op BinAND> '&' <Op Equate> 
function Rule_OpBinAND_Amp(token, parent)
  -- TODO: Rule_OpBinAND_Amp
end


-- <Op BinAND> ::= <Op Equate> 
function Rule_OpBinAND(token, parent)
  -- TODO: Rule_OpBinAND
end


-- <Op Equate> ::= <Op Equate> '==' <Op Compare> 
function Rule_OpEquate_EqEq(token, parent)
  -- TODO: Rule_OpEquate_EqEq
end


-- <Op Equate> ::= <Op Equate> '!=' <Op Compare> 
function Rule_OpEquate_ExclamEq(token, parent)
  -- TODO: Rule_OpEquate_ExclamEq
end


-- <Op Equate> ::= <Op Compare> 
function Rule_OpEquate(token, parent)
  -- TODO: Rule_OpEquate
end


-- <Op Compare> ::= <Op Compare> '<' <Op Shift> 
function Rule_OpCompare_Lt(token, parent)
  -- TODO: Rule_OpCompare_Lt
end


-- <Op Compare> ::= <Op Compare> '>' <Op Shift> 
function Rule_OpCompare_Gt(token, parent)
  -- TODO: Rule_OpCompare_Gt
end


-- <Op Compare> ::= <Op Compare> '<=' <Op Shift> 
function Rule_OpCompare_LtEq(token, parent)
  -- TODO: Rule_OpCompare_LtEq
end


-- <Op Compare> ::= <Op Compare> '>=' <Op Shift> 
function Rule_OpCompare_GtEq(token, parent)
  -- TODO: Rule_OpCompare_GtEq
end


-- <Op Compare> ::= <Op Compare> is <Type> 
function Rule_OpCompare_is(token, parent)
  -- TODO: Rule_OpCompare_is
end


-- <Op Compare> ::= <Op Shift> 
function Rule_OpCompare(token, parent)
  -- TODO: Rule_OpCompare
end


-- <Op Shift> ::= <Op Shift> '<<' <Op Add> 
function Rule_OpShift_LtLt(token, parent)
  -- TODO: Rule_OpShift_LtLt
end


-- <Op Shift> ::= <Op Shift> '>>' <Op Add> 
function Rule_OpShift_GtGt(token, parent)
  -- TODO: Rule_OpShift_GtGt
end


-- <Op Shift> ::= <Op Add> 
function Rule_OpShift(token, parent)
  -- TODO: Rule_OpShift
end


-- <Op Add> ::= <Op Add> '+' <Op Mult> 
function Rule_OpAdd_Plus(token, parent)
  -- TODO: Rule_OpAdd_Plus
end


-- <Op Add> ::= <Op Add> '-' <Op Mult> 
function Rule_OpAdd_Minus(token, parent)
  -- TODO: Rule_OpAdd_Minus
end


-- <Op Add> ::= <Op Mult> 
function Rule_OpAdd(token, parent)
  -- TODO: Rule_OpAdd
end


-- <Op Mult> ::= <Op Mult> '*' <Op Unary> 
function Rule_OpMult_Times(token, parent)
  -- TODO: Rule_OpMult_Times
end


-- <Op Mult> ::= <Op Mult> '/' <Op Unary> 
function Rule_OpMult_Div(token, parent)
  -- TODO: Rule_OpMult_Div
end


-- <Op Mult> ::= <Op Mult> '%' <Op Unary> 
function Rule_OpMult_Percent(token, parent)
  -- TODO: Rule_OpMult_Percent
end


-- <Op Mult> ::= <Op Unary> 
function Rule_OpMult(token, parent)
  -- TODO: Rule_OpMult
end


-- <Op Unary> ::= '!' <Op Unary> 
function Rule_OpUnary_Exclam(token, parent)
  -- TODO: Rule_OpUnary_Exclam
end


-- <Op Unary> ::= '~' <Op Unary> 
function Rule_OpUnary_Tilde(token, parent)
  -- TODO: Rule_OpUnary_Tilde
end


-- <Op Unary> ::= '-' <Op Unary> 
function Rule_OpUnary_Minus(token, parent)
  -- TODO: Rule_OpUnary_Minus
end


-- <Op Unary> ::= '++' <Op Unary> 
function Rule_OpUnary_PlusPlus(token, parent)
  -- TODO: Rule_OpUnary_PlusPlus
end


-- <Op Unary> ::= '--' <Op Unary> 
function Rule_OpUnary_MinusMinus(token, parent)
  -- TODO: Rule_OpUnary_MinusMinus
end


-- <Op Unary> ::= <Op Pointer> '++' 
function Rule_OpUnary_PlusPlus2(token, parent)
  -- TODO: Rule_OpUnary_PlusPlus2
end


-- <Op Unary> ::= <Op Pointer> '--' 
function Rule_OpUnary_MinusMinus2(token, parent)
  -- TODO: Rule_OpUnary_MinusMinus2
end


-- <Op Unary> ::= <Op Unary> as <Type> 
function Rule_OpUnary_as(token, parent)
  -- TODO: Rule_OpUnary_as
end


-- <Op Unary> ::= <New Expr> 
function Rule_OpUnary(token, parent)
  -- TODO: Rule_OpUnary
end


-- <Op Unary> ::= delete <Op Pointer> 
function Rule_OpUnary_delete(token, parent)
  -- TODO: Rule_OpUnary_delete
end


-- <Op Unary> ::= sizeof '(' <Type> ')' 
function Rule_OpUnary_sizeof_LParen_RParen(token, parent)
  -- TODO: Rule_OpUnary_sizeof_LParen_RParen
end


-- <Op Unary> ::= <Op Pointer> 
function Rule_OpUnary2(token, parent)
  -- TODO: Rule_OpUnary2
end


-- <Op Pointer> ::= <Op Pointer> '.' <Value> 
function Rule_OpPointer_Dot(token, parent)
  -- TODO: Rule_OpPointer_Dot
end


-- <Op Pointer> ::= <Op Pointer> '[' <CSE> ']' 
function Rule_OpPointer_LBracket_RBracket(token, parent)
  -- TODO: Rule_OpPointer_LBracket_RBracket
end


-- <Op Pointer> ::= <Op Pointer> '(' <CSE> ')' 
function Rule_OpPointer_LParen_RParen(token, parent)
  -- TODO: Rule_OpPointer_LParen_RParen
end


-- <Op Pointer> ::= <Op Pointer> '(' ')' 
function Rule_OpPointer_LParen_RParen2(token, parent)
  -- TODO: Rule_OpPointer_LParen_RParen2
end


-- <Op Pointer> ::= <Value> 
function Rule_OpPointer(token, parent)
  -- TODO: Rule_OpPointer
end


-- <Value> ::= OctLiteral 
function Rule_Value_OctLiteral(token, parent)
  -- TODO: Rule_Value_OctLiteral
end


-- <Value> ::= HexLiteral 
function Rule_Value_HexLiteral(token, parent)
  -- TODO: Rule_Value_HexLiteral
end


-- <Value> ::= DecLiteral 
function Rule_Value_DecLiteral(token, parent)
  -- TODO: Rule_Value_DecLiteral
end


-- <Value> ::= BinLiteral 
function Rule_Value_BinLiteral(token, parent)
  -- TODO: Rule_Value_BinLiteral
end


-- <Value> ::= StringLiteral 
function Rule_Value_StringLiteral(token, parent)
  -- TODO: Rule_Value_StringLiteral
end


-- <Value> ::= CharLiteral 
function Rule_Value_CharLiteral(token, parent)
  -- TODO: Rule_Value_CharLiteral
end


-- <Value> ::= FloatLiteral 
function Rule_Value_FloatLiteral(token, parent)
  -- TODO: Rule_Value_FloatLiteral
end


-- <Value> ::= null 
function Rule_Value_null(token, parent)
  -- TODO: Rule_Value_null
end


-- <Value> ::= '_' 
function Rule_Value__(token, parent)
  -- TODO: Rule_Value__
end


-- <Value> ::= true 
function Rule_Value_true(token, parent)
  -- TODO: Rule_Value_true
end


-- <Value> ::= false 
function Rule_Value_false(token, parent)
  -- TODO: Rule_Value_false
end


-- <Value> ::= <Pkg> 
function Rule_Value(token, parent)
  -- TODO: Rule_Value
end


-- <Value> ::= <Lambda Expr> 
function Rule_Value2(token, parent)
  -- TODO: Rule_Value2
end


-- <Value> ::= '(' <CSE> ')' 
function Rule_Value_LParen_RParen(token, parent)
  -- TODO: Rule_Value_LParen_RParen
end


-- <Value> ::= '[' for Id ':' <Type> in <Expr> '=>' <Expr> ']' 
function Rule_Value_LBracket_for_Id_Colon_in_EqGt_RBracket(token, parent)
  -- TODO: Rule_Value_LBracket_for_Id_Colon_in_EqGt_RBracket
end


-- <Value> ::= '[' for Id in <Expr> '=>' <Expr> ']' 
function Rule_Value_LBracket_for_Id_in_EqGt_RBracket(token, parent)
  -- TODO: Rule_Value_LBracket_for_Id_in_EqGt_RBracket
end


-- <Value> ::= '[' for Id ':' <Type> in <Expr> if <Expr> '=>' <Expr> ']' 
function Rule_Value_LBracket_for_Id_Colon_in_if_EqGt_RBracket(token, parent)
  -- TODO: Rule_Value_LBracket_for_Id_Colon_in_if_EqGt_RBracket
end


-- <Value> ::= '[' for Id in <Expr> if <Expr> '=>' <Expr> ']' 
function Rule_Value_LBracket_for_Id_in_if_EqGt_RBracket(token, parent)
  -- TODO: Rule_Value_LBracket_for_Id_in_if_EqGt_RBracket
end


-- <Value> ::= '[' <CSE> ']' 
function Rule_Value_LBracket_RBracket(token, parent)
  -- TODO: Rule_Value_LBracket_RBracket
end


-- <Lambda Expr> ::= lambda '(' <Params> ')' <Block> 
function Rule_LambdaExpr_lambda_LParen_RParen(token, parent)
  -- TODO: Rule_LambdaExpr_lambda_LParen_RParen
end


-- <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> 
function Rule_LambdaExpr_lambda_LParen_RParen_Eq(token, parent)
  -- TODO: Rule_LambdaExpr_lambda_LParen_RParen_Eq
end


-- <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> 
function Rule_LambdaExpr_lambda_LParen_RParen_MinusGt(token, parent)
  -- TODO: Rule_LambdaExpr_lambda_LParen_RParen_MinusGt
end


-- <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> 
function Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq(token, parent)
  -- TODO: Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq
end


-- <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> 
function Rule_CaseExprs_case_when_EqGt(token, parent)
  -- TODO: Rule_CaseExprs_case_when_EqGt
end


-- <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> 
function Rule_CaseExprs_case_EqGt(token, parent)
  -- TODO: Rule_CaseExprs_case_EqGt
end


-- <Case Exprs> ::= else '=>' <Expr> 
function Rule_CaseExprs_else_EqGt(token, parent)
  -- TODO: Rule_CaseExprs_else_EqGt
end


-- <New Expr> ::= new <Pkg Template> '(' ')' 
function Rule_NewExpr_new_LParen_RParen(token, parent)
  -- TODO: Rule_NewExpr_new_LParen_RParen
end


-- <New Expr> ::= new <Pkg Template> '(' <Expr> ')' 
function Rule_NewExpr_new_LParen_RParen2(token, parent)
  -- TODO: Rule_NewExpr_new_LParen_RParen2
end


-- <New Expr> ::= new <Pkg Template> '(' ')' '{' <CDecl> '}' 
function Rule_NewExpr_new_LParen_RParen_LBrace_RBrace(token, parent)
  -- TODO: Rule_NewExpr_new_LParen_RParen_LBrace_RBrace
end


-- <New Expr> ::= new <Pkg Template> '(' <Expr> ')' '{' <CDecl> '}' 
function Rule_NewExpr_new_LParen_RParen_LBrace_RBrace2(token, parent)
  -- TODO: Rule_NewExpr_new_LParen_RParen_LBrace_RBrace2
end


-- <New Expr> ::= new <Type> 
function Rule_NewExpr_new(token, parent)
  -- TODO: Rule_NewExpr_new
end


-- <New Expr> ::= new <Type> '[' <Expr> ']' 
function Rule_NewExpr_new_LBracket_RBracket(token, parent)
  -- TODO: Rule_NewExpr_new_LBracket_RBracket
end


local ruleJumpTable = {

  -- 0. <Decls> ::= <Imports> <Using Stms> <Decl List> 
  [0] = Rule_Decls,

  -- 1. <Decls> ::=  
  [1] = Rule_Decls2,

  -- 2. <Decl List> ::= <Decl> <Decl List> 
  [2] = Rule_DeclList,

  -- 3. <Decl List> ::= <Decl> 
  [3] = Rule_DeclList2,

  -- 4. <Decl> ::= <Func Decl> 
  [4] = Rule_Decl,

  -- 5. <Decl> ::= <Class Decl> 
  [5] = Rule_Decl2,

  -- 6. <Decl> ::= <Enum Decl> 
  [6] = Rule_Decl3,

  -- 7. <Decl> ::= <Var Decl> 
  [7] = Rule_Decl4,

  -- 8. <Decl> ::= <CDefFunc Decl> 
  [8] = Rule_Decl5,

  -- 9. <Imports> ::= <Import> <Imports> 
  [9] = Rule_Imports,

  -- 10. <Imports> ::=  
  [10] = Rule_Imports2,

  -- 11. <Import> ::= import <File Path All> 
  [11] = Rule_Import_import,

  -- 12. <Import> ::= import <File Path> as Id 
  [12] = Rule_Import_import_as_Id,

  -- 13. <Import> ::= from <File Path> import <File Path List> 
  [13] = Rule_Import_from_import,

  -- 14. <File Path> ::= Id '.' <File Path> 
  [14] = Rule_FilePath_Id_Dot,

  -- 15. <File Path> ::= Id 
  [15] = Rule_FilePath_Id,

  -- 16. <File Path All> ::= Id '.' <File Path All> 
  [16] = Rule_FilePathAll_Id_Dot,

  -- 17. <File Path All> ::= Id '.*' 
  [17] = Rule_FilePathAll_Id_DotTimes,

  -- 18. <File Path All> ::= Id 
  [18] = Rule_FilePathAll_Id,

  -- 19. <File Path List> ::= <File Path> ',' <File Path List> 
  [19] = Rule_FilePathList_Comma,

  -- 20. <File Path List> ::= <File Path> 
  [20] = Rule_FilePathList,

  -- 21. <Fn Header Proto> ::= Id '(' <Params> ')' 
  [21] = Rule_FnHeaderProto_Id_LParen_RParen,

  -- 22. <Fn Header Proto> ::= Id '(' <Params> ')' '->' <Type> 
  [22] = Rule_FnHeaderProto_Id_LParen_RParen_MinusGt,

  -- 23. <Fn Header Proto> ::= Id '(' <Types> ')' 
  [23] = Rule_FnHeaderProto_Id_LParen_RParen2,

  -- 24. <Fn Header Proto> ::= Id '(' <Types> ')' '->' <Type> 
  [24] = Rule_FnHeaderProto_Id_LParen_RParen_MinusGt2,

  -- 25. <Fn Header Proto> ::= Id '(' ')' 
  [25] = Rule_FnHeaderProto_Id_LParen_RParen3,

  -- 26. <Fn Header Proto> ::= Id '(' ')' '->' <Type> 
  [26] = Rule_FnHeaderProto_Id_LParen_RParen_MinusGt3,

  -- 27. <Fn Header Impl> ::= Id '(' <Params> ')' 
  [27] = Rule_FnHeaderImpl_Id_LParen_RParen,

  -- 28. <Fn Header Impl> ::= Id '(' <Params> ')' '->' <Type> 
  [28] = Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt,

  -- 29. <Fn Header Impl> ::= Id '(' ')' 
  [29] = Rule_FnHeaderImpl_Id_LParen_RParen2,

  -- 30. <Fn Header Impl> ::= Id '(' ')' '->' <Type> 
  [30] = Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt2,

  -- 31. <Func Decl> ::= function <Fn Header Impl> <Func Body> 
  [31] = Rule_FuncDecl_function,

  -- 32. <Func Decl> ::= local function <Fn Header Impl> <Func Body> 
  [32] = Rule_FuncDecl_local_function,

  -- 33. <Func Decl> ::= synchronized function <Fn Header Impl> <Func Body> 
  [33] = Rule_FuncDecl_synchronized_function,

  -- 34. <Func Decl> ::= synchronized local function <Fn Header Impl> <Func Body> 
  [34] = Rule_FuncDecl_synchronized_local_function,

  -- 35. <Func Decl> ::= local synchronized function <Fn Header Impl> <Func Body> 
  [35] = Rule_FuncDecl_local_synchronized_function,

  -- 36. <Func Decl> ::= pure function <Fn Header Impl> <Func Body> 
  [36] = Rule_FuncDecl_pure_function,

  -- 37. <Func Decl> ::= local pure function <Fn Header Impl> <Func Body> 
  [37] = Rule_FuncDecl_local_pure_function,

  -- 38. <Func Decl> ::= pure local function <Fn Header Impl> <Func Body> 
  [38] = Rule_FuncDecl_pure_local_function,

  -- 39. <Func Body> ::= '=' <Expr> 
  [39] = Rule_FuncBody_Eq,

  -- 40. <Func Body> ::= <Block> 
  [40] = Rule_FuncBody,

  -- 41. <CFunc Proto> ::= function <Fn Header Proto> 
  [41] = Rule_CFuncProto_function,

  -- 42. <CFunc Proto> ::= pure function <Fn Header Proto> 
  [42] = Rule_CFuncProto_pure_function,

  -- 43. <CFunc Proto> ::= static function <Fn Header Proto> 
  [43] = Rule_CFuncProto_static_function,

  -- 44. <CFunc Proto> ::= <Visibility> function <Fn Header Proto> 
  [44] = Rule_CFuncProto_function2,

  -- 45. <CFunc Proto> ::= <Inherited> function <Fn Header Proto> 
  [45] = Rule_CFuncProto_function3,

  -- 46. <CFunc Proto> ::= pure static function <Fn Header Proto> 
  [46] = Rule_CFuncProto_pure_static_function,

  -- 47. <CFunc Proto> ::= pure <Visibility> function <Fn Header Proto> 
  [47] = Rule_CFuncProto_pure_function2,

  -- 48. <CFunc Proto> ::= pure <Inherited> function <Fn Header Proto> 
  [48] = Rule_CFuncProto_pure_function3,

  -- 49. <CFunc Proto> ::= static pure function <Fn Header Proto> 
  [49] = Rule_CFuncProto_static_pure_function,

  -- 50. <CFunc Proto> ::= static <Visibility> function <Fn Header Proto> 
  [50] = Rule_CFuncProto_static_function2,

  -- 51. <CFunc Proto> ::= static <Inherited> function <Fn Header Proto> 
  [51] = Rule_CFuncProto_static_function3,

  -- 52. <CFunc Proto> ::= <Visibility> pure function <Fn Header Proto> 
  [52] = Rule_CFuncProto_pure_function4,

  -- 53. <CFunc Proto> ::= <Visibility> static function <Fn Header Proto> 
  [53] = Rule_CFuncProto_static_function4,

  -- 54. <CFunc Proto> ::= <Visibility> <Inherited> function <Fn Header Proto> 
  [54] = Rule_CFuncProto_function4,

  -- 55. <CFunc Proto> ::= <Inherited> pure function <Fn Header Proto> 
  [55] = Rule_CFuncProto_pure_function5,

  -- 56. <CFunc Proto> ::= <Inherited> <Visibility> function <Fn Header Proto> 
  [56] = Rule_CFuncProto_function5,

  -- 57. <CFunc Proto> ::= <Inherited> static function <Fn Header Proto> 
  [57] = Rule_CFuncProto_static_function5,

  -- 58. <CFunc Proto> ::= pure static <Visibility> function <Fn Header Proto> 
  [58] = Rule_CFuncProto_pure_static_function2,

  -- 59. <CFunc Proto> ::= pure <Visibility> static function <Fn Header Proto> 
  [59] = Rule_CFuncProto_pure_static_function3,

  -- 60. <CFunc Proto> ::= pure <Visibility> <Inherited> function <Fn Header Proto> 
  [60] = Rule_CFuncProto_pure_function6,

  -- 61. <CFunc Proto> ::= pure <Inherited> <Visibility> function <Fn Header Proto> 
  [61] = Rule_CFuncProto_pure_function7,

  -- 62. <CFunc Proto> ::= static pure <Visibility> function <Fn Header Proto> 
  [62] = Rule_CFuncProto_static_pure_function2,

  -- 63. <CFunc Proto> ::= static <Visibility> pure function <Fn Header Proto> 
  [63] = Rule_CFuncProto_static_pure_function3,

  -- 64. <CFunc Proto> ::= static <Visibility> <Inherited> function <Fn Header Proto> 
  [64] = Rule_CFuncProto_static_function6,

  -- 65. <CFunc Proto> ::= static <Inherited> <Visibility> function <Fn Header Proto> 
  [65] = Rule_CFuncProto_static_function7,

  -- 66. <CFunc Proto> ::= <Inherited> <Visibility> pure function <Fn Header Proto> 
  [66] = Rule_CFuncProto_pure_function8,

  -- 67. <CFunc Proto> ::= <Inherited> pure <Visibility> function <Fn Header Proto> 
  [67] = Rule_CFuncProto_pure_function9,

  -- 68. <CFunc Proto> ::= <Inherited> pure static function <Fn Header Proto> 
  [68] = Rule_CFuncProto_pure_static_function4,

  -- 69. <CFunc Decl> ::= <CFunc Proto> <Func Body> 
  [69] = Rule_CFuncDecl,

  -- 70. <CDefFunc Decl> ::= extern function <Fn Header Proto> 
  [70] = Rule_CDefFuncDecl_extern_function,

  -- 71. <CDefFunc Decl> ::= extern pure function <Fn Header Proto> 
  [71] = Rule_CDefFuncDecl_extern_pure_function,

  -- 72. <CDefFunc Decl> ::= extern local function <Fn Header Proto> 
  [72] = Rule_CDefFuncDecl_extern_local_function,

  -- 73. <CDefFunc Decl> ::= local extern function <Fn Header Proto> 
  [73] = Rule_CDefFuncDecl_local_extern_function,

  -- 74. <CDefFunc Decl> ::= local pure extern function <Fn Header Proto> 
  [74] = Rule_CDefFuncDecl_local_pure_extern_function,

  -- 75. <CDefFunc Decl> ::= local extern pure function <Fn Header Proto> 
  [75] = Rule_CDefFuncDecl_local_extern_pure_function,

  -- 76. <CDefFunc Decl> ::= pure extern function <Fn Header Proto> 
  [76] = Rule_CDefFuncDecl_pure_extern_function,

  -- 77. <CDefFunc Decl> ::= pure local extern function <Fn Header Proto> 
  [77] = Rule_CDefFuncDecl_pure_local_extern_function,

  -- 78. <CDefFunc Decl> ::= pure extern local function <Fn Header Proto> 
  [78] = Rule_CDefFuncDecl_pure_extern_local_function,

  -- 79. <Visibility> ::= public 
  [79] = Rule_Visibility_public,

  -- 80. <Visibility> ::= private 
  [80] = Rule_Visibility_private,

  -- 81. <Visibility> ::= protected 
  [81] = Rule_Visibility_protected,

  -- 82. <Inherited> ::= inherited '(' <Pkg List> ')' 
  [82] = Rule_Inherited_inherited_LParen_RParen,

  -- 83. <Inherited> ::= inherited 
  [83] = Rule_Inherited_inherited,

  -- 84. <Params> ::= <Param> ',' <Params> 
  [84] = Rule_Params_Comma,

  -- 85. <Params> ::= <Param> 
  [85] = Rule_Params,

  -- 86. <Param> ::= final Id ':' <Type> 
  [86] = Rule_Param_final_Id_Colon,

  -- 87. <Param> ::= Id ':' <Type> 
  [87] = Rule_Param_Id_Colon,

  -- 88. <Types> ::= <Type> ',' <Types> 
  [88] = Rule_Types_Comma,

  -- 89. <Types> ::= <Type> 
  [89] = Rule_Types,

  -- 90. <Id List> ::= Id ',' <Id List> 
  [90] = Rule_IdList_Id_Comma,

  -- 91. <Id List> ::= Id 
  [91] = Rule_IdList_Id,

  -- 92. <Class Decl> ::= <Normal Class> 
  [92] = Rule_ClassDecl,

  -- 93. <Class Decl> ::= <Abstract Class> 
  [93] = Rule_ClassDecl2,

  -- 94. <Class Decl> ::= local <Normal Class> 
  [94] = Rule_ClassDecl_local,

  -- 95. <Class Decl> ::= local <Abstract Class> 
  [95] = Rule_ClassDecl_local2,

  -- 96. <Normal Class> ::= class <Class Name> '{' <CDecls> '}' 
  [96] = Rule_NormalClass_class_LBrace_RBrace,

  -- 97. <Normal Class> ::= class <Class Name> extends <Extend Class Name List> '{' <CDecls> '}' 
  [97] = Rule_NormalClass_class_extends_LBrace_RBrace,

  -- 98. <Abstract Class> ::= abstract class <Class Name> '{' <ACDecls> '}' 
  [98] = Rule_AbstractClass_abstract_class_LBrace_RBrace,

  -- 99. <Abstract Class> ::= abstract class <Class Name> extends <Extend Class Name List> '{' <ACDecls> '}' 
  [99] = Rule_AbstractClass_abstract_class_extends_LBrace_RBrace,

  -- 100. <Class Name> ::= Id 
  [100] = Rule_ClassName_Id,

  -- 101. <Class Name> ::= Id '<' <Id List> '>' 
  [101] = Rule_ClassName_Id_Lt_Gt,

  -- 102. <Extend Class Name List> ::= <Extend Class Name> ',' <Extend Class Name List> 
  [102] = Rule_ExtendClassNameList_Comma,

  -- 103. <Extend Class Name List> ::= <Extend Class Name> 
  [103] = Rule_ExtendClassNameList,

  -- 104. <Extend Class Name> ::= <Pkg> 
  [104] = Rule_ExtendClassName,

  -- 105. <Extend Class Name> ::= <Pkg> '<' <Extend Class Name List> '>' 
  [105] = Rule_ExtendClassName_Lt_Gt,

  -- 106. <CDecls> ::= <CDecl> <CDecls> 
  [106] = Rule_CDecls,

  -- 107. <CDecls> ::=  
  [107] = Rule_CDecls2,

  -- 108. <ACDecls> ::= <ACDecl> <ACDecls> 
  [108] = Rule_ACDecls,

  -- 109. <ACDecls> ::=  
  [109] = Rule_ACDecls2,

  -- 110. <CDecl> ::= <CFunc Decl> 
  [110] = Rule_CDecl,

  -- 111. <CDecl> ::= <CVar Decl> 
  [111] = Rule_CDecl2,

  -- 112. <CDecl> ::= <Operator Impl> 
  [112] = Rule_CDecl3,

  -- 113. <ACDecl> ::= <CFunc Decl> 
  [113] = Rule_ACDecl,

  -- 114. <ACDecl> ::= <CFunc Proto> 
  [114] = Rule_ACDecl2,

  -- 115. <ACDecl> ::= <CVar Decl> 
  [115] = Rule_ACDecl3,

  -- 116. <ACDecl> ::= <Operator Impl> 
  [116] = Rule_ACDecl4,

  -- 117. <ACDecl> ::= <Operator Proto> 
  [117] = Rule_ACDecl5,

  -- 118. <Operator Impl> ::= operator <Operator> <Op Header Impl> '=' <Expr> 
  [118] = Rule_OperatorImpl_operator_Eq,

  -- 119. <Operator Impl> ::= operator <Operator> <Op Header Impl> <Block> 
  [119] = Rule_OperatorImpl_operator,

  -- 120. <Operator Proto> ::= operator <Operator> <Op Header Proto> 
  [120] = Rule_OperatorProto_operator,

  -- 121. <CDefStruct> ::= extern struct Id '{' <Params> '}' 
  [121] = Rule_CDefStruct_extern_struct_Id_LBrace_RBrace,

  -- 122. <Operator> ::= '+' 
  [122] = Rule_Operator_Plus,

  -- 123. <Operator> ::= '-' 
  [123] = Rule_Operator_Minus,

  -- 124. <Operator> ::= '*' 
  [124] = Rule_Operator_Times,

  -- 125. <Operator> ::= '/' 
  [125] = Rule_Operator_Div,

  -- 126. <Operator> ::= '%' 
  [126] = Rule_Operator_Percent,

  -- 127. <Operator> ::= '^' 
  [127] = Rule_Operator_Caret,

  -- 128. <Operator> ::= '&' 
  [128] = Rule_Operator_Amp,

  -- 129. <Operator> ::= '|' 
  [129] = Rule_Operator_Pipe,

  -- 130. <Operator> ::= '~' 
  [130] = Rule_Operator_Tilde,

  -- 131. <Operator> ::= '!' 
  [131] = Rule_Operator_Exclam,

  -- 132. <Operator> ::= '=' 
  [132] = Rule_Operator_Eq,

  -- 133. <Operator> ::= '<' 
  [133] = Rule_Operator_Lt,

  -- 134. <Operator> ::= '>' 
  [134] = Rule_Operator_Gt,

  -- 135. <Operator> ::= '+=' 
  [135] = Rule_Operator_PlusEq,

  -- 136. <Operator> ::= '-=' 
  [136] = Rule_Operator_MinusEq,

  -- 137. <Operator> ::= '*=' 
  [137] = Rule_Operator_TimesEq,

  -- 138. <Operator> ::= '/=' 
  [138] = Rule_Operator_DivEq,

  -- 139. <Operator> ::= '%=' 
  [139] = Rule_Operator_PercentEq,

  -- 140. <Operator> ::= '^=' 
  [140] = Rule_Operator_CaretEq,

  -- 141. <Operator> ::= '&=' 
  [141] = Rule_Operator_AmpEq,

  -- 142. <Operator> ::= '|=' 
  [142] = Rule_Operator_PipeEq,

  -- 143. <Operator> ::= '<<' 
  [143] = Rule_Operator_LtLt,

  -- 144. <Operator> ::= '>>' 
  [144] = Rule_Operator_GtGt,

  -- 145. <Operator> ::= '>>=' 
  [145] = Rule_Operator_GtGtEq,

  -- 146. <Operator> ::= '<<=' 
  [146] = Rule_Operator_LtLtEq,

  -- 147. <Operator> ::= '==' 
  [147] = Rule_Operator_EqEq,

  -- 148. <Operator> ::= '!=' 
  [148] = Rule_Operator_ExclamEq,

  -- 149. <Operator> ::= '<=' 
  [149] = Rule_Operator_LtEq,

  -- 150. <Operator> ::= '>=' 
  [150] = Rule_Operator_GtEq,

  -- 151. <Operator> ::= '&&' 
  [151] = Rule_Operator_AmpAmp,

  -- 152. <Operator> ::= '||' 
  [152] = Rule_Operator_PipePipe,

  -- 153. <Operator> ::= '++' 
  [153] = Rule_Operator_PlusPlus,

  -- 154. <Operator> ::= '--' 
  [154] = Rule_Operator_MinusMinus,

  -- 155. <Operator> ::= ',' 
  [155] = Rule_Operator_Comma,

  -- 156. <Operator> ::= '(' ')' 
  [156] = Rule_Operator_LParen_RParen,

  -- 157. <Operator> ::= '[' ']' 
  [157] = Rule_Operator_LBracket_RBracket,

  -- 158. <Op Header Proto> ::= '(' <Params> ')' 
  [158] = Rule_OpHeaderProto_LParen_RParen,

  -- 159. <Op Header Proto> ::= '(' <Params> ')' '->' <Type> 
  [159] = Rule_OpHeaderProto_LParen_RParen_MinusGt,

  -- 160. <Op Header Proto> ::= '(' <Types> ')' 
  [160] = Rule_OpHeaderProto_LParen_RParen2,

  -- 161. <Op Header Proto> ::= '(' <Types> ')' '->' <Type> 
  [161] = Rule_OpHeaderProto_LParen_RParen_MinusGt2,

  -- 162. <Op Header Proto> ::= '(' ')' 
  [162] = Rule_OpHeaderProto_LParen_RParen3,

  -- 163. <Op Header Proto> ::= '(' ')' '->' <Type> 
  [163] = Rule_OpHeaderProto_LParen_RParen_MinusGt3,

  -- 164. <Op Header Impl> ::= '(' <Params> ')' 
  [164] = Rule_OpHeaderImpl_LParen_RParen,

  -- 165. <Op Header Impl> ::= '(' <Params> ')' '->' <Type> 
  [165] = Rule_OpHeaderImpl_LParen_RParen_MinusGt,

  -- 166. <Op Header Impl> ::= '(' ')' 
  [166] = Rule_OpHeaderImpl_LParen_RParen2,

  -- 167. <Op Header Impl> ::= '(' ')' '->' <Type> 
  [167] = Rule_OpHeaderImpl_LParen_RParen_MinusGt2,

  -- 168. <Var Decl> ::= let final <Var Header> 
  [168] = Rule_VarDecl_let_final,

  -- 169. <Var Decl> ::= let <Var Header> 
  [169] = Rule_VarDecl_let,

  -- 170. <Var Decl> ::= let local <Var Header> 
  [170] = Rule_VarDecl_let_local,

  -- 171. <Var Decl> ::= let local final <Var Header> 
  [171] = Rule_VarDecl_let_local_final,

  -- 172. <Var Decl> ::= let final local <Var Header> 
  [172] = Rule_VarDecl_let_final_local,

  -- 173. <Var Decl> ::= let atomic <Var Header> 
  [173] = Rule_VarDecl_let_atomic,

  -- 174. <Var Decl> ::= let local atomic <Var Header> 
  [174] = Rule_VarDecl_let_local_atomic,

  -- 175. <Var Decl> ::= let atomic local <Var Header> 
  [175] = Rule_VarDecl_let_atomic_local,

  -- 176. <CVar Decl> ::= let <Var Header> 
  [176] = Rule_CVarDecl_let,

  -- 177. <CVar Decl> ::= let final <Var Header> 
  [177] = Rule_CVarDecl_let_final,

  -- 178. <CVar Decl> ::= let final static <Var Header> 
  [178] = Rule_CVarDecl_let_final_static,

  -- 179. <CVar Decl> ::= let final <Visibility> <Var Header> 
  [179] = Rule_CVarDecl_let_final2,

  -- 180. <CVar Decl> ::= let final <Visibility> static <Var Header> 
  [180] = Rule_CVarDecl_let_final_static2,

  -- 181. <CVar Decl> ::= let final static <Visibility> <Var Header> 
  [181] = Rule_CVarDecl_let_final_static3,

  -- 182. <CVar Decl> ::= let static <Var Header> 
  [182] = Rule_CVarDecl_let_static,

  -- 183. <CVar Decl> ::= let static final <Var Header> 
  [183] = Rule_CVarDecl_let_static_final,

  -- 184. <CVar Decl> ::= let static atomic <Var Header> 
  [184] = Rule_CVarDecl_let_static_atomic,

  -- 185. <CVar Decl> ::= let static <Visibility> <Var Header> 
  [185] = Rule_CVarDecl_let_static2,

  -- 186. <CVar Decl> ::= let static <Visibility> atomic <Var Header> 
  [186] = Rule_CVarDecl_let_static_atomic2,

  -- 187. <CVar Decl> ::= let static <Visibility> final <Var Header> 
  [187] = Rule_CVarDecl_let_static_final2,

  -- 188. <CVar Decl> ::= let static atomic <Visibility> <Var Header> 
  [188] = Rule_CVarDecl_let_static_atomic3,

  -- 189. <CVar Decl> ::= let <Visibility> <Var Header> 
  [189] = Rule_CVarDecl_let2,

  -- 190. <CVar Decl> ::= let <Visibility> static <Var Header> 
  [190] = Rule_CVarDecl_let_static3,

  -- 191. <CVar Decl> ::= let <Visibility> static atomic <Var Header> 
  [191] = Rule_CVarDecl_let_static_atomic4,

  -- 192. <CVar Decl> ::= let <Visibility> final <Var Header> 
  [192] = Rule_CVarDecl_let_final3,

  -- 193. <CVar Decl> ::= let <Visibility> static final <Var Header> 
  [193] = Rule_CVarDecl_let_static_final3,

  -- 194. <CVar Decl> ::= let <Visibility> final static <Var Header> 
  [194] = Rule_CVarDecl_let_final_static4,

  -- 195. <CVar Decl> ::= let <Visibility> atomic static 
  [195] = Rule_CVarDecl_let_atomic_static,

  -- 196. <CVar Decl> ::= let atomic <Var Header> 
  [196] = Rule_CVarDecl_let_atomic,

  -- 197. <CVar Decl> ::= let atomic <Visibility> <Var Header> 
  [197] = Rule_CVarDecl_let_atomic2,

  -- 198. <CVar Decl> ::= let atomic static <Var Header> 
  [198] = Rule_CVarDecl_let_atomic_static2,

  -- 199. <CVar Decl> ::= let atomic <Visibility> static <Var Header> 
  [199] = Rule_CVarDecl_let_atomic_static3,

  -- 200. <CVar Decl> ::= let atomic static <Visibility> <Var Header> 
  [200] = Rule_CVarDecl_let_atomic_static4,

  -- 201. <Var Header> ::= <Id List> ':' <Type> '=' <CSE> 
  [201] = Rule_VarHeader_Colon_Eq,

  -- 202. <Var Header> ::= <Id List> ':' <Type> 
  [202] = Rule_VarHeader_Colon,

  -- 203. <Var Header> ::= <Id List> '=' <CSE> 
  [203] = Rule_VarHeader_Eq,

  -- 204. <Enum Decl> ::= enum Id '{' <Enum Def> '}' 
  [204] = Rule_EnumDecl_enum_Id_LBrace_RBrace,

  -- 205. <Enum Decl> ::= local enum Id '{' <Enum Def> '}' 
  [205] = Rule_EnumDecl_local_enum_Id_LBrace_RBrace,

  -- 206. <Enum Def> ::= Id ',' <Enum Def> 
  [206] = Rule_EnumDef_Id_Comma,

  -- 207. <Enum Def> ::= Id 
  [207] = Rule_EnumDef_Id,

  -- 208. <Type> ::= <Base> 
  [208] = Rule_Type,

  -- 209. <Type> ::= <Fn Type> 
  [209] = Rule_Type2,

  -- 210. <Type> ::= <Pkg Template> 
  [210] = Rule_Type3,

  -- 211. <Type> ::= <Type> '[' ']' 
  [211] = Rule_Type_LBracket_RBracket,

  -- 212. <Type> ::= '(' <Types> ')' 
  [212] = Rule_Type_LParen_RParen,

  -- 213. <Fn Type> ::= fn '(' ')' 
  [213] = Rule_FnType_fn_LParen_RParen,

  -- 214. <Fn Type> ::= fn '(' ')' '->' <Type> 
  [214] = Rule_FnType_fn_LParen_RParen_MinusGt,

  -- 215. <Fn Type> ::= fn '(' <Types> ')' 
  [215] = Rule_FnType_fn_LParen_RParen2,

  -- 216. <Fn Type> ::= fn '(' <Types> ')' '->' <Type> 
  [216] = Rule_FnType_fn_LParen_RParen_MinusGt2,

  -- 217. <Pkg Template> ::= <Pkg> 
  [217] = Rule_PkgTemplate,

  -- 218. <Pkg Template> ::= <Pkg> '<' <Types> '>' 
  [218] = Rule_PkgTemplate_Lt_Gt,

  -- 219. <Base> ::= <Sign> <Scalar> 
  [219] = Rule_Base,

  -- 220. <Base> ::= 'size_t' 
  [220] = Rule_Base_size_t,

  -- 221. <Base> ::= byte 
  [221] = Rule_Base_byte,

  -- 222. <Base> ::= float 
  [222] = Rule_Base_float,

  -- 223. <Base> ::= double 
  [223] = Rule_Base_double,

  -- 224. <Base> ::= bool 
  [224] = Rule_Base_bool,

  -- 225. <Base> ::= long double 
  [225] = Rule_Base_long_double,

  -- 226. <Sign> ::= signed 
  [226] = Rule_Sign_signed,

  -- 227. <Sign> ::= unsigned 
  [227] = Rule_Sign_unsigned,

  -- 228. <Sign> ::=  
  [228] = Rule_Sign,

  -- 229. <Scalar> ::= char 
  [229] = Rule_Scalar_char,

  -- 230. <Scalar> ::= int 
  [230] = Rule_Scalar_int,

  -- 231. <Scalar> ::= short 
  [231] = Rule_Scalar_short,

  -- 232. <Scalar> ::= long 
  [232] = Rule_Scalar_long,

  -- 233. <Scalar> ::= short int 
  [233] = Rule_Scalar_short_int,

  -- 234. <Scalar> ::= long int 
  [234] = Rule_Scalar_long_int,

  -- 235. <Stm> ::= <Var Decl> 
  [235] = Rule_Stm,

  -- 236. <Stm> ::= <If Stm> 
  [236] = Rule_Stm2,

  -- 237. <Stm> ::= while <Expr> <Block> 
  [237] = Rule_Stm_while,

  -- 238. <Stm> ::= for <Arg> ';' <Arg> ';' <Arg> <Block> 
  [238] = Rule_Stm_for_Semi_Semi,

  -- 239. <Stm> ::= foreach <Param> in <Expr> <Block> 
  [239] = Rule_Stm_foreach_in,

  -- 240. <Stm> ::= <Normal Stm> 
  [240] = Rule_Stm3,

  -- 241. <Using Stm> ::= using <Pkg> 
  [241] = Rule_UsingStm_using,

  -- 242. <Using Stms> ::= <Using Stm> <Using Stms> 
  [242] = Rule_UsingStms,

  -- 243. <Using Stms> ::=  
  [243] = Rule_UsingStms2,

  -- 244. <Pkg> ::= Id '.' <Pkg> 
  [244] = Rule_Pkg_Id_Dot,

  -- 245. <Pkg> ::= Id 
  [245] = Rule_Pkg_Id,

  -- 246. <Pkg List> ::= <Pkg> ',' <Pkg List> 
  [246] = Rule_PkgList_Comma,

  -- 247. <Pkg List> ::= <Pkg> 
  [247] = Rule_PkgList,

  -- 248. <If Stm> ::= if <Expr> <Block> <else-if> 
  [248] = Rule_IfStm_if,

  -- 249. <else-if> ::= else if <Expr> <Block> <else-if> 
  [249] = Rule_elseif_else_if,

  -- 250. <else-if> ::= else <Block> 
  [250] = Rule_elseif_else,

  -- 251. <else-if> ::=  
  [251] = Rule_elseif,

  -- 252. <Normal Stm> ::= do <Block> while <Expr> 
  [252] = Rule_NormalStm_do_while,

  -- 253. <Normal Stm> ::= match <Expr> '{' <Case Stms> '}' 
  [253] = Rule_NormalStm_match_LBrace_RBrace,

  -- 254. <Normal Stm> ::= <Block> 
  [254] = Rule_NormalStm,

  -- 255. <Normal Stm> ::= <Expr> 
  [255] = Rule_NormalStm2,

  -- 256. <Normal Stm> ::= break 
  [256] = Rule_NormalStm_break,

  -- 257. <Normal Stm> ::= continue 
  [257] = Rule_NormalStm_continue,

  -- 258. <Normal Stm> ::= return <Expr> 
  [258] = Rule_NormalStm_return,

  -- 259. <Normal Stm> ::= return 
  [259] = Rule_NormalStm_return2,

  -- 260. <Normal Stm> ::= ';' 
  [260] = Rule_NormalStm_Semi,

  -- 261. <Arg> ::= <Expr> 
  [261] = Rule_Arg,

  -- 262. <Arg> ::=  
  [262] = Rule_Arg2,

  -- 263. <Case Stms> ::= case <Expr> when <Expr> <Block> <Case Stms> 
  [263] = Rule_CaseStms_case_when,

  -- 264. <Case Stms> ::= case <Expr> <Block> <Case Stms> 
  [264] = Rule_CaseStms_case,

  -- 265. <Case Stms> ::= else <Block> 
  [265] = Rule_CaseStms_else,

  -- 266. <Block> ::= '{' <Using Stms> <Stm List> '}' 
  [266] = Rule_Block_LBrace_RBrace,

  -- 267. <Block> ::= synchronized '{' <Using Stms> <Stm List> '}' 
  [267] = Rule_Block_synchronized_LBrace_RBrace,

  -- 268. <Stm List> ::= <Stm> <Stm List> 
  [268] = Rule_StmList,

  -- 269. <Stm List> ::=  
  [269] = Rule_StmList2,

  -- 270. <CSE> ::= <Expr> 
  [270] = Rule_CSE,

  -- 271. <CSE> ::= <CSE> ',' <Expr> 
  [271] = Rule_CSE_Comma,

  -- 272. <Expr> ::= <Var Decl> in <Expr> 
  [272] = Rule_Expr_in,

  -- 273. <Expr> ::= match <Expr> '{' <Case Exprs> '}' 
  [273] = Rule_Expr_match_LBrace_RBrace,

  -- 274. <Expr> ::= <Op Assign> 
  [274] = Rule_Expr,

  -- 275. <Op Assign> ::= <Op Or> '=' <Op Assign> 
  [275] = Rule_OpAssign_Eq,

  -- 276. <Op Assign> ::= <Op Or> '+=' <Op Assign> 
  [276] = Rule_OpAssign_PlusEq,

  -- 277. <Op Assign> ::= <Op Or> '-=' <Op Assign> 
  [277] = Rule_OpAssign_MinusEq,

  -- 278. <Op Assign> ::= <Op Or> '*=' <Op Assign> 
  [278] = Rule_OpAssign_TimesEq,

  -- 279. <Op Assign> ::= <Op Or> '/=' <Op Assign> 
  [279] = Rule_OpAssign_DivEq,

  -- 280. <Op Assign> ::= <Op Or> '%=' <Op Assign> 
  [280] = Rule_OpAssign_PercentEq,

  -- 281. <Op Assign> ::= <Op Or> '^=' <Op Assign> 
  [281] = Rule_OpAssign_CaretEq,

  -- 282. <Op Assign> ::= <Op Or> '&=' <Op Assign> 
  [282] = Rule_OpAssign_AmpEq,

  -- 283. <Op Assign> ::= <Op Or> '|=' <Op Assign> 
  [283] = Rule_OpAssign_PipeEq,

  -- 284. <Op Assign> ::= <Op Or> '>>=' <Op Assign> 
  [284] = Rule_OpAssign_GtGtEq,

  -- 285. <Op Assign> ::= <Op Or> '<<=' <Op Assign> 
  [285] = Rule_OpAssign_LtLtEq,

  -- 286. <Op Assign> ::= <Op Or> 
  [286] = Rule_OpAssign,

  -- 287. <Op Or> ::= <Op Or> '||' <Op And> 
  [287] = Rule_OpOr_PipePipe,

  -- 288. <Op Or> ::= <Op And> 
  [288] = Rule_OpOr,

  -- 289. <Op And> ::= <Op And> '&&' <Op BinOR> 
  [289] = Rule_OpAnd_AmpAmp,

  -- 290. <Op And> ::= <Op BinOR> 
  [290] = Rule_OpAnd,

  -- 291. <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> 
  [291] = Rule_OpBinOR_Pipe,

  -- 292. <Op BinOR> ::= <Op BinXOR> 
  [292] = Rule_OpBinOR,

  -- 293. <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> 
  [293] = Rule_OpBinXOR_Caret,

  -- 294. <Op BinXOR> ::= <Op BinAND> 
  [294] = Rule_OpBinXOR,

  -- 295. <Op BinAND> ::= <Op BinAND> '&' <Op Equate> 
  [295] = Rule_OpBinAND_Amp,

  -- 296. <Op BinAND> ::= <Op Equate> 
  [296] = Rule_OpBinAND,

  -- 297. <Op Equate> ::= <Op Equate> '==' <Op Compare> 
  [297] = Rule_OpEquate_EqEq,

  -- 298. <Op Equate> ::= <Op Equate> '!=' <Op Compare> 
  [298] = Rule_OpEquate_ExclamEq,

  -- 299. <Op Equate> ::= <Op Compare> 
  [299] = Rule_OpEquate,

  -- 300. <Op Compare> ::= <Op Compare> '<' <Op Shift> 
  [300] = Rule_OpCompare_Lt,

  -- 301. <Op Compare> ::= <Op Compare> '>' <Op Shift> 
  [301] = Rule_OpCompare_Gt,

  -- 302. <Op Compare> ::= <Op Compare> '<=' <Op Shift> 
  [302] = Rule_OpCompare_LtEq,

  -- 303. <Op Compare> ::= <Op Compare> '>=' <Op Shift> 
  [303] = Rule_OpCompare_GtEq,

  -- 304. <Op Compare> ::= <Op Compare> is <Type> 
  [304] = Rule_OpCompare_is,

  -- 305. <Op Compare> ::= <Op Shift> 
  [305] = Rule_OpCompare,

  -- 306. <Op Shift> ::= <Op Shift> '<<' <Op Add> 
  [306] = Rule_OpShift_LtLt,

  -- 307. <Op Shift> ::= <Op Shift> '>>' <Op Add> 
  [307] = Rule_OpShift_GtGt,

  -- 308. <Op Shift> ::= <Op Add> 
  [308] = Rule_OpShift,

  -- 309. <Op Add> ::= <Op Add> '+' <Op Mult> 
  [309] = Rule_OpAdd_Plus,

  -- 310. <Op Add> ::= <Op Add> '-' <Op Mult> 
  [310] = Rule_OpAdd_Minus,

  -- 311. <Op Add> ::= <Op Mult> 
  [311] = Rule_OpAdd,

  -- 312. <Op Mult> ::= <Op Mult> '*' <Op Unary> 
  [312] = Rule_OpMult_Times,

  -- 313. <Op Mult> ::= <Op Mult> '/' <Op Unary> 
  [313] = Rule_OpMult_Div,

  -- 314. <Op Mult> ::= <Op Mult> '%' <Op Unary> 
  [314] = Rule_OpMult_Percent,

  -- 315. <Op Mult> ::= <Op Unary> 
  [315] = Rule_OpMult,

  -- 316. <Op Unary> ::= '!' <Op Unary> 
  [316] = Rule_OpUnary_Exclam,

  -- 317. <Op Unary> ::= '~' <Op Unary> 
  [317] = Rule_OpUnary_Tilde,

  -- 318. <Op Unary> ::= '-' <Op Unary> 
  [318] = Rule_OpUnary_Minus,

  -- 319. <Op Unary> ::= '++' <Op Unary> 
  [319] = Rule_OpUnary_PlusPlus,

  -- 320. <Op Unary> ::= '--' <Op Unary> 
  [320] = Rule_OpUnary_MinusMinus,

  -- 321. <Op Unary> ::= <Op Pointer> '++' 
  [321] = Rule_OpUnary_PlusPlus2,

  -- 322. <Op Unary> ::= <Op Pointer> '--' 
  [322] = Rule_OpUnary_MinusMinus2,

  -- 323. <Op Unary> ::= <Op Unary> as <Type> 
  [323] = Rule_OpUnary_as,

  -- 324. <Op Unary> ::= <New Expr> 
  [324] = Rule_OpUnary,

  -- 325. <Op Unary> ::= delete <Op Pointer> 
  [325] = Rule_OpUnary_delete,

  -- 326. <Op Unary> ::= sizeof '(' <Type> ')' 
  [326] = Rule_OpUnary_sizeof_LParen_RParen,

  -- 327. <Op Unary> ::= <Op Pointer> 
  [327] = Rule_OpUnary2,

  -- 328. <Op Pointer> ::= <Op Pointer> '.' <Value> 
  [328] = Rule_OpPointer_Dot,

  -- 329. <Op Pointer> ::= <Op Pointer> '[' <CSE> ']' 
  [329] = Rule_OpPointer_LBracket_RBracket,

  -- 330. <Op Pointer> ::= <Op Pointer> '(' <CSE> ')' 
  [330] = Rule_OpPointer_LParen_RParen,

  -- 331. <Op Pointer> ::= <Op Pointer> '(' ')' 
  [331] = Rule_OpPointer_LParen_RParen2,

  -- 332. <Op Pointer> ::= <Value> 
  [332] = Rule_OpPointer,

  -- 333. <Value> ::= OctLiteral 
  [333] = Rule_Value_OctLiteral,

  -- 334. <Value> ::= HexLiteral 
  [334] = Rule_Value_HexLiteral,

  -- 335. <Value> ::= DecLiteral 
  [335] = Rule_Value_DecLiteral,

  -- 336. <Value> ::= BinLiteral 
  [336] = Rule_Value_BinLiteral,

  -- 337. <Value> ::= StringLiteral 
  [337] = Rule_Value_StringLiteral,

  -- 338. <Value> ::= CharLiteral 
  [338] = Rule_Value_CharLiteral,

  -- 339. <Value> ::= FloatLiteral 
  [339] = Rule_Value_FloatLiteral,

  -- 340. <Value> ::= null 
  [340] = Rule_Value_null,

  -- 341. <Value> ::= '_' 
  [341] = Rule_Value__,

  -- 342. <Value> ::= true 
  [342] = Rule_Value_true,

  -- 343. <Value> ::= false 
  [343] = Rule_Value_false,

  -- 344. <Value> ::= <Pkg> 
  [344] = Rule_Value,

  -- 345. <Value> ::= <Lambda Expr> 
  [345] = Rule_Value2,

  -- 346. <Value> ::= '(' <CSE> ')' 
  [346] = Rule_Value_LParen_RParen,

  -- 347. <Value> ::= '[' for Id ':' <Type> in <Expr> '=>' <Expr> ']' 
  [347] = Rule_Value_LBracket_for_Id_Colon_in_EqGt_RBracket,

  -- 348. <Value> ::= '[' for Id in <Expr> '=>' <Expr> ']' 
  [348] = Rule_Value_LBracket_for_Id_in_EqGt_RBracket,

  -- 349. <Value> ::= '[' for Id ':' <Type> in <Expr> if <Expr> '=>' <Expr> ']' 
  [349] = Rule_Value_LBracket_for_Id_Colon_in_if_EqGt_RBracket,

  -- 350. <Value> ::= '[' for Id in <Expr> if <Expr> '=>' <Expr> ']' 
  [350] = Rule_Value_LBracket_for_Id_in_if_EqGt_RBracket,

  -- 351. <Value> ::= '[' <CSE> ']' 
  [351] = Rule_Value_LBracket_RBracket,

  -- 352. <Lambda Expr> ::= lambda '(' <Params> ')' <Block> 
  [352] = Rule_LambdaExpr_lambda_LParen_RParen,

  -- 353. <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> 
  [353] = Rule_LambdaExpr_lambda_LParen_RParen_Eq,

  -- 354. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> 
  [354] = Rule_LambdaExpr_lambda_LParen_RParen_MinusGt,

  -- 355. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> 
  [355] = Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq,

  -- 356. <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> 
  [356] = Rule_CaseExprs_case_when_EqGt,

  -- 357. <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> 
  [357] = Rule_CaseExprs_case_EqGt,

  -- 358. <Case Exprs> ::= else '=>' <Expr> 
  [358] = Rule_CaseExprs_else_EqGt,

  -- 359. <New Expr> ::= new <Pkg Template> '(' ')' 
  [359] = Rule_NewExpr_new_LParen_RParen,

  -- 360. <New Expr> ::= new <Pkg Template> '(' <Expr> ')' 
  [360] = Rule_NewExpr_new_LParen_RParen2,

  -- 361. <New Expr> ::= new <Pkg Template> '(' ')' '{' <CDecl> '}' 
  [361] = Rule_NewExpr_new_LParen_RParen_LBrace_RBrace,

  -- 362. <New Expr> ::= new <Pkg Template> '(' <Expr> ')' '{' <CDecl> '}' 
  [362] = Rule_NewExpr_new_LParen_RParen_LBrace_RBrace2,

  -- 363. <New Expr> ::= new <Type> 
  [363] = Rule_NewExpr_new,

  -- 364. <New Expr> ::= new <Type> '[' <Expr> ']' 
  [364] = Rule_NewExpr_new_LBracket_RBracket 
}

function parseExpr(i, token, parent)
  assert(token.tokens ~= nil)
  assert(i > 0)
  assert(i <= #token.tokens)

  ruleJumpTable[token.tokens[i].rule](token.tokens[i], parent)
end

local token = expr

local parent = {
  type = "package",
  name = "_G",

  -- first things first
  imports = {},
  usings = {},


  funcs = {},
  classes = {},
  enums = {},
  vars = {},
  externFuncs = {},
}

function dumpImport(import)
  for _, v in ipairs(import) do
    io.write(v..".")
  end
  io.write("\n")
end

ruleJumpTable[token.rule](token, parent)