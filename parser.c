/*

This file was generated by the "C - Kessels engine template.c" template.

*/


#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>                  /* wchar_t */
#include <sys/stat.h>

#include "engine.h"                 /* The Kessels engine. */
#include "grammar.h"                /* Generated by GOLD. */



#define TRIMREDUCTIONS 0            /* 0=off, 1=on */
#define DEBUG          1            /* 0=off, 1=on */




/* Struct for transporting data between rules. Add whatever you need.
   Note: you could also use global variables to store stuff, but using
   a struct like this makes the interpreter thread-safe. */
struct ContextStruct {
  wchar_t *ReturnValue;             /* In this template all rules return a string. */
  int Indent;                       /* For printing debug messages. */
  int Debug;                        /* 0=off, 1=on */
  };




/* Forward definition of the RuleJumpTable. It will be filled with a link
   to a subroutine for every rule later on. */
void (*RuleJumpTable[])(struct TokenStruct *Token, struct ContextStruct *Context);




/***** Helper subroutines ***************************************************/




/* Make a readable copy of a string. All characters outside 32...127 are
   displayed as a HEX number in square brackets, for example "[0A]". */
void ReadableString(wchar_t *Input, wchar_t *Output, long Width) {
  char s1[BUFSIZ];
  long i1;
  long i2;

  /* Sanity check. */
  if ((Output == NULL) || (Width < 1)) return;
  Output[0] = 0;
  if (Input == NULL) return;

  i1 = 0;
  i2 = 0;
  while ((i2 < Width - 1) && (Input[i1] != 0)) {
    if ((Input[i1] >= 32) && (Input[i1] <= 127)) {
        Output[i2++] = Input[i1];
      } else {
        if (Width - i2 > 4) {
          sprintf(s1,"          Output[i2++] = '[';
          Output[i2++] = s1[0];
          Output[i2++] = s1[1];
          Output[i2++] = ']';
          }
        }
    i1++;
    }
  Output[i2] = 0;
  }




void ShowIndent(int Indent) {
  int i;
  for (i = 0; i < Indent; i++) fprintf(stdout,"  ");
  }




/***** Rule subroutine template *********************************************/




/* This subroutine is a template of things that can happen in the
   subroutine of a rule. It shows how to access the value of symbols
   and how to call rules, and how to transport results and stuff via
   the Context.

   For example the rule:

     <Increment> ::= <Expression> '+' Number

   Has 3 sub-tokens:

     Token->Tokens[0] = token for <Expression>, a rule
     Token->Tokens[1] = token for '+', a symbol
     Token->Tokens[2] = token for Number, a symbol

   We know Token->Tokens[0] is a rule, because that's what the grammar
   says. We may assume that the engine has fully populated the sub-tokens
   and don't have to perform any checks. We can immediately call the
   subroutine of the rule, like this:

     RuleJumpTable[Token->Tokens[0]->ReductionRule](Token->Tokens[0],Context);

   The subroutine should hand back it's results via the Context. Here
   is an example of how to store a result in the context:

     Context->ReturnValue = (wchar_t *)wcsdup(....);

   Symbols are literal strings from the input (that was parsed by the
   engine), stored in the sub-token. We can get the value of the "Number"
   symbol like this:

     Value = (wchar_t *)wcsdup(Token->Tokens[2]->Data);

   Further reading:
   - See "engine.h" for the definition of the TokenStruct.
   - See "readme.txt" for a short discussion on how to use the content
     of a Token.
   - See "example4.c" for a working template example.
   */

void RuleTemplate(struct TokenStruct *Token, struct ContextStruct *Context) {
  int i;

  /* Debugging: show the description of the rule. */
  if (Context->Debug > 0) {
    ShowIndent(Context->Indent);
    fprintf(stdout,"Executing rule:     }

  /* For all the sub-Tokens. */
  for (i = 0; i < Grammar.RuleArray[Token->ReductionRule].SymbolsCount; i++) {
    /* See if the Token is a Symbol or a Rule. */
    if (Token->Tokens[i]->ReductionRule < 0) {
        /* It's a Symbol. Make a copy of the Data. Most symbols are grammar,
           for example '+', 'function', 'while', and such, and you won't
           need to look at the Data. Other symbols are literals from the input
           script, for example numbers, strings, variable names, and such. */
        if (Context->ReturnValue != NULL) free(Context->ReturnValue);
        Context->ReturnValue = (wchar_t *)wcsdup(Token->Tokens[i]->Data);

        /* Debugging: show a description of the Symbol, and it's value. */
        if (Context->Debug > 0) {
          ShowIndent(Context->Indent + 1);
          fprintf(stdout,"Token[s') = '            Grammar.SymbolArray[Token->Tokens[i]->Symbol].Name,
            Context->ReturnValue);
          }

      } else {
        /* It's a rule. */

        /* Debugging: show a description of the rule. */
        if (Context->Debug > 0) {
          ShowIndent(Context->Indent + 1);
          fprintf(stdout,"Token[s\n",i,
            Grammar.RuleArray[Token->Tokens[i]->ReductionRule].Description);
          }

        /* Call the rule's subroutine via the RuleJumpTable. */
        Context->Indent = Context->Indent + 1;
        RuleJumpTable[Token->Tokens[i]->ReductionRule](Token->Tokens[i],Context);
        Context->Indent = Context->Indent - 1;

        /* At this point you will probably want to save the Context->ReturnValue
           somewhere. */

        /* Debugging: show the value that was returned by the rule's subroutine. */
        if (Context->Debug > 0) {
          ShowIndent(Context->Indent + 2);
          fprintf(stdout,"Result value =           }
        }
    }

  /* Do whatever processing is needed by the rule. Remember to free() the
     Values you have saved. */
  }




/***** Rule subroutines *****************************************************/




/* <Decls> ::= <Imports> <Using Stms> <Decl List> */
void Rule_Decls(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decls> ::=  */
void Rule_Decls2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl List> ::= <Decl> <Decl List> */
void Rule_DeclList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl List> ::= <Decl> */
void Rule_DeclList2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Func Decl> */
void Rule_Decl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Class Decl> */
void Rule_Decl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Enum Decl> */
void Rule_Decl3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= extern type Id */
void Rule_Decl_extern_type_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= local extern type Id */
void Rule_Decl_local_extern_type_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= extern local type Id */
void Rule_Decl_extern_local_type_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <Var Decl> */
void Rule_Decl4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <CDefFunc Decl> */
void Rule_Decl5(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Imports> ::= <Import> <Imports> */
void Rule_Imports(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Imports> ::=  */
void Rule_Imports2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= import <File Path All> */
void Rule_Import_import(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= import <File Path> as Id */
void Rule_Import_import_as_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import> ::= from <File Path> import <File Path List> */
void Rule_Import_from_import(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path> ::= Id '.' <File Path> */
void Rule_FilePath_Id_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path> ::= Id */
void Rule_FilePath_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path All> ::= Id '.' <File Path All> */
void Rule_FilePathAll_Id_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path All> ::= Id '.*' */
void Rule_FilePathAll_Id_DotTimes(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path All> ::= Id */
void Rule_FilePathAll_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path List> ::= <File Path> ',' <File Path List> */
void Rule_FilePathList_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <File Path List> ::= <File Path> */
void Rule_FilePathList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Params> ')' */
void Rule_FnHeaderProto_Id_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Params> ')' '->' <Type> */
void Rule_FnHeaderProto_Id_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Types> ')' */
void Rule_FnHeaderProto_Id_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' <Types> ')' '->' <Type> */
void Rule_FnHeaderProto_Id_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' ')' */
void Rule_FnHeaderProto_Id_LParen_RParen3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Proto> ::= Id '(' ')' '->' <Type> */
void Rule_FnHeaderProto_Id_LParen_RParen_MinusGt3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' <Params> ')' */
void Rule_FnHeaderImpl_Id_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' <Params> ')' '->' <Type> */
void Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' ')' */
void Rule_FnHeaderImpl_Id_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Header Impl> ::= Id '(' ')' '->' <Type> */
void Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= local function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_local_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= synchronized function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_synchronized_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= synchronized local function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_synchronized_local_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= local synchronized function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_local_synchronized_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= pure function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_pure_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= local pure function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_local_pure_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Decl> ::= pure local function <Fn Header Impl> <Func Body> */
void Rule_FuncDecl_pure_local_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Body> ::= '=' <Expr> */
void Rule_FuncBody_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Body> ::= <Block> */
void Rule_FuncBody(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= function <Fn Header Proto> */
void Rule_CFuncProto_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure function <Fn Header Proto> */
void Rule_CFuncProto_pure_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static function <Fn Header Proto> */
void Rule_CFuncProto_static_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Visibility> function <Fn Header Proto> */
void Rule_CFuncProto_function2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= inherited function <Fn Header Proto> */
void Rule_CFuncProto_inherited_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure static function <Fn Header Proto> */
void Rule_CFuncProto_pure_static_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure <Visibility> function <Fn Header Proto> */
void Rule_CFuncProto_pure_function2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure inherited function <Fn Header Proto> */
void Rule_CFuncProto_pure_inherited_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static pure <Fn Header Proto> */
void Rule_CFuncProto_static_pure(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static <Visibility> <Fn Header Proto> */
void Rule_CFuncProto_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static inherited <Fn Header Proto> */
void Rule_CFuncProto_static_inherited(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Visibility> pure <Fn Header Proto> */
void Rule_CFuncProto_pure(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Visibility> static <Fn Header Proto> */
void Rule_CFuncProto_static2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= <Visibility> inherited <Fn Header Proto> */
void Rule_CFuncProto_inherited(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= inherited pure <Fn Header Proto> */
void Rule_CFuncProto_inherited_pure(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= inherited <Visibility> <Fn Header Proto> */
void Rule_CFuncProto_inherited2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= inherited static <Fn Header Proto> */
void Rule_CFuncProto_inherited_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure static <Visibility> <Fn Header Proto> */
void Rule_CFuncProto_pure_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure <Visibility> static <Fn Header Proto> */
void Rule_CFuncProto_pure_static2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure <Visibility> inherited <Fn Header Proto> */
void Rule_CFuncProto_pure_inherited(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= pure inherited <Visibility> <Fn Header Proto> */
void Rule_CFuncProto_pure_inherited2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static pure <Visibility> <Fn Header Proto> */
void Rule_CFuncProto_static_pure2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static <Visibility> pure <Fn Header Proto> */
void Rule_CFuncProto_static_pure3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static <Visibility> inherited <Fn Header Proto> */
void Rule_CFuncProto_static_inherited2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= static inherited <Visibility> <Fn Header Proto> */
void Rule_CFuncProto_static_inherited3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= inherited <Visibility> pure <Fn Header Proto> */
void Rule_CFuncProto_inherited_pure2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= inherited pure <Visibility> <Fn Header Proto> */
void Rule_CFuncProto_inherited_pure3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Proto> ::= inherited pure static <Fn Header Proto> */
void Rule_CFuncProto_inherited_pure_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CFunc Decl> ::= <CFunc Proto> <Func Body> */
void Rule_CFuncDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_extern_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= extern pure function <Fn Header Proto> */
void Rule_CDefFuncDecl_extern_pure_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= extern local function <Fn Header Proto> */
void Rule_CDefFuncDecl_extern_local_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= local extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_local_extern_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= local pure extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_local_pure_extern_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= local extern pure function <Fn Header Proto> */
void Rule_CDefFuncDecl_local_extern_pure_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= pure extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_pure_extern_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= pure local extern function <Fn Header Proto> */
void Rule_CDefFuncDecl_pure_local_extern_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefFunc Decl> ::= pure extern local function <Fn Header Proto> */
void Rule_CDefFuncDecl_pure_extern_local_function(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Visibility> ::= public */
void Rule_Visibility_public(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Visibility> ::= private */
void Rule_Visibility_private(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Visibility> ::= protected */
void Rule_Visibility_protected(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Params> ::= <Param> ',' <Params> */
void Rule_Params_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Params> ::= <Param> */
void Rule_Params(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Param> ::= final Id ':' <Type> */
void Rule_Param_final_Id_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Param> ::= Id ':' <Type> */
void Rule_Param_Id_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Types> ::= <Type> ',' <Types> */
void Rule_Types_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Types> ::= <Type> */
void Rule_Types(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Id List> ::= Id ',' <Id List> */
void Rule_IdList_Id_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Id List> ::= Id */
void Rule_IdList_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= <Normal Class> */
void Rule_ClassDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= <Abstract Class> */
void Rule_ClassDecl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= local <Normal Class> */
void Rule_ClassDecl_local(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= local <Abstract Class> */
void Rule_ClassDecl_local2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Class> ::= class <Class Name> '{' <CDecls> '}' */
void Rule_NormalClass_class_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Class> ::= class <Class Name> extends <Extend Class Name List> '{' <CDecls> '}' */
void Rule_NormalClass_class_extends_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Abstract Class> ::= abstract class <Class Name> '{' <ACDecls> '}' */
void Rule_AbstractClass_abstract_class_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Abstract Class> ::= abstract class <Class Name> extends <Extend Class Name List> '{' <ACDecls> '}' */
void Rule_AbstractClass_abstract_class_extends_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Name> ::= Id */
void Rule_ClassName_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Name> ::= Id '<' <Id List> '>' */
void Rule_ClassName_Id_Lt_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name List> ::= <Extend Class Name> ',' <Extend Class Name List> */
void Rule_ExtendClassNameList_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name List> ::= <Extend Class Name> */
void Rule_ExtendClassNameList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name> ::= <Pkg> */
void Rule_ExtendClassName(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Extend Class Name> ::= <Pkg> '<' <Extend Class Name List> '>' */
void Rule_ExtendClassName_Lt_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecls> ::= <CDecl> <CDecls> */
void Rule_CDecls(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecls> ::=  */
void Rule_CDecls2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecls> ::= <ACDecl> <ACDecls> */
void Rule_ACDecls(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecls> ::=  */
void Rule_ACDecls2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <CFunc Decl> */
void Rule_CDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <CVar Decl> */
void Rule_CDecl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDecl> ::= <Operator Impl> */
void Rule_CDecl3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CFunc Decl> */
void Rule_ACDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CFunc Proto> */
void Rule_ACDecl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <CVar Decl> */
void Rule_ACDecl3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <Operator Impl> */
void Rule_ACDecl4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <ACDecl> ::= <Operator Proto> */
void Rule_ACDecl5(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator Impl> ::= operator <Operator> <Op Header Impl> '=' <Expr> */
void Rule_OperatorImpl_operator_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator Impl> ::= operator <Operator> <Op Header Impl> <Block> */
void Rule_OperatorImpl_operator(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator Proto> ::= operator <Operator> <Op Header Proto> */
void Rule_OperatorProto_operator(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CDefStruct> ::= extern struct Id '{' <Params> '}' */
void Rule_CDefStruct_extern_struct_Id_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '+' */
void Rule_Operator_Plus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '-' */
void Rule_Operator_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '*' */
void Rule_Operator_Times(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '/' */
void Rule_Operator_Div(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '%' */
void Rule_Operator_Percent(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '^' */
void Rule_Operator_Caret(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&' */
void Rule_Operator_Amp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '|' */
void Rule_Operator_Pipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '~' */
void Rule_Operator_Tilde(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '!' */
void Rule_Operator_Exclam(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '=' */
void Rule_Operator_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<' */
void Rule_Operator_Lt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>' */
void Rule_Operator_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '+=' */
void Rule_Operator_PlusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '-=' */
void Rule_Operator_MinusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '*=' */
void Rule_Operator_TimesEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '/=' */
void Rule_Operator_DivEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '%=' */
void Rule_Operator_PercentEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '^=' */
void Rule_Operator_CaretEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&=' */
void Rule_Operator_AmpEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '|=' */
void Rule_Operator_PipeEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<<' */
void Rule_Operator_LtLt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>>' */
void Rule_Operator_GtGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>>=' */
void Rule_Operator_GtGtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<<=' */
void Rule_Operator_LtLtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '==' */
void Rule_Operator_EqEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '!=' */
void Rule_Operator_ExclamEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '<=' */
void Rule_Operator_LtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '>=' */
void Rule_Operator_GtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '&&' */
void Rule_Operator_AmpAmp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '||' */
void Rule_Operator_PipePipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '++' */
void Rule_Operator_PlusPlus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '--' */
void Rule_Operator_MinusMinus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= ',' */
void Rule_Operator_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '(' ')' */
void Rule_Operator_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Operator> ::= '[' ']' */
void Rule_Operator_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Params> ')' */
void Rule_OpHeaderProto_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Params> ')' '->' <Type> */
void Rule_OpHeaderProto_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Types> ')' */
void Rule_OpHeaderProto_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' <Types> ')' '->' <Type> */
void Rule_OpHeaderProto_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' ')' */
void Rule_OpHeaderProto_LParen_RParen3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Proto> ::= '(' ')' '->' <Type> */
void Rule_OpHeaderProto_LParen_RParen_MinusGt3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' <Params> ')' */
void Rule_OpHeaderImpl_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' <Params> ')' '->' <Type> */
void Rule_OpHeaderImpl_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' ')' */
void Rule_OpHeaderImpl_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Header Impl> ::= '(' ')' '->' <Type> */
void Rule_OpHeaderImpl_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let final <Var Header> */
void Rule_VarDecl_let_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let <Var Header> */
void Rule_VarDecl_let(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let local <Var Header> */
void Rule_VarDecl_let_local(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let local final <Var Header> */
void Rule_VarDecl_let_local_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let final local <Var Header> */
void Rule_VarDecl_let_final_local(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let atomic <Var Header> */
void Rule_VarDecl_let_atomic(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let local atomic <Var Header> */
void Rule_VarDecl_let_local_atomic(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl> ::= let atomic local <Var Header> */
void Rule_VarDecl_let_atomic_local(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Var Header> */
void Rule_CVarDecl_let(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let final <Var Header> */
void Rule_CVarDecl_let_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let final static <Var Header> */
void Rule_CVarDecl_let_final_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let final <Visibility> <Var Header> */
void Rule_CVarDecl_let_final2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let final <Visibility> static <Var Header> */
void Rule_CVarDecl_let_final_static2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let final static <Visibility> <Var Header> */
void Rule_CVarDecl_let_final_static3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static <Var Header> */
void Rule_CVarDecl_let_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static final <Var Header> */
void Rule_CVarDecl_let_static_final(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static atomic <Var Header> */
void Rule_CVarDecl_let_static_atomic(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static <Visibility> <Var Header> */
void Rule_CVarDecl_let_static2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static <Visibility> atomic <Var Header> */
void Rule_CVarDecl_let_static_atomic2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static <Visibility> final <Var Header> */
void Rule_CVarDecl_let_static_final2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let static atomic <Visibility> <Var Header> */
void Rule_CVarDecl_let_static_atomic3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> <Var Header> */
void Rule_CVarDecl_let2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> static <Var Header> */
void Rule_CVarDecl_let_static3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> static atomic <Var Header> */
void Rule_CVarDecl_let_static_atomic4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> final <Var Header> */
void Rule_CVarDecl_let_final3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> static final <Var Header> */
void Rule_CVarDecl_let_static_final3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> final static <Var Header> */
void Rule_CVarDecl_let_final_static4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let <Visibility> atomic static */
void Rule_CVarDecl_let_atomic_static(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let atomic <Var Header> */
void Rule_CVarDecl_let_atomic(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let atomic <Visibility> <Var Header> */
void Rule_CVarDecl_let_atomic2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let atomic static <Var Header> */
void Rule_CVarDecl_let_atomic_static2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let atomic <Visibility> static <Var Header> */
void Rule_CVarDecl_let_atomic_static3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CVar Decl> ::= let atomic static <Visibility> <Var Header> */
void Rule_CVarDecl_let_atomic_static4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> ':' <Type> '=' <CSE> */
void Rule_VarHeader_Colon_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> ':' <Type> */
void Rule_VarHeader_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Header> ::= <Id List> '=' <CSE> */
void Rule_VarHeader_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Decl> ::= enum Id '{' <Enum Def> '}' */
void Rule_EnumDecl_enum_Id_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Decl> ::= local enum Id '{' <Enum Def> '}' */
void Rule_EnumDecl_local_enum_Id_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Def> ::= Id ',' <Enum Def> */
void Rule_EnumDef_Id_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Def> ::= Id */
void Rule_EnumDef_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Base> */
void Rule_Type(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Fn Type> */
void Rule_Type2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Pkg Template> */
void Rule_Type3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Type> '[' ']' */
void Rule_Type_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= '(' <Types> ')' */
void Rule_Type_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' ')' */
void Rule_FnType_fn_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' ')' '->' <Type> */
void Rule_FnType_fn_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' <Types> ')' */
void Rule_FnType_fn_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' <Types> ')' '->' <Type> */
void Rule_FnType_fn_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg Template> ::= <Pkg> */
void Rule_PkgTemplate(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg Template> ::= <Pkg> '<' <Types> '>' */
void Rule_PkgTemplate_Lt_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= <Sign> <Scalar> */
void Rule_Base(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'size_t' */
void Rule_Base_size_t(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= byte */
void Rule_Base_byte(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= float */
void Rule_Base_float(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= double */
void Rule_Base_double(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= bool */
void Rule_Base_bool(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= long double */
void Rule_Base_long_double(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::= signed */
void Rule_Sign_signed(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::= unsigned */
void Rule_Sign_unsigned(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Sign> ::=  */
void Rule_Sign(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= char */
void Rule_Scalar_char(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= int */
void Rule_Scalar_int(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= short */
void Rule_Scalar_short(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= long */
void Rule_Scalar_long(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= short int */
void Rule_Scalar_short_int(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Scalar> ::= long int */
void Rule_Scalar_long_int(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <Var Decl> */
void Rule_Stm(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <If Stm> */
void Rule_Stm2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= while <Expr> <Block> */
void Rule_Stm_while(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= for <Arg> ';' <Arg> ';' <Arg> <Block> */
void Rule_Stm_for_Semi_Semi(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= foreach <Param> in <Expr> <Block> */
void Rule_Stm_foreach_in(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm> ::= <Normal Stm> */
void Rule_Stm3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Using Stm> ::= using <Pkg> */
void Rule_UsingStm_using(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Using Stms> ::= <Using Stm> <Using Stms> */
void Rule_UsingStms(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Using Stms> ::=  */
void Rule_UsingStms2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg> ::= Id '.' <Pkg> */
void Rule_Pkg_Id_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg> ::= Id */
void Rule_Pkg_Id(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <If Stm> ::= if <Expr> <Block> <else-if> */
void Rule_IfStm_if(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::= else if <Expr> <Block> <else-if> */
void Rule_elseif_else_if(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::= else <Block> */
void Rule_elseif_else(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <else-if> ::=  */
void Rule_elseif(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= do <Block> while <Expr> */
void Rule_NormalStm_do_while(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= match <Expr> '{' <Case Stms> '}' */
void Rule_NormalStm_match_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= <Block> */
void Rule_NormalStm(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= <Expr> */
void Rule_NormalStm2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= break */
void Rule_NormalStm_break(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= continue */
void Rule_NormalStm_continue(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= return <Expr> */
void Rule_NormalStm_return(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= return */
void Rule_NormalStm_return2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Normal Stm> ::= ';' */
void Rule_NormalStm_Semi(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Arg> ::= <Expr> */
void Rule_Arg(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Arg> ::=  */
void Rule_Arg2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= case <Expr> when <Expr> <Block> <Case Stms> */
void Rule_CaseStms_case_when(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= case <Expr> <Block> <Case Stms> */
void Rule_CaseStms_case(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Stms> ::= else <Block> */
void Rule_CaseStms_else(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Block> ::= '{' <Using Stms> <Stm List> '}' */
void Rule_Block_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Block> ::= synchronized '{' <Using Stms> <Stm List> '}' */
void Rule_Block_synchronized_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm List> ::= <Stm> <Stm List> */
void Rule_StmList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stm List> ::=  */
void Rule_StmList2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CSE> ::= <Expr> */
void Rule_CSE(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <CSE> ::= <CSE> ',' <Expr> */
void Rule_CSE_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Var Decl> in <Expr> */
void Rule_Expr_in(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= match <Expr> '{' <Case Exprs> '}' */
void Rule_Expr_match_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Op Assign> */
void Rule_Expr(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '=' <Op Assign> */
void Rule_OpAssign_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '+=' <Op Assign> */
void Rule_OpAssign_PlusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '-=' <Op Assign> */
void Rule_OpAssign_MinusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '*=' <Op Assign> */
void Rule_OpAssign_TimesEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '/=' <Op Assign> */
void Rule_OpAssign_DivEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '%=' <Op Assign> */
void Rule_OpAssign_PercentEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '^=' <Op Assign> */
void Rule_OpAssign_CaretEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '&=' <Op Assign> */
void Rule_OpAssign_AmpEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '|=' <Op Assign> */
void Rule_OpAssign_PipeEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '>>=' <Op Assign> */
void Rule_OpAssign_GtGtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '<<=' <Op Assign> */
void Rule_OpAssign_LtLtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> */
void Rule_OpAssign(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Or> ::= <Op Or> '||' <Op And> */
void Rule_OpOr_PipePipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Or> ::= <Op And> */
void Rule_OpOr(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op And> ::= <Op And> '&&' <Op BinOR> */
void Rule_OpAnd_AmpAmp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op And> ::= <Op BinOR> */
void Rule_OpAnd(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> */
void Rule_OpBinOR_Pipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinOR> ::= <Op BinXOR> */
void Rule_OpBinOR(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> */
void Rule_OpBinXOR_Caret(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinXOR> ::= <Op BinAND> */
void Rule_OpBinXOR(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinAND> ::= <Op BinAND> '&' <Op Equate> */
void Rule_OpBinAND_Amp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinAND> ::= <Op Equate> */
void Rule_OpBinAND(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Equate> '==' <Op Compare> */
void Rule_OpEquate_EqEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Equate> '!=' <Op Compare> */
void Rule_OpEquate_ExclamEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Compare> */
void Rule_OpEquate(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '<' <Op Shift> */
void Rule_OpCompare_Lt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '>' <Op Shift> */
void Rule_OpCompare_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '<=' <Op Shift> */
void Rule_OpCompare_LtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '>=' <Op Shift> */
void Rule_OpCompare_GtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> is <Type> */
void Rule_OpCompare_is(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Shift> */
void Rule_OpCompare(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Shift> '<<' <Op Add> */
void Rule_OpShift_LtLt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Shift> '>>' <Op Add> */
void Rule_OpShift_GtGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Add> */
void Rule_OpShift(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Add> '+' <Op Mult> */
void Rule_OpAdd_Plus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Add> '-' <Op Mult> */
void Rule_OpAdd_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Mult> */
void Rule_OpAdd(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '*' <Op Unary> */
void Rule_OpMult_Times(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '/' <Op Unary> */
void Rule_OpMult_Div(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '%' <Op Unary> */
void Rule_OpMult_Percent(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Unary> */
void Rule_OpMult(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '!' <Op Unary> */
void Rule_OpUnary_Exclam(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '~' <Op Unary> */
void Rule_OpUnary_Tilde(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '-' <Op Unary> */
void Rule_OpUnary_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '++' <Op Unary> */
void Rule_OpUnary_PlusPlus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '--' <Op Unary> */
void Rule_OpUnary_MinusMinus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> '++' */
void Rule_OpUnary_PlusPlus2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> '--' */
void Rule_OpUnary_MinusMinus2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Unary> as <Type> */
void Rule_OpUnary_as(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <New Expr> */
void Rule_OpUnary(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= delete <Op Pointer> */
void Rule_OpUnary_delete(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= sizeof '(' <Type> ')' */
void Rule_OpUnary_sizeof_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> */
void Rule_OpUnary2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '.' <Value> */
void Rule_OpPointer_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '[' <CSE> ']' */
void Rule_OpPointer_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '(' <CSE> ')' */
void Rule_OpPointer_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '(' ')' */
void Rule_OpPointer_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Value> */
void Rule_OpPointer(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= OctLiteral */
void Rule_Value_OctLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= HexLiteral */
void Rule_Value_HexLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= DecLiteral */
void Rule_Value_DecLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= BinLiteral */
void Rule_Value_BinLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= StringLiteral */
void Rule_Value_StringLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= CharLiteral */
void Rule_Value_CharLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= FloatLiteral */
void Rule_Value_FloatLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= null */
void Rule_Value_null(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '_' */
void Rule_Value__(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= true */
void Rule_Value_true(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= false */
void Rule_Value_false(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= <Pkg> */
void Rule_Value(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= <Lambda Expr> */
void Rule_Value2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '(' <CSE> ')' */
void Rule_Value_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Id ':' <Type> in <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Id_Colon_in_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Id in <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Id_in_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Id ':' <Type> in <Expr> if <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Id_Colon_in_if_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Id in <Expr> if <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Id_in_if_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' <CSE> ']' */
void Rule_Value_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' <Block> */
void Rule_LambdaExpr_lambda_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> */
void Rule_LambdaExpr_lambda_LParen_RParen_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> */
void Rule_LambdaExpr_lambda_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> */
void Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> */
void Rule_CaseExprs_case_when_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> */
void Rule_CaseExprs_case_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= else '=>' <Expr> */
void Rule_CaseExprs_else_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Pkg Template> '(' ')' */
void Rule_NewExpr_new_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Pkg Template> '(' <Expr> ')' */
void Rule_NewExpr_new_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Pkg Template> '(' ')' '{' <CDecl> '}' */
void Rule_NewExpr_new_LParen_RParen_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Pkg Template> '(' <Expr> ')' '{' <CDecl> '}' */
void Rule_NewExpr_new_LParen_RParen_LBrace_RBrace2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> */
void Rule_NewExpr_new(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> '[' <Expr> ']' */
void Rule_NewExpr_new_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/***** Rule jumptable *******************************************************/




void (*RuleJumpTable[])(struct TokenStruct *Token, struct ContextStruct *Context) = {

  /* 0. <Decls> ::= <Imports> <Using Stms> <Decl List> */
  Rule_Decls,

  /* 1. <Decls> ::=  */
  Rule_Decls2,

  /* 2. <Decl List> ::= <Decl> <Decl List> */
  Rule_DeclList,

  /* 3. <Decl List> ::= <Decl> */
  Rule_DeclList2,

  /* 4. <Decl> ::= <Func Decl> */
  Rule_Decl,

  /* 5. <Decl> ::= <Class Decl> */
  Rule_Decl2,

  /* 6. <Decl> ::= <Enum Decl> */
  Rule_Decl3,

  /* 7. <Decl> ::= extern type Id */
  Rule_Decl_extern_type_Id,

  /* 8. <Decl> ::= local extern type Id */
  Rule_Decl_local_extern_type_Id,

  /* 9. <Decl> ::= extern local type Id */
  Rule_Decl_extern_local_type_Id,

  /* 10. <Decl> ::= <Var Decl> */
  Rule_Decl4,

  /* 11. <Decl> ::= <CDefFunc Decl> */
  Rule_Decl5,

  /* 12. <Imports> ::= <Import> <Imports> */
  Rule_Imports,

  /* 13. <Imports> ::=  */
  Rule_Imports2,

  /* 14. <Import> ::= import <File Path All> */
  Rule_Import_import,

  /* 15. <Import> ::= import <File Path> as Id */
  Rule_Import_import_as_Id,

  /* 16. <Import> ::= from <File Path> import <File Path List> */
  Rule_Import_from_import,

  /* 17. <File Path> ::= Id '.' <File Path> */
  Rule_FilePath_Id_Dot,

  /* 18. <File Path> ::= Id */
  Rule_FilePath_Id,

  /* 19. <File Path All> ::= Id '.' <File Path All> */
  Rule_FilePathAll_Id_Dot,

  /* 20. <File Path All> ::= Id '.*' */
  Rule_FilePathAll_Id_DotTimes,

  /* 21. <File Path All> ::= Id */
  Rule_FilePathAll_Id,

  /* 22. <File Path List> ::= <File Path> ',' <File Path List> */
  Rule_FilePathList_Comma,

  /* 23. <File Path List> ::= <File Path> */
  Rule_FilePathList,

  /* 24. <Fn Header Proto> ::= Id '(' <Params> ')' */
  Rule_FnHeaderProto_Id_LParen_RParen,

  /* 25. <Fn Header Proto> ::= Id '(' <Params> ')' '->' <Type> */
  Rule_FnHeaderProto_Id_LParen_RParen_MinusGt,

  /* 26. <Fn Header Proto> ::= Id '(' <Types> ')' */
  Rule_FnHeaderProto_Id_LParen_RParen2,

  /* 27. <Fn Header Proto> ::= Id '(' <Types> ')' '->' <Type> */
  Rule_FnHeaderProto_Id_LParen_RParen_MinusGt2,

  /* 28. <Fn Header Proto> ::= Id '(' ')' */
  Rule_FnHeaderProto_Id_LParen_RParen3,

  /* 29. <Fn Header Proto> ::= Id '(' ')' '->' <Type> */
  Rule_FnHeaderProto_Id_LParen_RParen_MinusGt3,

  /* 30. <Fn Header Impl> ::= Id '(' <Params> ')' */
  Rule_FnHeaderImpl_Id_LParen_RParen,

  /* 31. <Fn Header Impl> ::= Id '(' <Params> ')' '->' <Type> */
  Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt,

  /* 32. <Fn Header Impl> ::= Id '(' ')' */
  Rule_FnHeaderImpl_Id_LParen_RParen2,

  /* 33. <Fn Header Impl> ::= Id '(' ')' '->' <Type> */
  Rule_FnHeaderImpl_Id_LParen_RParen_MinusGt2,

  /* 34. <Func Decl> ::= function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_function,

  /* 35. <Func Decl> ::= local function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_local_function,

  /* 36. <Func Decl> ::= synchronized function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_synchronized_function,

  /* 37. <Func Decl> ::= synchronized local function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_synchronized_local_function,

  /* 38. <Func Decl> ::= local synchronized function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_local_synchronized_function,

  /* 39. <Func Decl> ::= pure function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_pure_function,

  /* 40. <Func Decl> ::= local pure function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_local_pure_function,

  /* 41. <Func Decl> ::= pure local function <Fn Header Impl> <Func Body> */
  Rule_FuncDecl_pure_local_function,

  /* 42. <Func Body> ::= '=' <Expr> */
  Rule_FuncBody_Eq,

  /* 43. <Func Body> ::= <Block> */
  Rule_FuncBody,

  /* 44. <CFunc Proto> ::= function <Fn Header Proto> */
  Rule_CFuncProto_function,

  /* 45. <CFunc Proto> ::= pure function <Fn Header Proto> */
  Rule_CFuncProto_pure_function,

  /* 46. <CFunc Proto> ::= static function <Fn Header Proto> */
  Rule_CFuncProto_static_function,

  /* 47. <CFunc Proto> ::= <Visibility> function <Fn Header Proto> */
  Rule_CFuncProto_function2,

  /* 48. <CFunc Proto> ::= inherited function <Fn Header Proto> */
  Rule_CFuncProto_inherited_function,

  /* 49. <CFunc Proto> ::= pure static function <Fn Header Proto> */
  Rule_CFuncProto_pure_static_function,

  /* 50. <CFunc Proto> ::= pure <Visibility> function <Fn Header Proto> */
  Rule_CFuncProto_pure_function2,

  /* 51. <CFunc Proto> ::= pure inherited function <Fn Header Proto> */
  Rule_CFuncProto_pure_inherited_function,

  /* 52. <CFunc Proto> ::= static pure <Fn Header Proto> */
  Rule_CFuncProto_static_pure,

  /* 53. <CFunc Proto> ::= static <Visibility> <Fn Header Proto> */
  Rule_CFuncProto_static,

  /* 54. <CFunc Proto> ::= static inherited <Fn Header Proto> */
  Rule_CFuncProto_static_inherited,

  /* 55. <CFunc Proto> ::= <Visibility> pure <Fn Header Proto> */
  Rule_CFuncProto_pure,

  /* 56. <CFunc Proto> ::= <Visibility> static <Fn Header Proto> */
  Rule_CFuncProto_static2,

  /* 57. <CFunc Proto> ::= <Visibility> inherited <Fn Header Proto> */
  Rule_CFuncProto_inherited,

  /* 58. <CFunc Proto> ::= inherited pure <Fn Header Proto> */
  Rule_CFuncProto_inherited_pure,

  /* 59. <CFunc Proto> ::= inherited <Visibility> <Fn Header Proto> */
  Rule_CFuncProto_inherited2,

  /* 60. <CFunc Proto> ::= inherited static <Fn Header Proto> */
  Rule_CFuncProto_inherited_static,

  /* 61. <CFunc Proto> ::= pure static <Visibility> <Fn Header Proto> */
  Rule_CFuncProto_pure_static,

  /* 62. <CFunc Proto> ::= pure <Visibility> static <Fn Header Proto> */
  Rule_CFuncProto_pure_static2,

  /* 63. <CFunc Proto> ::= pure <Visibility> inherited <Fn Header Proto> */
  Rule_CFuncProto_pure_inherited,

  /* 64. <CFunc Proto> ::= pure inherited <Visibility> <Fn Header Proto> */
  Rule_CFuncProto_pure_inherited2,

  /* 65. <CFunc Proto> ::= static pure <Visibility> <Fn Header Proto> */
  Rule_CFuncProto_static_pure2,

  /* 66. <CFunc Proto> ::= static <Visibility> pure <Fn Header Proto> */
  Rule_CFuncProto_static_pure3,

  /* 67. <CFunc Proto> ::= static <Visibility> inherited <Fn Header Proto> */
  Rule_CFuncProto_static_inherited2,

  /* 68. <CFunc Proto> ::= static inherited <Visibility> <Fn Header Proto> */
  Rule_CFuncProto_static_inherited3,

  /* 69. <CFunc Proto> ::= inherited <Visibility> pure <Fn Header Proto> */
  Rule_CFuncProto_inherited_pure2,

  /* 70. <CFunc Proto> ::= inherited pure <Visibility> <Fn Header Proto> */
  Rule_CFuncProto_inherited_pure3,

  /* 71. <CFunc Proto> ::= inherited pure static <Fn Header Proto> */
  Rule_CFuncProto_inherited_pure_static,

  /* 72. <CFunc Decl> ::= <CFunc Proto> <Func Body> */
  Rule_CFuncDecl,

  /* 73. <CDefFunc Decl> ::= extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_extern_function,

  /* 74. <CDefFunc Decl> ::= extern pure function <Fn Header Proto> */
  Rule_CDefFuncDecl_extern_pure_function,

  /* 75. <CDefFunc Decl> ::= extern local function <Fn Header Proto> */
  Rule_CDefFuncDecl_extern_local_function,

  /* 76. <CDefFunc Decl> ::= local extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_local_extern_function,

  /* 77. <CDefFunc Decl> ::= local pure extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_local_pure_extern_function,

  /* 78. <CDefFunc Decl> ::= local extern pure function <Fn Header Proto> */
  Rule_CDefFuncDecl_local_extern_pure_function,

  /* 79. <CDefFunc Decl> ::= pure extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_pure_extern_function,

  /* 80. <CDefFunc Decl> ::= pure local extern function <Fn Header Proto> */
  Rule_CDefFuncDecl_pure_local_extern_function,

  /* 81. <CDefFunc Decl> ::= pure extern local function <Fn Header Proto> */
  Rule_CDefFuncDecl_pure_extern_local_function,

  /* 82. <Visibility> ::= public */
  Rule_Visibility_public,

  /* 83. <Visibility> ::= private */
  Rule_Visibility_private,

  /* 84. <Visibility> ::= protected */
  Rule_Visibility_protected,

  /* 85. <Params> ::= <Param> ',' <Params> */
  Rule_Params_Comma,

  /* 86. <Params> ::= <Param> */
  Rule_Params,

  /* 87. <Param> ::= final Id ':' <Type> */
  Rule_Param_final_Id_Colon,

  /* 88. <Param> ::= Id ':' <Type> */
  Rule_Param_Id_Colon,

  /* 89. <Types> ::= <Type> ',' <Types> */
  Rule_Types_Comma,

  /* 90. <Types> ::= <Type> */
  Rule_Types,

  /* 91. <Id List> ::= Id ',' <Id List> */
  Rule_IdList_Id_Comma,

  /* 92. <Id List> ::= Id */
  Rule_IdList_Id,

  /* 93. <Class Decl> ::= <Normal Class> */
  Rule_ClassDecl,

  /* 94. <Class Decl> ::= <Abstract Class> */
  Rule_ClassDecl2,

  /* 95. <Class Decl> ::= local <Normal Class> */
  Rule_ClassDecl_local,

  /* 96. <Class Decl> ::= local <Abstract Class> */
  Rule_ClassDecl_local2,

  /* 97. <Normal Class> ::= class <Class Name> '{' <CDecls> '}' */
  Rule_NormalClass_class_LBrace_RBrace,

  /* 98. <Normal Class> ::= class <Class Name> extends <Extend Class Name List> '{' <CDecls> '}' */
  Rule_NormalClass_class_extends_LBrace_RBrace,

  /* 99. <Abstract Class> ::= abstract class <Class Name> '{' <ACDecls> '}' */
  Rule_AbstractClass_abstract_class_LBrace_RBrace,

  /* 100. <Abstract Class> ::= abstract class <Class Name> extends <Extend Class Name List> '{' <ACDecls> '}' */
  Rule_AbstractClass_abstract_class_extends_LBrace_RBrace,

  /* 101. <Class Name> ::= Id */
  Rule_ClassName_Id,

  /* 102. <Class Name> ::= Id '<' <Id List> '>' */
  Rule_ClassName_Id_Lt_Gt,

  /* 103. <Extend Class Name List> ::= <Extend Class Name> ',' <Extend Class Name List> */
  Rule_ExtendClassNameList_Comma,

  /* 104. <Extend Class Name List> ::= <Extend Class Name> */
  Rule_ExtendClassNameList,

  /* 105. <Extend Class Name> ::= <Pkg> */
  Rule_ExtendClassName,

  /* 106. <Extend Class Name> ::= <Pkg> '<' <Extend Class Name List> '>' */
  Rule_ExtendClassName_Lt_Gt,

  /* 107. <CDecls> ::= <CDecl> <CDecls> */
  Rule_CDecls,

  /* 108. <CDecls> ::=  */
  Rule_CDecls2,

  /* 109. <ACDecls> ::= <ACDecl> <ACDecls> */
  Rule_ACDecls,

  /* 110. <ACDecls> ::=  */
  Rule_ACDecls2,

  /* 111. <CDecl> ::= <CFunc Decl> */
  Rule_CDecl,

  /* 112. <CDecl> ::= <CVar Decl> */
  Rule_CDecl2,

  /* 113. <CDecl> ::= <Operator Impl> */
  Rule_CDecl3,

  /* 114. <ACDecl> ::= <CFunc Decl> */
  Rule_ACDecl,

  /* 115. <ACDecl> ::= <CFunc Proto> */
  Rule_ACDecl2,

  /* 116. <ACDecl> ::= <CVar Decl> */
  Rule_ACDecl3,

  /* 117. <ACDecl> ::= <Operator Impl> */
  Rule_ACDecl4,

  /* 118. <ACDecl> ::= <Operator Proto> */
  Rule_ACDecl5,

  /* 119. <Operator Impl> ::= operator <Operator> <Op Header Impl> '=' <Expr> */
  Rule_OperatorImpl_operator_Eq,

  /* 120. <Operator Impl> ::= operator <Operator> <Op Header Impl> <Block> */
  Rule_OperatorImpl_operator,

  /* 121. <Operator Proto> ::= operator <Operator> <Op Header Proto> */
  Rule_OperatorProto_operator,

  /* 122. <CDefStruct> ::= extern struct Id '{' <Params> '}' */
  Rule_CDefStruct_extern_struct_Id_LBrace_RBrace,

  /* 123. <Operator> ::= '+' */
  Rule_Operator_Plus,

  /* 124. <Operator> ::= '-' */
  Rule_Operator_Minus,

  /* 125. <Operator> ::= '*' */
  Rule_Operator_Times,

  /* 126. <Operator> ::= '/' */
  Rule_Operator_Div,

  /* 127. <Operator> ::= '%' */
  Rule_Operator_Percent,

  /* 128. <Operator> ::= '^' */
  Rule_Operator_Caret,

  /* 129. <Operator> ::= '&' */
  Rule_Operator_Amp,

  /* 130. <Operator> ::= '|' */
  Rule_Operator_Pipe,

  /* 131. <Operator> ::= '~' */
  Rule_Operator_Tilde,

  /* 132. <Operator> ::= '!' */
  Rule_Operator_Exclam,

  /* 133. <Operator> ::= '=' */
  Rule_Operator_Eq,

  /* 134. <Operator> ::= '<' */
  Rule_Operator_Lt,

  /* 135. <Operator> ::= '>' */
  Rule_Operator_Gt,

  /* 136. <Operator> ::= '+=' */
  Rule_Operator_PlusEq,

  /* 137. <Operator> ::= '-=' */
  Rule_Operator_MinusEq,

  /* 138. <Operator> ::= '*=' */
  Rule_Operator_TimesEq,

  /* 139. <Operator> ::= '/=' */
  Rule_Operator_DivEq,

  /* 140. <Operator> ::= '%=' */
  Rule_Operator_PercentEq,

  /* 141. <Operator> ::= '^=' */
  Rule_Operator_CaretEq,

  /* 142. <Operator> ::= '&=' */
  Rule_Operator_AmpEq,

  /* 143. <Operator> ::= '|=' */
  Rule_Operator_PipeEq,

  /* 144. <Operator> ::= '<<' */
  Rule_Operator_LtLt,

  /* 145. <Operator> ::= '>>' */
  Rule_Operator_GtGt,

  /* 146. <Operator> ::= '>>=' */
  Rule_Operator_GtGtEq,

  /* 147. <Operator> ::= '<<=' */
  Rule_Operator_LtLtEq,

  /* 148. <Operator> ::= '==' */
  Rule_Operator_EqEq,

  /* 149. <Operator> ::= '!=' */
  Rule_Operator_ExclamEq,

  /* 150. <Operator> ::= '<=' */
  Rule_Operator_LtEq,

  /* 151. <Operator> ::= '>=' */
  Rule_Operator_GtEq,

  /* 152. <Operator> ::= '&&' */
  Rule_Operator_AmpAmp,

  /* 153. <Operator> ::= '||' */
  Rule_Operator_PipePipe,

  /* 154. <Operator> ::= '++' */
  Rule_Operator_PlusPlus,

  /* 155. <Operator> ::= '--' */
  Rule_Operator_MinusMinus,

  /* 156. <Operator> ::= ',' */
  Rule_Operator_Comma,

  /* 157. <Operator> ::= '(' ')' */
  Rule_Operator_LParen_RParen,

  /* 158. <Operator> ::= '[' ']' */
  Rule_Operator_LBracket_RBracket,

  /* 159. <Op Header Proto> ::= '(' <Params> ')' */
  Rule_OpHeaderProto_LParen_RParen,

  /* 160. <Op Header Proto> ::= '(' <Params> ')' '->' <Type> */
  Rule_OpHeaderProto_LParen_RParen_MinusGt,

  /* 161. <Op Header Proto> ::= '(' <Types> ')' */
  Rule_OpHeaderProto_LParen_RParen2,

  /* 162. <Op Header Proto> ::= '(' <Types> ')' '->' <Type> */
  Rule_OpHeaderProto_LParen_RParen_MinusGt2,

  /* 163. <Op Header Proto> ::= '(' ')' */
  Rule_OpHeaderProto_LParen_RParen3,

  /* 164. <Op Header Proto> ::= '(' ')' '->' <Type> */
  Rule_OpHeaderProto_LParen_RParen_MinusGt3,

  /* 165. <Op Header Impl> ::= '(' <Params> ')' */
  Rule_OpHeaderImpl_LParen_RParen,

  /* 166. <Op Header Impl> ::= '(' <Params> ')' '->' <Type> */
  Rule_OpHeaderImpl_LParen_RParen_MinusGt,

  /* 167. <Op Header Impl> ::= '(' ')' */
  Rule_OpHeaderImpl_LParen_RParen2,

  /* 168. <Op Header Impl> ::= '(' ')' '->' <Type> */
  Rule_OpHeaderImpl_LParen_RParen_MinusGt2,

  /* 169. <Var Decl> ::= let final <Var Header> */
  Rule_VarDecl_let_final,

  /* 170. <Var Decl> ::= let <Var Header> */
  Rule_VarDecl_let,

  /* 171. <Var Decl> ::= let local <Var Header> */
  Rule_VarDecl_let_local,

  /* 172. <Var Decl> ::= let local final <Var Header> */
  Rule_VarDecl_let_local_final,

  /* 173. <Var Decl> ::= let final local <Var Header> */
  Rule_VarDecl_let_final_local,

  /* 174. <Var Decl> ::= let atomic <Var Header> */
  Rule_VarDecl_let_atomic,

  /* 175. <Var Decl> ::= let local atomic <Var Header> */
  Rule_VarDecl_let_local_atomic,

  /* 176. <Var Decl> ::= let atomic local <Var Header> */
  Rule_VarDecl_let_atomic_local,

  /* 177. <CVar Decl> ::= let <Var Header> */
  Rule_CVarDecl_let,

  /* 178. <CVar Decl> ::= let final <Var Header> */
  Rule_CVarDecl_let_final,

  /* 179. <CVar Decl> ::= let final static <Var Header> */
  Rule_CVarDecl_let_final_static,

  /* 180. <CVar Decl> ::= let final <Visibility> <Var Header> */
  Rule_CVarDecl_let_final2,

  /* 181. <CVar Decl> ::= let final <Visibility> static <Var Header> */
  Rule_CVarDecl_let_final_static2,

  /* 182. <CVar Decl> ::= let final static <Visibility> <Var Header> */
  Rule_CVarDecl_let_final_static3,

  /* 183. <CVar Decl> ::= let static <Var Header> */
  Rule_CVarDecl_let_static,

  /* 184. <CVar Decl> ::= let static final <Var Header> */
  Rule_CVarDecl_let_static_final,

  /* 185. <CVar Decl> ::= let static atomic <Var Header> */
  Rule_CVarDecl_let_static_atomic,

  /* 186. <CVar Decl> ::= let static <Visibility> <Var Header> */
  Rule_CVarDecl_let_static2,

  /* 187. <CVar Decl> ::= let static <Visibility> atomic <Var Header> */
  Rule_CVarDecl_let_static_atomic2,

  /* 188. <CVar Decl> ::= let static <Visibility> final <Var Header> */
  Rule_CVarDecl_let_static_final2,

  /* 189. <CVar Decl> ::= let static atomic <Visibility> <Var Header> */
  Rule_CVarDecl_let_static_atomic3,

  /* 190. <CVar Decl> ::= let <Visibility> <Var Header> */
  Rule_CVarDecl_let2,

  /* 191. <CVar Decl> ::= let <Visibility> static <Var Header> */
  Rule_CVarDecl_let_static3,

  /* 192. <CVar Decl> ::= let <Visibility> static atomic <Var Header> */
  Rule_CVarDecl_let_static_atomic4,

  /* 193. <CVar Decl> ::= let <Visibility> final <Var Header> */
  Rule_CVarDecl_let_final3,

  /* 194. <CVar Decl> ::= let <Visibility> static final <Var Header> */
  Rule_CVarDecl_let_static_final3,

  /* 195. <CVar Decl> ::= let <Visibility> final static <Var Header> */
  Rule_CVarDecl_let_final_static4,

  /* 196. <CVar Decl> ::= let <Visibility> atomic static */
  Rule_CVarDecl_let_atomic_static,

  /* 197. <CVar Decl> ::= let atomic <Var Header> */
  Rule_CVarDecl_let_atomic,

  /* 198. <CVar Decl> ::= let atomic <Visibility> <Var Header> */
  Rule_CVarDecl_let_atomic2,

  /* 199. <CVar Decl> ::= let atomic static <Var Header> */
  Rule_CVarDecl_let_atomic_static2,

  /* 200. <CVar Decl> ::= let atomic <Visibility> static <Var Header> */
  Rule_CVarDecl_let_atomic_static3,

  /* 201. <CVar Decl> ::= let atomic static <Visibility> <Var Header> */
  Rule_CVarDecl_let_atomic_static4,

  /* 202. <Var Header> ::= <Id List> ':' <Type> '=' <CSE> */
  Rule_VarHeader_Colon_Eq,

  /* 203. <Var Header> ::= <Id List> ':' <Type> */
  Rule_VarHeader_Colon,

  /* 204. <Var Header> ::= <Id List> '=' <CSE> */
  Rule_VarHeader_Eq,

  /* 205. <Enum Decl> ::= enum Id '{' <Enum Def> '}' */
  Rule_EnumDecl_enum_Id_LBrace_RBrace,

  /* 206. <Enum Decl> ::= local enum Id '{' <Enum Def> '}' */
  Rule_EnumDecl_local_enum_Id_LBrace_RBrace,

  /* 207. <Enum Def> ::= Id ',' <Enum Def> */
  Rule_EnumDef_Id_Comma,

  /* 208. <Enum Def> ::= Id */
  Rule_EnumDef_Id,

  /* 209. <Type> ::= <Base> */
  Rule_Type,

  /* 210. <Type> ::= <Fn Type> */
  Rule_Type2,

  /* 211. <Type> ::= <Pkg Template> */
  Rule_Type3,

  /* 212. <Type> ::= <Type> '[' ']' */
  Rule_Type_LBracket_RBracket,

  /* 213. <Type> ::= '(' <Types> ')' */
  Rule_Type_LParen_RParen,

  /* 214. <Fn Type> ::= fn '(' ')' */
  Rule_FnType_fn_LParen_RParen,

  /* 215. <Fn Type> ::= fn '(' ')' '->' <Type> */
  Rule_FnType_fn_LParen_RParen_MinusGt,

  /* 216. <Fn Type> ::= fn '(' <Types> ')' */
  Rule_FnType_fn_LParen_RParen2,

  /* 217. <Fn Type> ::= fn '(' <Types> ')' '->' <Type> */
  Rule_FnType_fn_LParen_RParen_MinusGt2,

  /* 218. <Pkg Template> ::= <Pkg> */
  Rule_PkgTemplate,

  /* 219. <Pkg Template> ::= <Pkg> '<' <Types> '>' */
  Rule_PkgTemplate_Lt_Gt,

  /* 220. <Base> ::= <Sign> <Scalar> */
  Rule_Base,

  /* 221. <Base> ::= 'size_t' */
  Rule_Base_size_t,

  /* 222. <Base> ::= byte */
  Rule_Base_byte,

  /* 223. <Base> ::= float */
  Rule_Base_float,

  /* 224. <Base> ::= double */
  Rule_Base_double,

  /* 225. <Base> ::= bool */
  Rule_Base_bool,

  /* 226. <Base> ::= long double */
  Rule_Base_long_double,

  /* 227. <Sign> ::= signed */
  Rule_Sign_signed,

  /* 228. <Sign> ::= unsigned */
  Rule_Sign_unsigned,

  /* 229. <Sign> ::=  */
  Rule_Sign,

  /* 230. <Scalar> ::= char */
  Rule_Scalar_char,

  /* 231. <Scalar> ::= int */
  Rule_Scalar_int,

  /* 232. <Scalar> ::= short */
  Rule_Scalar_short,

  /* 233. <Scalar> ::= long */
  Rule_Scalar_long,

  /* 234. <Scalar> ::= short int */
  Rule_Scalar_short_int,

  /* 235. <Scalar> ::= long int */
  Rule_Scalar_long_int,

  /* 236. <Stm> ::= <Var Decl> */
  Rule_Stm,

  /* 237. <Stm> ::= <If Stm> */
  Rule_Stm2,

  /* 238. <Stm> ::= while <Expr> <Block> */
  Rule_Stm_while,

  /* 239. <Stm> ::= for <Arg> ';' <Arg> ';' <Arg> <Block> */
  Rule_Stm_for_Semi_Semi,

  /* 240. <Stm> ::= foreach <Param> in <Expr> <Block> */
  Rule_Stm_foreach_in,

  /* 241. <Stm> ::= <Normal Stm> */
  Rule_Stm3,

  /* 242. <Using Stm> ::= using <Pkg> */
  Rule_UsingStm_using,

  /* 243. <Using Stms> ::= <Using Stm> <Using Stms> */
  Rule_UsingStms,

  /* 244. <Using Stms> ::=  */
  Rule_UsingStms2,

  /* 245. <Pkg> ::= Id '.' <Pkg> */
  Rule_Pkg_Id_Dot,

  /* 246. <Pkg> ::= Id */
  Rule_Pkg_Id,

  /* 247. <If Stm> ::= if <Expr> <Block> <else-if> */
  Rule_IfStm_if,

  /* 248. <else-if> ::= else if <Expr> <Block> <else-if> */
  Rule_elseif_else_if,

  /* 249. <else-if> ::= else <Block> */
  Rule_elseif_else,

  /* 250. <else-if> ::=  */
  Rule_elseif,

  /* 251. <Normal Stm> ::= do <Block> while <Expr> */
  Rule_NormalStm_do_while,

  /* 252. <Normal Stm> ::= match <Expr> '{' <Case Stms> '}' */
  Rule_NormalStm_match_LBrace_RBrace,

  /* 253. <Normal Stm> ::= <Block> */
  Rule_NormalStm,

  /* 254. <Normal Stm> ::= <Expr> */
  Rule_NormalStm2,

  /* 255. <Normal Stm> ::= break */
  Rule_NormalStm_break,

  /* 256. <Normal Stm> ::= continue */
  Rule_NormalStm_continue,

  /* 257. <Normal Stm> ::= return <Expr> */
  Rule_NormalStm_return,

  /* 258. <Normal Stm> ::= return */
  Rule_NormalStm_return2,

  /* 259. <Normal Stm> ::= ';' */
  Rule_NormalStm_Semi,

  /* 260. <Arg> ::= <Expr> */
  Rule_Arg,

  /* 261. <Arg> ::=  */
  Rule_Arg2,

  /* 262. <Case Stms> ::= case <Expr> when <Expr> <Block> <Case Stms> */
  Rule_CaseStms_case_when,

  /* 263. <Case Stms> ::= case <Expr> <Block> <Case Stms> */
  Rule_CaseStms_case,

  /* 264. <Case Stms> ::= else <Block> */
  Rule_CaseStms_else,

  /* 265. <Block> ::= '{' <Using Stms> <Stm List> '}' */
  Rule_Block_LBrace_RBrace,

  /* 266. <Block> ::= synchronized '{' <Using Stms> <Stm List> '}' */
  Rule_Block_synchronized_LBrace_RBrace,

  /* 267. <Stm List> ::= <Stm> <Stm List> */
  Rule_StmList,

  /* 268. <Stm List> ::=  */
  Rule_StmList2,

  /* 269. <CSE> ::= <Expr> */
  Rule_CSE,

  /* 270. <CSE> ::= <CSE> ',' <Expr> */
  Rule_CSE_Comma,

  /* 271. <Expr> ::= <Var Decl> in <Expr> */
  Rule_Expr_in,

  /* 272. <Expr> ::= match <Expr> '{' <Case Exprs> '}' */
  Rule_Expr_match_LBrace_RBrace,

  /* 273. <Expr> ::= <Op Assign> */
  Rule_Expr,

  /* 274. <Op Assign> ::= <Op Or> '=' <Op Assign> */
  Rule_OpAssign_Eq,

  /* 275. <Op Assign> ::= <Op Or> '+=' <Op Assign> */
  Rule_OpAssign_PlusEq,

  /* 276. <Op Assign> ::= <Op Or> '-=' <Op Assign> */
  Rule_OpAssign_MinusEq,

  /* 277. <Op Assign> ::= <Op Or> '*=' <Op Assign> */
  Rule_OpAssign_TimesEq,

  /* 278. <Op Assign> ::= <Op Or> '/=' <Op Assign> */
  Rule_OpAssign_DivEq,

  /* 279. <Op Assign> ::= <Op Or> '%=' <Op Assign> */
  Rule_OpAssign_PercentEq,

  /* 280. <Op Assign> ::= <Op Or> '^=' <Op Assign> */
  Rule_OpAssign_CaretEq,

  /* 281. <Op Assign> ::= <Op Or> '&=' <Op Assign> */
  Rule_OpAssign_AmpEq,

  /* 282. <Op Assign> ::= <Op Or> '|=' <Op Assign> */
  Rule_OpAssign_PipeEq,

  /* 283. <Op Assign> ::= <Op Or> '>>=' <Op Assign> */
  Rule_OpAssign_GtGtEq,

  /* 284. <Op Assign> ::= <Op Or> '<<=' <Op Assign> */
  Rule_OpAssign_LtLtEq,

  /* 285. <Op Assign> ::= <Op Or> */
  Rule_OpAssign,

  /* 286. <Op Or> ::= <Op Or> '||' <Op And> */
  Rule_OpOr_PipePipe,

  /* 287. <Op Or> ::= <Op And> */
  Rule_OpOr,

  /* 288. <Op And> ::= <Op And> '&&' <Op BinOR> */
  Rule_OpAnd_AmpAmp,

  /* 289. <Op And> ::= <Op BinOR> */
  Rule_OpAnd,

  /* 290. <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> */
  Rule_OpBinOR_Pipe,

  /* 291. <Op BinOR> ::= <Op BinXOR> */
  Rule_OpBinOR,

  /* 292. <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> */
  Rule_OpBinXOR_Caret,

  /* 293. <Op BinXOR> ::= <Op BinAND> */
  Rule_OpBinXOR,

  /* 294. <Op BinAND> ::= <Op BinAND> '&' <Op Equate> */
  Rule_OpBinAND_Amp,

  /* 295. <Op BinAND> ::= <Op Equate> */
  Rule_OpBinAND,

  /* 296. <Op Equate> ::= <Op Equate> '==' <Op Compare> */
  Rule_OpEquate_EqEq,

  /* 297. <Op Equate> ::= <Op Equate> '!=' <Op Compare> */
  Rule_OpEquate_ExclamEq,

  /* 298. <Op Equate> ::= <Op Compare> */
  Rule_OpEquate,

  /* 299. <Op Compare> ::= <Op Compare> '<' <Op Shift> */
  Rule_OpCompare_Lt,

  /* 300. <Op Compare> ::= <Op Compare> '>' <Op Shift> */
  Rule_OpCompare_Gt,

  /* 301. <Op Compare> ::= <Op Compare> '<=' <Op Shift> */
  Rule_OpCompare_LtEq,

  /* 302. <Op Compare> ::= <Op Compare> '>=' <Op Shift> */
  Rule_OpCompare_GtEq,

  /* 303. <Op Compare> ::= <Op Compare> is <Type> */
  Rule_OpCompare_is,

  /* 304. <Op Compare> ::= <Op Shift> */
  Rule_OpCompare,

  /* 305. <Op Shift> ::= <Op Shift> '<<' <Op Add> */
  Rule_OpShift_LtLt,

  /* 306. <Op Shift> ::= <Op Shift> '>>' <Op Add> */
  Rule_OpShift_GtGt,

  /* 307. <Op Shift> ::= <Op Add> */
  Rule_OpShift,

  /* 308. <Op Add> ::= <Op Add> '+' <Op Mult> */
  Rule_OpAdd_Plus,

  /* 309. <Op Add> ::= <Op Add> '-' <Op Mult> */
  Rule_OpAdd_Minus,

  /* 310. <Op Add> ::= <Op Mult> */
  Rule_OpAdd,

  /* 311. <Op Mult> ::= <Op Mult> '*' <Op Unary> */
  Rule_OpMult_Times,

  /* 312. <Op Mult> ::= <Op Mult> '/' <Op Unary> */
  Rule_OpMult_Div,

  /* 313. <Op Mult> ::= <Op Mult> '%' <Op Unary> */
  Rule_OpMult_Percent,

  /* 314. <Op Mult> ::= <Op Unary> */
  Rule_OpMult,

  /* 315. <Op Unary> ::= '!' <Op Unary> */
  Rule_OpUnary_Exclam,

  /* 316. <Op Unary> ::= '~' <Op Unary> */
  Rule_OpUnary_Tilde,

  /* 317. <Op Unary> ::= '-' <Op Unary> */
  Rule_OpUnary_Minus,

  /* 318. <Op Unary> ::= '++' <Op Unary> */
  Rule_OpUnary_PlusPlus,

  /* 319. <Op Unary> ::= '--' <Op Unary> */
  Rule_OpUnary_MinusMinus,

  /* 320. <Op Unary> ::= <Op Pointer> '++' */
  Rule_OpUnary_PlusPlus2,

  /* 321. <Op Unary> ::= <Op Pointer> '--' */
  Rule_OpUnary_MinusMinus2,

  /* 322. <Op Unary> ::= <Op Unary> as <Type> */
  Rule_OpUnary_as,

  /* 323. <Op Unary> ::= <New Expr> */
  Rule_OpUnary,

  /* 324. <Op Unary> ::= delete <Op Pointer> */
  Rule_OpUnary_delete,

  /* 325. <Op Unary> ::= sizeof '(' <Type> ')' */
  Rule_OpUnary_sizeof_LParen_RParen,

  /* 326. <Op Unary> ::= <Op Pointer> */
  Rule_OpUnary2,

  /* 327. <Op Pointer> ::= <Op Pointer> '.' <Value> */
  Rule_OpPointer_Dot,

  /* 328. <Op Pointer> ::= <Op Pointer> '[' <CSE> ']' */
  Rule_OpPointer_LBracket_RBracket,

  /* 329. <Op Pointer> ::= <Op Pointer> '(' <CSE> ')' */
  Rule_OpPointer_LParen_RParen,

  /* 330. <Op Pointer> ::= <Op Pointer> '(' ')' */
  Rule_OpPointer_LParen_RParen2,

  /* 331. <Op Pointer> ::= <Value> */
  Rule_OpPointer,

  /* 332. <Value> ::= OctLiteral */
  Rule_Value_OctLiteral,

  /* 333. <Value> ::= HexLiteral */
  Rule_Value_HexLiteral,

  /* 334. <Value> ::= DecLiteral */
  Rule_Value_DecLiteral,

  /* 335. <Value> ::= BinLiteral */
  Rule_Value_BinLiteral,

  /* 336. <Value> ::= StringLiteral */
  Rule_Value_StringLiteral,

  /* 337. <Value> ::= CharLiteral */
  Rule_Value_CharLiteral,

  /* 338. <Value> ::= FloatLiteral */
  Rule_Value_FloatLiteral,

  /* 339. <Value> ::= null */
  Rule_Value_null,

  /* 340. <Value> ::= '_' */
  Rule_Value__,

  /* 341. <Value> ::= true */
  Rule_Value_true,

  /* 342. <Value> ::= false */
  Rule_Value_false,

  /* 343. <Value> ::= <Pkg> */
  Rule_Value,

  /* 344. <Value> ::= <Lambda Expr> */
  Rule_Value2,

  /* 345. <Value> ::= '(' <CSE> ')' */
  Rule_Value_LParen_RParen,

  /* 346. <Value> ::= '[' for Id ':' <Type> in <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Id_Colon_in_EqGt_RBracket,

  /* 347. <Value> ::= '[' for Id in <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Id_in_EqGt_RBracket,

  /* 348. <Value> ::= '[' for Id ':' <Type> in <Expr> if <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Id_Colon_in_if_EqGt_RBracket,

  /* 349. <Value> ::= '[' for Id in <Expr> if <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Id_in_if_EqGt_RBracket,

  /* 350. <Value> ::= '[' <CSE> ']' */
  Rule_Value_LBracket_RBracket,

  /* 351. <Lambda Expr> ::= lambda '(' <Params> ')' <Block> */
  Rule_LambdaExpr_lambda_LParen_RParen,

  /* 352. <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> */
  Rule_LambdaExpr_lambda_LParen_RParen_Eq,

  /* 353. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> */
  Rule_LambdaExpr_lambda_LParen_RParen_MinusGt,

  /* 354. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> */
  Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq,

  /* 355. <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> */
  Rule_CaseExprs_case_when_EqGt,

  /* 356. <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> */
  Rule_CaseExprs_case_EqGt,

  /* 357. <Case Exprs> ::= else '=>' <Expr> */
  Rule_CaseExprs_else_EqGt,

  /* 358. <New Expr> ::= new <Pkg Template> '(' ')' */
  Rule_NewExpr_new_LParen_RParen,

  /* 359. <New Expr> ::= new <Pkg Template> '(' <Expr> ')' */
  Rule_NewExpr_new_LParen_RParen2,

  /* 360. <New Expr> ::= new <Pkg Template> '(' ')' '{' <CDecl> '}' */
  Rule_NewExpr_new_LParen_RParen_LBrace_RBrace,

  /* 361. <New Expr> ::= new <Pkg Template> '(' <Expr> ')' '{' <CDecl> '}' */
  Rule_NewExpr_new_LParen_RParen_LBrace_RBrace2,

  /* 362. <New Expr> ::= new <Type> */
  Rule_NewExpr_new,

  /* 363. <New Expr> ::= new <Type> '[' <Expr> ']' */
  Rule_NewExpr_new_LBracket_RBracket 
  };




/***** Main *****************************************************************/




/* Load input file from disk into memory. */
wchar_t *LoadInputFile(char *FileName) {
  FILE *Fin;
  char *Buf1;
  wchar_t *Buf2;
  struct stat statbuf;
  size_t BytesRead;
  unsigned long i;

  /* Sanity check. */
  if ((FileName == NULL) || (*FileName == '\0')) return(NULL);

  /* Open the file. */
  Fin = fopen(FileName,"rb");
  if (Fin == NULL) {
    fprintf(stdout,"Could not open input file:     return(NULL);
    }

  /* Get the size of the file. */
  if (fstat(fileno(Fin),&statbuf) != 0) {
    fprintf(stdout,"Could not stat() the input file:     fclose(Fin);
    return(NULL);
    }

  /* Allocate memory for the input. */
  Buf1 = (char *)malloc(statbuf.st_size + 1);
  Buf2 = (wchar_t *)malloc(sizeof(wchar_t) * (statbuf.st_size + 1));
  if ((Buf1 == NULL) || (Buf2 == NULL)) {
    fprintf(stdout,"Not enough memory to load the file:     fclose(Fin);
    if (Buf1 != NULL) free(Buf1);
    if (Buf2 != NULL) free(Buf2);
    return(NULL);
    }

  /* Load the file into memory. */
  BytesRead = fread(Buf1,1,statbuf.st_size,Fin);
  Buf1[BytesRead] = '\0';

  /* Close the file. */
  fclose(Fin);

  /* Exit if there was an error while reading the file. */
  if (BytesRead != statbuf.st_size) {
    fprintf(stdout,"Error while reading input file:     free(Buf1);
    free(Buf2);
    return(NULL);
    }

  /* Convert from ASCII to Unicode. */
  for (i = 0; i <= BytesRead; i++) Buf2[i] = Buf1[i];
  free(Buf1);

  return(Buf2);
  }




void ShowErrorMessage(struct TokenStruct *Token, int Result) {
  int Symbol;
  int i;
  wchar_t s1[BUFSIZ];

  switch(Result) {
    case PARSELEXICALERROR:
      fprintf(stdout,"Lexical error");
      break;
    case PARSECOMMENTERROR:
      fprintf(stdout,"Comment error");
      break;
    case PARSETOKENERROR:
      fprintf(stdout,"Tokenizer error");
      break;
    case PARSESYNTAXERROR:
      fprintf(stdout,"Syntax error");
      break;
    case PARSEMEMORYERROR:
      fprintf(stdout,"Out of memory");
      break;
    }
  if (Token != NULL) fprintf(stdout," at line d",Token->Line,Token->Column);
  fprintf(stdout,".\n");

  if (Result == PARSELEXICALERROR) {
    if (Token->Data != NULL) {
        ReadableString(Token->Data,s1,BUFSIZ);
        fprintf(stdout,"The grammar does not specify what to do with '      } else {
        fprintf(stdout,"The grammar does not specify what to do.\n");
        }
    }
  if (Result == PARSETOKENERROR) {
    fprintf(stdout,"The tokenizer returned a non-terminal.\n");
    }
  if (Result == PARSECOMMENTERROR) {
    fprintf(stdout,"The comment has no end, it was started but not finished.\n");
    }
  if (Result == PARSESYNTAXERROR) {
    if (Token->Data != NULL) {
        ReadableString(Token->Data,s1,BUFSIZ);
        fprintf(stdout,"Encountered '      } else {
        fprintf(stdout,"Expected ");
        }
    for (i = 0; i < Grammar.LalrArray[Token->Symbol].ActionCount; i++) {
      Symbol = Grammar.LalrArray[Token->Symbol].Actions[i].Entry;
      if (Grammar.SymbolArray[Symbol].Kind == SYMBOLTERMINAL) {
        if (i > 0) {
          fprintf(stdout,", ");
          if (i >= Grammar.LalrArray[Token->Symbol].ActionCount - 2) fprintf(stdout,"or ");
          }
        fprintf(stdout,"'        }
      }
    fprintf(stdout,".\n");
    }
  }




int main(int argc, char *argv[]){
  wchar_t *InputBuf;
  struct TokenStruct *Token;
  struct ContextStruct Context;
  int Result;

  /* Load the inputfile into memory. */
  InputBuf = LoadInputFile("Example.input");
  if (InputBuf == NULL) exit(1);

  /* Run the Parser. */
  Result = Parse(InputBuf,wcslen(InputBuf),TRIMREDUCTIONS,DEBUG,&Token);

  /* Interpret the results. */
  if (Result != PARSEACCEPT) {
      ShowErrorMessage(Token,Result);
    } else {
      /* Initialize the Context. */
      Context.Debug = DEBUG;
      Context.Indent = 0;
      Context.ReturnValue = NULL;

      /* Start execution by calling the subroutine of the first Token on
         the TokenStack. It's the "Start Symbol" that is defined in the
         grammar. */
      RuleJumpTable[Token->ReductionRule](Token,&Context);
      }

  /* Cleanup. */
  DeleteTokens(Token);
  free(InputBuf);
  }
